/**
 * Duik Rigging Tools
 * @author Nicolas Dufresne, Kevin Masson and contributors
 * @copyright 2017,2018 Nicolas Dufresne, Rainbox Productions<br />
 * {@link https://rainboxprod.coop}
 * @namespace
 * @memberof DuAEF.Duik
 * @license GPL-3.0 <br />
 * DuAEF is free software: you can redistribute it and/or modify<br />
 * it under the terms of the GNU General Public License as published by<br />
 * the Free Software Foundation, either version 3 of the License, or<br />
 * (at your option) any later version.<br />
 *<br />
 * DuAEF is distributed in the hope that it will be useful,<br />
 * but WITHOUT ANY WARRANTY; without even the implied warranty of<br />
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br />
 * GNU General Public License for more details.<br />
 *<br />
 * You should have received a copy of the GNU General Public License<br />
 * along with DuAEF. If not, see {@link http://www.gnu.org/licenses/}.
 */
DuAEF.Duik.Rigging = {};

/**
 * Chain Rig types
 * @enum {int}
 * @readonly
 */
DuAEF.Duik.Rigging.chainTypes =
{
	IK: 0,
	FK: 1,
	BEZIER: 2
}

/**
	* Adds a zero to a layer
	* @param {Layer} layer - The layer
	* @return {AVLayer} The zero, a null
*/
DuAEF.Duik.Rigging.addZero = function (layer)
{
	//create null object
	var zero = layer.containingComp.layers.addNull();
	DuAEF.Dugr.addLayerToGroup(zero,"Zeros");
	var layerparent = layer.parent;
	layer.parent = null;
	zero.position.setValue(layer.position.value);
	zero.rotation.setValue(layer.rotation.value);
	zero.name = "Zero | " + layer.name.slice(-24);
	layer.parent = zero;
	zero.scale.setValue(layer.scale.value);
	layer.scale.setValue([100,100,100]);

	DuAEF.Duik.setDuikMarker(zero,"Zero",DuAEF.Duik.LayerTypes.ZERO);

	//parent
	zero.parent = layerparent;

	//lock and hide
	zero.moveToEnd();
	zero.guideLayer = true;
	zero.shy = true;
	zero.enabled = false;
	zero.selected = false;
	zero.locked = true;
	return zero;
}

/**
	* Adds a locator to a layer
	* @param {Layer|CompItem} [layerOrComp=DuAEF.DuAE.Project.getActiveComp()] - The layer or the containing comp, to add a standalone locator.
	* @return {AVLayer} The locator, a null object
*/
DuAEF.Duik.Rigging.addLocator = function (layerOrComp)
{
	var layer = null;
	var comp = null;
	if (typeof layerOrComp === 'undefined') comp = DuAEF.DuAE.Project.getActiveComp();
	else if (layerOrComp instanceof CompItem) comp = layerOrComp;
	else
	{
		layer = layerOrComp;
		comp = layer.containingComp;
	}
	if (!comp) return;

	//create null object
	var loc = comp.layers.addNull();
	var name = 'LOC';
	if (layer) name = DuAEF.Duik.generateName('LOC', layer.name);
	loc.name = DuAEF.DuAE.Comp.newUniqueLayerName(name,comp);
	DuAEF.Dugr.addLayerToGroup(loc,"Locators");

	//add layer control
	var layerfx = loc.property('ADBE Effect Parade').addProperty('ADBE Layer Control');
	layerfx.name = "Locator";
	if (layer) layerfx(1).setValue(layer.index);

	//add expressions
	loc.transform.rotation.expression = 'var result = 0;\n' +
		'var l = null;\n' +
		'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }\n' +
		'if (l)\n' +
		'{\n' +
		'result = l.rotation;\n' +
		'while(l.hasParent)\n' +
		'{\n' +
		'l = l.parent;\n' +
		'result += l.rotation;\n' +
		'}\n' +
		'}\n' +
		'if (hasParent)\n' +
		'{\n' +
		'var p =thisLayer;\n' +
		'while (p.hasParent)\n' +
		'{\n' +
		'p = p.parent;\n' +
		'result -= p.rotation;\n' +
		'}\n' +
		'}\n' +
		'result;';

	loc.transform.position.expression = 'var result = [thisComp.width/2,thisComp.height/2];\n' +
		'var l = null;\n' +
		'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }\n' +
		'if (l)\n' +
		'{\n' +
		'result = l.toWorld(l.anchorPoint);\n' +
		'}\n' +
		'if (hasParent)\n' +
		'{\n' +
		'result = parent.fromWorld(result);\n' +
		'}\n' +
		'result;';

	loc.transform.anchorPoint.expression = 'var result = value;\n' +
		'var l = null;\n' +
		'try{ l = effect("' + layerfx.name + '")(1) } catch(e) { }\n' +
		'if (l)\n' +
		'{\n' +
		'result =l.anchorPoint.value;\n' +
		'}\n' +
		'result;';

	DuAEF.Duik.setDuikMarker(loc,"Locator",DuAEF.Duik.LayerTypes.LOCATOR);


	return loc;
}

/**
	* Extracts locators from a precomposition
	* @param {AVLayer} [preCompLayer] - The precomposition layer
	* @return {AVLayer[]} The extracted locators
*/
DuAEF.Duik.Rigging.extractLocators = function (preCompLayer)
{
	var preComp = preCompLayer.source;
	if (!preComp instanceof CompItem) return;

	//get locators in precomp
	var preCompLocs = DuAEF.Duik.getLayers(DuAEF.Duik.LayerTypes.LOCATOR,false,preComp);

	var locs = [];

	var it = new Iterator(preCompLocs);
	it.do(function(preCompLoc)
	{
		locs.push(DuAEF.Duik.Rigging.extractLocator(preCompLoc,preCompLayer));
	});

	return locs;
}

/**
	* Extracts one locator from a precomposition
	* @param {AVLayer} [preCompLayer] - The precomposition layer
	* @param {AVLayer} [locator] - The locator to extract
	* @return {AVLayer} The extracted locator
*/
DuAEF.Duik.Rigging.extractLocator = function(locator,preCompLayer)
{
	var comp = preCompLayer.containingComp;
	//comp names
	DuAEF.DuAE.Comp.setUniqueCompName(comp);
	DuAEF.DuAE.Comp.setUniqueCompName(locator.containingComp);
	//create a null in the comp
	var loc = comp.layers.addNull();
	loc.name = DuAEF.DuAE.Comp.newUniqueLayerName(locator.name,comp);
	loc.parent = preCompLayer;
	DuAEF.Dugr.addLayerToGroup(loc,"Locators");
	DuAEF.Duik.setDuikMarker(loc,"Locator",DuAEF.Duik.LayerTypes.LOCATOR);
	DuAEF.DuAE.Property.linkProperties(loc.transform,locator.transform);
	return loc;
}

/**
	* Parents two layers even if the parent is in the parent comp or a precomp.
	* @param {Layer[]} children - The child layer(s)
	* @param {Layer} parent - The parent layer
*/
DuAEF.Duik.Rigging.parent = function(children,parent)
{
	if (typeof children === 'undefined') throw "You must provide children to parent.";
	if (typeof children.length === 'undefined') children = [children];

	var parentComp = parent.containingComp;

	//create the parent locator
	var locator = DuAEF.Duik.Rigging.addLocator(parent);
	//the children locators
	var childLocators = [];

	new Iterator(children).do(function(child)
	{
		var childComp = child.containingComp;

		//check if there already is a child locator
		var childLocator = null;
		for (var i = 0, num = childLocators.length; i < num; i++)
		{
			if (childLocators[i].containingComp.id == childComp.id)
			{
				childLocator = childLocators[i];
				break;
			}
		}

		//if precomp
		var precomps = DuAEF.DuAE.Comp.getPrecomps(childComp);

		if (DuAEF.DuJS.Array.indexOf(precomps,parentComp) >= 0)
		{
			//select the first precomp layer
			var precompLayer;
			for (var i = 1, num = childComp.numLayers; i <= num; i++)
			{
				var l = childComp.layer(i);
				if (l.source)
				{
					if (l.source.id == parentComp.id)
					{
						precompLayer = l;
						break;
					}
				}
			}

			//create the child Locator
			if (!childLocator)
			{
				//create a locator and extract it
				var childLocator = DuAEF.Duik.Rigging.extractLocator(locator,precompLayer);
				childLocator.selected = false;
				childLocator.enabled = false;
				childLocator.shy = true;
				childLocator.locked = true;
				childLocators.push(childLocator);
			}

			child.parent = childLocator;
			child.selected = true;
			return;
		}

		//if parent comp
		var parentComps = DuAEF.DuAE.Comp.getParentComps(childComp);
		if (DuAEF.DuJS.Array.indexOf(parentComps,parentComp) >= 0)
		{
			//select the first precomp layer
			var precompLayer;
			for (var i = 1, num = parentComp.numLayers; i <= num; i++)
			{
				var l = parentComp.layer(i);
				if (l.source == childComp)
				{
					precompLayer = l;
					break;
				}
			}

			//create a locator and extract it
			locator.parent = precompLayer;

			//create the child Locator
			if (!childLocator)
			{
				//create a null in the comp
				var childLocator = childComp.layers.addNull();
				childLocator.name = DuAEF.DuAE.Comp.newUniqueLayerName(locator.name,childComp);
				DuAEF.Duik.setDuikMarker(childLocator,"Locator",DuAEF.Duik.LayerTypes.LOCATOR);
				DuAEF.DuAE.Property.linkProperties(childLocator.transform,locator.transform);
				//lock and hide
				childLocator.selected = false;
				childLocator.enabled = false;
				childLocator.shy = true;
				childLocator.locked = true;
				childLocators.push(childLocator);
			}

			child.parent = childLocator;
			child.selected = true;

			return;
		}

	});

	//lock and hide
	locator.selected = false;
	locator.enabled = false;
	locator.locked = true;
	locator.shy = true;
	parent.selected = true;

}

/**
	* Adds an orientation constraint to a layer
	* @param {Layer} layer - The layer
*/
DuAEF.Duik.Rigging.orientationConstraint = function (layer)
{
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.ORIENTATION,DuAEF.Duik.PseudoEffectsMatchNames.ORIENTATION,'Orientation constraint');

	layer.rotation.expression = '//Duik.orientationConstraint\n' +
						'function o(l)\n' +
						'{\n' +
						'var r = 0;\n' +
						'r += l.rotation;\n' +
						'while(l.hasParent)\n' +
						'{\n' +
						'l = l.parent;\n' +
						'r += l.rotation;\n' +
						'}\n' +
						'return r;\n' +
						'}\n' +
						'var result = value;\n' +
						'var p = thisLayer;\n' +
						'while(p.hasParent)\n' +
						'{\n' +
						'p = p.parent;\n' +
						'result -= p.rotation.value;\n' +
						'}\n' +
						'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
						'{\n' +
						'var fx = effect(i) ;\n' +
						'if (fx.name.indexOf("Orientation constraint") == 0)\n' +
						'{\n' +
						'var l = null;\n' +
						'try { l = fx(1); } catch (e){}\n' +
						'if (l) result += o(l)*(fx(2).value/100);\n' +
						'}\n' +
						'}\n' +
						'result;';

}

/**
	* Adds a position constraint to a layer
	* @param {Layer} layer - The layer
*/
DuAEF.Duik.Rigging.positionConstraint = function (layer)
{
	var effect = DuAEF.Duik.PseudoEffects.POSITION.apply(layer);
	effect(DuAEF.Duik.PseudoEffects.POSITION.weightSlider).setValue(0);

	layer.position.expression = '//Duik.positionConstraint\n' +
								'var result = value;\n' +
								'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
								'{\n' +
								'var fx = effect(i) ;\n' +
								'if (fx.name.indexOf("' + effect.name + '") == 0)\n' +
								'{\n' +
								'var l = null;\n' +
								'try { l = fx(1); } catch (e){}\n' +
								'if (l)\n' +
								'{\n' +
								'var cp = l.toWorld(l.anchorPoint);\n' +
								'if (thisLayer.hasParent) cp = thisLayer.parent.fromWorld(cp);\n' +
								'cp0 = l.toWorld(l.anchorPoint,0);\n' +
								'if (thisLayer.hasParent) cp0 = thisLayer.parent.fromWorld(cp0);\n' +
								'cp -= cp0;\n' +
								'result += cp*(fx(2).value/100);\n' +
								'}\n' +
								'}\n' +
								'}\n' +
								'result;';
}

/**
	* Adds a path constraint to a layer
	* @param {Layer} layer - The layer
	* @param {Property|PropertyInfo} path - The path property
*/
DuAEF.Duik.Rigging.pathConstraint = function (layer,path)
{
	if (path instanceof PropertyInfo) path = path.getProperty();

	var effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.PATH,DuAEF.Duik.PseudoEffectsMatchNames.PATH,'Path constraint');

	var l = DuAEF.DuAE.Property.getLayer(path);
	var pathExpr = DuAEF.DuAE.Property.getExpressionLink(path,true);

	var previous = layer.position.value;
	layer.position.expression = '//Duik.positionConstraint\n' +
								'var fx = effect("' + effect.name + '");\n' +
								'var l = thisComp.layer("' + l.name + '");\n' +
								'var p = ' + pathExpr + ';\n' +
								'var percent = fx(1)%100/100;\n' +
								'p.pointOnPath(percent, time)+l.position+value;';

	layer.position.setValue(previous - (layer.position.value-previous));
}

/**
	* Adds a parent constraint to a layer
	* @param {Layer} layer - The layer
*/
DuAEF.Duik.Rigging.parentConstraint = function (layer)
{
	var effect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.PARENT,DuAEF.Duik.PseudoEffectsMatchNames.PARENT,'Parent link');

	var posExpr = '//Duik.parent\n' +
		'function getParentTransform(l,origin,sF,eF)\n' +
		'{\n' +
		'var sT = framesToTime(sF);\n' +
		'var eT = framesToTime(eF);\n' +
		'try { var pos = l.fromWorld( origin , sT ) ; }\n' +
		'catch (e) { var pos = [0,0]; }\n' +
		'var prevPos = l.toWorld( pos , sT );\n' +
		'var newPos =  l.toWorld( pos , eT );\n' +
		'return newPos - prevPos;\n' +
		'}\n' +
		'var result = thisLayer.position.valueAtTime(0);\n' +
		'var cF = 1;\n' +
		'while (cF <= timeToFrames())\n' +
		'{\n' +
		'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
		'{\n' +
		'var fx = effect(i);\n' +
		'if (fx.name.indexOf("Parent link") != 0) continue;\n' +
		'if (!fx(4).value) continue;\n' +
		'try { var parentLayer = fx(1); } catch (e){ continue; }\n' +
		'if (parentLayer.index == index) continue;\n' +
		'var weight = fx(2).valueAtTime( framesToTime(cF) ) / 100;\n' +
		'if (weight == 0) continue;\n' +
		'result += getParentTransform( parentLayer , result , cF-1 , cF )*weight;\n' +
		'}\n' +
		'result += valueAtTime(framesToTime(cF)) - valueAtTime(framesToTime(cF-1));\n' +
		'cF++;\n' +
		'}\n' +
		'result;';

	if (layer.position.dimensionsSeparated)
	{
		layer.transform.xPosition.expression = posExpr + '\nresult[0];';

		layer.transform.yPosition.expression = posExpr + '\nresult[1];';
	}
	else
	{
		layer.position.expression = posExpr;
	}

	layer.rotation.expression = '//Duik.parent\n' +
						'function o(l,t)\n' +
						'{\n' +
						'if (t == undefined) t = time;\n' +
						'var r = 0;\n' +
						'r += l.rotation.valueAtTime(t);\n' +
						'while(l.hasParent)\n' +
						'{\n' +
						'l = l.parent;\n' +
						'r += l.rotation.valueAtTime(t);\n' +
						'}\n' +
						'return r;\n' +
						'}\n' +
						'var result = value;\n' +
						'for (var i = 1 ; i <= thisLayer("Effects").numProperties ; i++)\n' +
						'{\n' +
						'var fx = effect(i) ;\n' +
						'if (fx.name.indexOf("Parent link") != 0) continue;\n' +
						'if (!fx(5).value) continue;\n' +
						'try { var l = fx(1); } catch (e){ continue; }\n' +
						'if (l.index == index) continue;\n' +
						'if ( fx(2).numKeys < 2 )\n' +
						'{\n' +
						'var w = fx(2).value/100;\n' +
						'if (w == 0) continue;\n' +
						'var P = o(l);\n' +
						'var oP = o(l,0);\n' +
						'result += (P - oP)*w;\n' +
						'}\n' +
						'else\n' +
						'{\n' +
						'var frame = timeToFrames(time);\n' +
						'for (var j = frame;j>=0;j--)\n' +
						'{\n' +
						'var t = framesToTime(j);\n' +
						'var prevT = framesToTime(j-1);\n' +
						'var w = fx(2).valueAtTime(t)/100;\n' +
						'var P = o(l,t);\n' +
						'var oP = o(l,prevT);\n' +
						'result += (P - oP)*w;\n' +
						'}\n' +
						'}\n' +
						'}\n' +
						'result;';

	if (layer.parent != null)
	{
		var comp = layer.containingComp;
		var time = comp.time;
		comp.time = 0;
		var parent = layer.parent;
		layer.parent = null;
		effect(1).setValue(parent.index);
		comp.time = time;
	}
}

/**
	* Checks if the property can be used as parent with the connector
	* @param {Property|PropertyInfo} prop - The property
	* @return {int} 0 if the prop can not be used as parent, or the number of the dimensions of the property (4 = color)
*/
DuAEF.Duik.Rigging.connectorCheckParent = function (prop)
{
	if (!(prop instanceof PropertyInfo)) prop = new PropertyInfo(prop);
	if (prop.getProperty().propertyType != PropertyType.PROPERTY) return 0;

	//check dimensions
	var dim = DuAEF.DuAE.Property.getDimensions(prop);
	return dim;
}

/**
	* Applies connector to the property
	* @param {Property|PropertyInfo} childProp - The child property
	* @param {Property|PropertyInfo} parentProp - The parent property
	* @param {PropertyGroup|PropertyInfo|null} [parentEffect] - The effect of an already existing connector
	* @param {float} [minValue=0] - The minimum value
	* @param {float} [maxValue=100] - The maximum value
	* @param {DuAEF.DuAE.Axis} [axis=DuAEF.DuAE.Axis.X] - The axis or channel to connect
	* @param {DuAEF.DuAE.Types} [axis=DuAEF.DuAE.Types.VALUE] - The type
	* @return {PropertyGroup} The controlling effect created
*/
DuAEF.Duik.Rigging.connector = function (childProp, parentProperty, parentEffect, minValue, maxValue, axis, type)
{
	if (typeof minValue === 'undefined') minValue = null;
	if (typeof maxValue === 'undefined') maxValue = null;
	if (typeof axis === 'undefined') axis = DuAEF.DuAE.Axis.X;
	if (typeof type === 'undefined') axis = DuAEF.DuAE.Types.VALUE;
	if (typeof parentEffect === 'undefined') parentEffect = null;

	if (!(childProp instanceof PropertyInfo)) childProp = new PropertyInfo(childProp);
	var parentProp = parentProperty;
	if (!(parentProperty instanceof PropertyInfo)) parentProp = new PropertyInfo(parentProperty);

	DuAEF.DuAE.Comp.setUniqueCompName(parentProperty.comp);
	DuAEF.DuAE.Comp.setUniqueCompName(childProp.comp);

	if (!childProp.riggable) return null;

	var dim = DuAEF.Duik.Rigging.connectorCheckParent(parentProp);
	if (dim == 0) return null;

	var parentLayer = DuAEF.DuAE.Property.getLayer(parentProp);

	//Adjust minimum value
	if (!isNaN(minValue))
	{
		if (dim == 4)
		{
			if (app.project.bitsPerChannel == 8) minValue = minValue / 255;
			if (app.project.bitsPerChannel == 16) minValue = minValue / 32768;
			if (app.project.bitsPerChannel == 32 && minValue < 0) minValue = 0;
			if (app.project.bitsPerChannel == 32 && minValue > 1) minValue = 1;
		}
	}
	else minValue = 0;

	//adjust maximum value
	if (!isNaN(maxValue))
	{
		if (dim == 4)
		{
			if (app.project.bitsPerChannel == 8) maxValue = maxValue / 255;
			if (app.project.bitsPerChannel == 16) maxValue = maxValue / 32768;
			if (app.project.bitsPerChannel == 32 && maxValue < 0) maxValue = 0;
			if (app.project.bitsPerChannel == 32 && maxValue > 1) maxValue = 1;
		}
	}
	else maxValue = 100;

	//adjust typÃª
	if ( type == DuAEF.DuAE.Types.VELOCITY ) type = 2;
	else type = 1;

	//adjust axis
	if (axis == DuAEF.DuAE.Axis.Y ) axis = 2;
	else if (axis == DuAEF.DuAE.Axis.Z ) axis = 3;
	else if (axis == DuAEF.DuAE.Axis.RED ) axis = 1;
	else if (axis == DuAEF.DuAE.Axis.GREEN ) axis = 2;
	else if (axis == DuAEF.DuAE.Axis.BLUE ) axis = 3;
	else if (axis == DuAEF.DuAE.Axis.ALPHA ) axis = 4;
	else if (axis == DuAEF.DuAE.Axis.HUE ) axis = 5;
	else if (axis == DuAEF.DuAE.Axis.SATURATION ) axis = 6;
	else if (axis == DuAEF.DuAE.Axis.VALUE ) axis = 7;

	//try to find an existing effect
	if (!parentEffect)
	{
		var parentEffects = parentLayer.property('ADBE Effect Parade');
		var matchName = DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.matchName;
		if (dim == 2) matchName = DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.matchName;
		if (dim == 3) matchName = DuAEF.Duik.PseudoEffects.THREED_CONNECTOR.matchName;
		if (dim == 4) matchName = DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.matchName;

		var effects = DuAEF.DuAE.Property.getProps(parentEffects,matchName,true);

		//check if there is one with the same params
		for (var i = 0, num = effects.length; i < num; i++)
		{
			var effect = effects[i].getProperty();
			if (effect.property(DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.minimumSlider).value != minValue) continue;
			if (effect.property(DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider).value != maxValue) continue;
			if (effect.property(DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.connexionModePopup).value != type) continue;
			if (dim > 1) if (effect.property(DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.axisPopup).value != axis) continue;

			//if all tests passed, this is the one!
			parentEffect = effect;
			break;
		}
	}

	//if not found, create
	if (!parentEffect)
	{
		if (dim == 1) parentEffect = DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.apply(parentLayer, parentProp.getProperty().name + ' Connector');
		else if (dim == 2) parentEffect = DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.apply(parentLayer, parentProp.getProperty().name + ' Connector');
		else if (dim == 3) parentEffect = DuAEF.Duik.PseudoEffects.THREED_CONNECTOR.apply(parentLayer, parentProp.getProperty().name + ' Connector');
		else if (dim == 4) parentEffect = DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.apply(parentLayer, parentProp.getProperty().name + ' Connector');

		if (dim != 4) parentEffect(DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider).setValue(100);
		else parentEffect(DuAEF.Duik.PseudoEffects.COLOR_CONNECTOR.maximumSlider).setValue(1);
	}

	parentEffect(DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.minimumSlider).setValue(minValue);
	parentEffect(DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.maximumSlider).setValue(maxValue);
	parentEffect(DuAEF.Duik.PseudoEffects.ONED_CONNECTOR.connexionModePopup).setValue(type);
	if (dim > 1) parentEffect(DuAEF.Duik.PseudoEffects.TWOD_CONNECTOR.axisPopup).setValue(axis);

	// the expression

	// check if the current comp is the same than the comp containing the masterProperty
	var parentComp = parentLayer.containingComp;
	var childComp = DuAEF.DuAE.Property.getComp(childProp);
	var comp = 'thisComp.';
	if (parentComp !== childComp) comp = 'comp("' + parentComp.name + '").';

	var expr = '//Duik.connector\n' +
				'var ctrlLayer = ' + comp + 'layer("' + parentLayer.name + '");\n' +
				'var ctrlValue = ctrlLayer' + DuAEF.DuAE.Property.getExpressionLink(parentProp.getProperty(),false,false) + ';\n' +
				'var ctrlEffect = ctrlLayer.effect("' + parentEffect.name + '");\n' +
				'var ctrlMin = ctrlEffect(2).value;\n' +
				'var ctrlMax = ctrlEffect(3).value;\n' +
				'var result = value;\n' +
				'if (numKeys >= 2 && ctrlEffect.enabled)\n' +
				'{\n' +
				'var useVelocity = ctrlEffect(1).value == 2;\n' +
				'if (useVelocity) ctrlValue = ctrlValue.velocity;\n' +
				'else ctrlValue = ctrlValue.value;\n';
	if (dim == 2 || dim == 3)
	{
		expr += 'var axis = ctrlEffect(4).value-1;\n' +
				'ctrlValue = ctrlValue[axis];\n';
	}
	else if (dim == 4)
	{
		expr += 'var axis = ctrlEffect(4).value;\n' +
				'if (axis == 1) ctrlValue = ctrlValue[0];\n' +
				'else if (axis == 2) ctrlValue = ctrlValue[1];\n' +
				'else if (axis == 3) ctrlValue = ctrlValue[2];\n' +
				'else if (axis == 4) ctrlValue = ctrlValue[3];\n' +
				'else \n' +
				'{\n' +
				'ctrlValue = rgbToHsl(ctrlValue);\n' +
				'if (axis == 5) ctrlValue = ctrlValue[0];\n' +
				'else if (axis == 6) ctrlValue = ctrlValue[1];\n' +
				'else if (axis == 7) ctrlValue = ctrlValue[2];\n' +
				'}';
	}
	expr += 'var t = 0;\n' +
			'var beginTime = key(1).time;\n' +
			'var endTime = key(numKeys).time;\n' +
			'if (ctrlMin > ctrlMax)\n' +
			'{\n' +
			't = linear(ctrlValue, ctrlMin, ctrlMax, endTime, beginTime);\n' +
			'}\n' +
			'else\n' +
			'{\n' +
			't = linear(ctrlValue, ctrlMin, ctrlMax, beginTime, endTime);\n' +
			'}\n' +
			'result = valueAtTime(t);\n' +
			'}\n' +
			'result;';

	childProp.getProperty().expression = expr;

	return parentEffect;
}

/**
	* Creates an IK and its controller on the layers/the structure.
	* @param {Layer[]|Structure} layers - The layers, already parented or ordered from goal (at index 0) to root (including the goal)
	* @param {Layer|Controller|null} [controller] - An already existing controller.
	* @param {boolean} [forceBezier=false] - force the use of a bezier IK even with two or three layers
	* @param {boolean} [threeAsOneAndTwo=true] - when rigging three layers, true to rig using a one-layer IK followed by a two-layer IK instead of a three-mayer IK
	* @return {Controller[]} The controller(s) of the IK.
*/
DuAEF.Duik.Rigging.ik = function (layers,controller,forceBezier,threeAsOneAndTwo)
{
	if (layers instanceof Structure) layers = layers.elements;
	if (typeof forceBezier === 'undefined') forceBezier = false;
	if (typeof threeAsOneAndTwo === 'undefined') threeAsOneAndTwo = true;
	if (layers.length < 1) return;

	//check if there is a controller in the selection
	if (controller == undefined)
	{
		for (var i = 0 ; i < layers.length ; i++)
		{
			var l = layers[i];
			if (DuAEF.Duik.isLayerType(l,DuAEF.Duik.LayerTypes.CONTROLLER))
			{
				controller = l;
				layers.splice(i,1);
				break;
			}
		}
	}

	//sort layers and parent them
	layers = DuAEF.DuAE.Layer.sortByParent(layers);
	//reset rotation and scale if structures
	var it = new Iterator(layers);
	it.do(DuAEF.Duik.Structure.resetTransform);
	DuAEF.DuAE.Layer.parentChain(layers);

	//check if the last one is a goal
	var withGoal = true;
	if(controller != undefined)
	{
		var l = layers[layers.length-1];
		//check position
		var cL = controller;
		if (controller instanceof Controller) cL = controller.layer;
		else controller = new Controller(controller);
		var distance = DuAEF.DuAE.Layer.getDistance(cL,l);
		if (distance > 10) withGoal = false;
	}
	var goal = null;
	if (withGoal) goal = layers.pop();

	if (layers.length == 1 && !forceBezier) controller = [ DuAEF.Duik.Rigging.oneLayerIK(layers[0],goal,controller) ];
	else if (layers.length == 2 && !forceBezier) controller = [ DuAEF.Duik.Rigging.twoLayerIK(layers[0],layers[1],goal,controller) ];
	else if (layers.length == 3 && !forceBezier)
	{
		if (threeAsOneAndTwo)
		{
			controller = DuAEF.Duik.Rigging.twoLayerIK(layers[1],layers[2],goal,controller);
			DuAEF.Duik.Rigging.oneLayerIK(layers[0],goal,controller);
			controller.layer.effect(DuAEF.Duik.PseudoEffects.ONELAYER_IK.matchName)(DuAEF.Duik.PseudoEffects.ONELAYER_IK.weightSlider).setValue(50);
			controller = [controller];
		}
		else controller = [ DuAEF.Duik.Rigging.threeLayerIK(layers[0],layers[1],layers[2],goal,controller) ];
	}
	else controller = DuAEF.Duik.Rigging.bezierIK(layers,goal,controller);

	return controller;
}

/**
	* Creates a one-layer-ik on the layer
	* @param {Layer} layer - The layer
	* @param {Layer|null} [goal] - The goal layer, at the end of the IK
	* @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
	* Must be provided if goal is undefined
	* @return {Controller} The controller created
*/
DuAEF.Duik.Rigging.oneLayerIK = function (layer,goal,controller)
{
	if (goal == undefined) goal = null;
	if (controller == undefined) controller = null;
	if (controller == null && goal == null) throw "You must provide either a goal layer or a controller";
	var comp = layer.containingComp;

	var drawGuides = true;

	//Create controller
	if (controller == null)
	{
		var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
		if (DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL) ctrlType = DuAEF.Duik.Controller.Types.NULL;
		controller = DuAEF.Duik.Controller.create(comp,ctrlType,goal);
	}
	if (!(controller instanceof Controller))
	{
		drawGuides = false;
		controller = new Controller(controller);
	}

	//is right ?
	var ctrlPos = DuAEF.DuAE.Layer.getWorldPos(controller.layer);
	var layerPos = DuAEF.DuAE.Layer.getWorldPos(layer);

	var right = (ctrlPos[0] - layerPos[0]) < 0;

	//Add Effect
	var name = layer.name;
	if (goal != null) name = goal.name;
	var ikEffect = DuAEF.Duik.PseudoEffects.ONELAYER_IK.apply(controller.layer,DuAEF.Duik.generateName('IK',name));
	if (right) ikEffect(6).setValue(1);
	ikEffect(9).setValue(layer.index);

	if (DuAEF.DuAE.App.version >= 15 && controller.layer instanceof ShapeLayer && drawGuides)
	{
		var lineGroup = controller.layer("ADBE Root Vectors Group").property('IK Line');
		if(!lineGroup)
		{
			lineGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
			lineGroup.name = 'IK Line';
		}
		var lineContent = lineGroup.property("ADBE Vectors Group");
		var shape = lineContent.addProperty("ADBE Vector Shape - Group");
		shape('ADBE Vector Shape').expression = 'if (active){\n' +
			'var fx = effect("' + ikEffect.name + '");\n' +
			'var layer1 = null;\n' +
			'var result = [[0,0]];\n' +
			'if (fx(1).value && fx(12).value)\n' +
			'{\n' +
			'try{layer1 = fx(9);}catch(e){}\n' +
			'if (layer1!=null)\n' +
			'{\n' +
			'var l = layer1.toWorld(layer1.anchorPoint);\n' +
			'l = fromWorld(l);\n' +
			'result = [l,[0,0]];\n' +
			'}\n' +
			'}\n' +
			'createPath(result,[],[],false);\n' +
			'} else value;';
		var stroke = lineContent.property("ADBE Vector Graphic - Stroke");
		if(!stroke) stroke = lineContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
		stroke("ADBE Vector Stroke Width").setValue(2);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		stroke("ADBE Vector Stroke Dashes").addProperty("ADBE Vector Stroke Dash 1");
		stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").setValue(5);
	}

	//Add Data
	var layerData = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layerData(1).setValue(controller.layer.index);
	//Expression
	var expr = '//Duik.oneLayerIK\n' +
		'var ctrl = null;\n' +
		'var result = value;\n' +
		'try { ctrl = effect("' + layerData.name + '")(1); } catch (e){ value };\n' +
		'if (ctrl != null)\n' +
		'{\n' +
		'var C = ctrl.toWorld( ctrl.anchorPoint );\n' +
		'var O =  thisLayer.toWorld( thisLayer.anchorPoint );\n' +
		'var fx = ctrl.effect("' + ikEffect.name + '");\n' +
		'W = fx(2).value/100;\n' +
		'FK = fx(3).value;\n' +
		'R = fx(6).value;\n' +
		'var useIK = fx(1).value;\n' +
		'var parentRot = fx(5).value;\n' +
		'result = value+FK;\n' +
		'if (useIK)\n' +
		'{\n' +
		'var vec = R == 1 ? O-C : C-O;\n' +
		'var layer = thisLayer;\n' +
		'if (layer.hasParent && parentRot) result += layer.parent.rotation.value;\n' +
		'while (layer.hasParent)\n' +
		'{\n' +
		'layer = layer.parent;\n' +
		'result = result - layer.rotation;\n' +
		'}\n' +
		'var angle = Math.atan2(vec[1], vec[0]);\n' +
		'angle = radiansToDegrees(angle);\n' +
		'angle = angle*W;\n' +
		'result += angle;\n' +
		'}\n' +
		'}\n' +
		'result;\n';
	
	DuAEF.DuAE.Property.setExpression(layer.transform.rotation,expr);

	if (goal != null)
	{
		var goalData = DuAEF.DuAE.Layer.addPseudoEffect(goal,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
		goalData(1).setValue(controller.layer.index);
		expr = '//Duik.oneLayerIK.goal\n' +
			'var ctrl = null;\n' +
			'var result = value;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'var goal = ctrl.effect("' + ikEffect.name + '")(1).value;\n' +
			'result += ctrl.rotation.value;\n' +
			'if (goal)\n' +
			'{\n' +
			'var layer = thisLayer;\n' +
			'while (layer.hasParent)\n' +
			'{\n' +
			'layer = layer.parent;\n' +
			'result = result - layer.rotation;\n' +
			'}\n' +
			'}\n' +
			'}\n' +
			'result;';
		DuAEF.DuAE.Property.setExpression(goal.transform.rotation,expr);
	}

	return controller;
}

/**
	* Creates a two-layer-ik on the layer
	* @param {Layer} layer1 - The root layer
	* @param {Layer} layer2 - The end layer
	* @param {Layer|null} [goal] - The goal layer, at the end of the IK
	* @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
	* Must be provided if goal is undefined
	* @return {Controller} The controller created
*/
DuAEF.Duik.Rigging.twoLayerIK = function (layer1,layer2,goal,controller)
{
	if (goal == undefined) goal = null;
	if (controller == undefined) controller = null;
	if (controller == null && goal == null) throw "You must provide either a goal layer or a controller";

	var comp = layer1.containingComp;

	var drawGuides = true;

	//Create controller
	if (controller == null)
	{
		var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
		if (DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL) ctrlType = DuAEF.Duik.Controller.Types.NULL;
		controller = DuAEF.Duik.Controller.create(comp, ctrlType, goal);
		goal.parent = null;
		controller.layer.transform.rotation.setValue(goal.transform.rotation.value);
		goal.parent = layer2;
	}
	if (!(controller instanceof Controller))
	{
		drawGuides = false;
		controller = new Controller(controller);
	}

	//Check if clockwise and lengths

	//unparent
	var rootParent = layer1.parent;
	layer1.parent = null;
	var middleParent = layer2.parent;
	layer2.parent = null;
	var endParent = controller.layer.parent;
	controller.layer.parent = null;

	var clockwise = false;

	var upperLength = DuAEF.DuJS.Math.getLength(layer1.transform.position.value,layer2.transform.position.value);
	var lowerLength = DuAEF.DuJS.Math.getLength(layer2.transform.position.value,controller.layer.transform.position.value);
	var endPos = controller.layer.transform.position.value - layer1.transform.position.value;
	var middlePos = layer2.transform.position.value - layer1.transform.position.value;
	if (endPos[0] == 0 && endPos[1] > 0 && middlePos[0] > 0) clockwise = true;
	else if (endPos[0] == 0 && endPos[1] < 0 && middlePos[0] < 0) clockwise = true;
	else
	{
		var coef = endPos[1]/endPos[0];
		if (middlePos[1] < middlePos[0]*coef && endPos[0] > 0) clockwise = true;
		if (middlePos[1] > middlePos[0]*coef && endPos[0] < 0) clockwise = true;
	}

	//reparent
	layer1.parent = rootParent;
	layer2.parent = middleParent;
	controller.layer.parent = endParent;


	//add effect
	var name = layer2.name;
	if (goal != undefined) name = goal.name;
	var ikEffect = DuAEF.Duik.PseudoEffects.TWOLAYER_IK.apply(controller.layer,DuAEF.Duik.generateName('IK',name));
	if (clockwise) ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox).setValue(1);

	//set layers
	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer).setValue(layer1.index);
	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer).setValue(layer2.index);
	if (goal != undefined) ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalLayer).setValue(goal.index);

	//set lengths
	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider).setValue(upperLength);
	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider).setValue(lowerLength);

	//rotation limit
	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fullRotationLimitAngle).setValue(-180);

	//inherit parent rotation
	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox).setValue(1);

	//get some useful coordinates
	var goalPos = [0,0];
	if (goal != null)
	{
		goalPos = goal.transform.position.value;
	}
	else
	{
		ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint).expression = "thisComp.layer(" + layer2.index + ").fromWorld( thisComp.layer(" + controller.layer.index + ").position)";
		goalPos = ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint).value;
		ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint).expression = "";
	}
	DuAEF.DuAE.Property.setValue(ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint),goalPos);
	var rootAp = layer1.transform.anchorPoint.value.toSource();
	var middleAp = layer2.transform.anchorPoint.value.toSource();
	var middlePos = layer2.transform.position.value.toSource();

	//add expressions
	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperStretchSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var result = 0;\n' +
		'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
		'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperScaleSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value > 0)(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperStretchSlider + ').value+fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value)/fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value*100; else 100;';

	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerStretchSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer2 = null;\n' +
		'var result = 0;\n' +
		'try{layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
		'if (layer2!=null)\n' +
		'{\n' +
		'newLength = length(layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value),layer2.toWorld(layer2.anchorPoint));\n' +
		'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerScaleSlider).expression = 'var fx = effect("' + ikEffect.name + '"); if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value > 0)(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerStretchSlider + ').value+fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value)/fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value*100; else 100;';

	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint).expression = 'var result = value;\n' +
		'fx = effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ')}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.stretchSlider + ');\n' +
		'auto = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoStretchCheckbox + ').value;\n' +
		'IK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
		'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoShrinkSlider + ').value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'dist1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
		'dist2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
		'IKLength = dist1+dist2;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist2/(IKLength);\n' +
		'posC = toWorld(anchorPoint);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n' +
		'result = (' + goalPos.toSource() + ' -' + middleAp + ')*coef+' + middleAp + ';\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalWorldPositionPoint).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer2 = null;\n' +
		'var result = [0,0];\n' +
		'try{layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ')}catch(e){}\n' +
		'if (layer2!=null)\n' +
		'{\n' +
		'result = layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value);\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikLengthSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var result = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
		'var goalPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalWorldPositionPoint + ').value;\n' +
		'var layer1 = null;\n' +
		'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + '); } catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'result = length(layer1.toWorld(layer1.anchorPoint), goalPos);\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.TWOLAYER_IK.straightCheckbox).expression = 'fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var result = false;\n' +
		'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + ');}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'var a = layer1.toWorld(layer1.anchorPoint);\n' +
		'var b = layer2.toWorld(layer2.anchorPoint);\n' +
		'var c = layer2.toWorld(fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value);\n' +
		'result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 1000;\n' +
		'}\n' +
		'result;';

	//add controller visual feedback
	if ((controller.layer instanceof ShapeLayer) && drawGuides)
	{
		var ikGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		ikGroup.name = 'IK';
		var ikContent = ikGroup.property("ADBE Vectors Group");
		var shape = ikContent.addProperty("ADBE Vector Shape - Group");
		var ikShape = new Shape();
		ikShape.vertices = [[-8, 16], [8, 16]];
		ikShape.inTangents = [[0, 0], [0, 0]];
		ikShape.outTangents = [[0, 0], [0, 0]];
		ikShape.closed = false;
		shape('ADBE Vector Shape').setValue(ikShape);
		var stroke = ikContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
		stroke("ADBE Vector Stroke Width").setValue(2);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		stroke("ADBE Vector Stroke Opacity").expression = 'var fx = effect("' + ikEffect.name + '");\n' +
			'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.drawGuidesCheckbox + ').value) fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.straightCheckbox + ').value*100 else 0;';

		ikGroup.transform.scale.expression = '[effect("Controller")(4)*2,effect("Controller")(4)*2]';
		ikGroup.transform.position.expression = 'effect("Controller")(3)';
		ikGroup.transform.opacity.expression = 'effect("Controller")(6)';

		if (DuAEF.DuAE.App.version >= 15)
		{
			var lineGroup = controller.layer("ADBE Root Vectors Group").property('IK Line');
			if(!lineGroup)
			{
				lineGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
				lineGroup.name = 'IK Line';
			}
			var lineContent = lineGroup.property("ADBE Vectors Group");
			var shape = lineContent.addProperty("ADBE Vector Shape - Group");
			shape('ADBE Vector Shape').expression = 'if (active){\n' +
				'var fx = effect("' + ikEffect.name + '");\n' +
				'var layer1 = null;\n' +
				'var result = [[0,0]];\n' +
				'if (fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value && fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.drawGuidesCheckbox + ').value)\n' +
				'{\n' +
				'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ');}catch(e){}\n' +
				'if (layer1!=null)\n' +
				'{\n' +
				'var l = layer1.toWorld(layer1.anchorPoint);\n' +
				'l = fromWorld(l);\n' +
				'result = [l,[0,0]];\n' +
				'}\n' +
				'}\n' +
				'createPath(result,[],[],false);\n' +
				'} else value;';
			var stroke = lineContent.property("ADBE Vector Graphic - Stroke");
			if(!stroke) stroke = lineContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
			stroke("ADBE Vector Stroke Width").setValue(2);
			stroke("ADBE Vector Stroke Line Cap").setValue(2);
			stroke("ADBE Vector Stroke Dashes").addProperty("ADBE Vector Stroke Dash 1");
			stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").setValue(5);
		}
	}


	//setup layers
	var layer1Data = DuAEF.DuAE.Layer.addPseudoEffect(layer1,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer1Data(1).setValue(controller.layer.index);

	layer1.transform.rotation.expression = '//Duik.twoLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer1Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name  + '");\n' +
		'IKFK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
		'function ik() \n' +
		'{\n' +
		'layer1 = thisLayer;\n' +
		'layer2 = null;\n' +
		'try{ layer2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLayer + '); }  catch (e){return value;}\n' +
		'if (layer2 != null)\n' +
		'{\n' +
		'endPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
		'limit = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fullRotationLimitAngle + ').value;\n' +
		'cw = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox + ').value;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'A = getWorldPos(layer1);\n' +
		'C = layer2.toWorld(endPos);\n' +
		'B = getWorldPos(layer2);\n' +
		'E = getWorldPos(controller);\n' +
		'a = length(B,C);\n' +
		'b = length(E,A);\n' +
		'c = length(A,B);\n' +
		'x = (b*b + c*c - a*a )/(2*b);\n' +
		'alpha = Math.acos(clamp(x/c,-1,1));\n' +
		'D = E - A;\n' +
		'delta = Math.atan2(D[1],D[0]);\n' +
		'result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n' +
		'V = B - A;\n' +
		'adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n' +
		'IK = result - adj1 + value;\n' +
		'if (IK < limit) IK+=360;\n' +
		'return IK;\n' +
		'}\n' +
		'}\n' +
		'function fk() {\n' +
		'var follow = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox + ').value;\n' +
		'var FK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperAngle + ').value + fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fkAngle + ').value;\n' +
		'var p = thisLayer;\n' +
		'if (!follow)\n' +
		'{\n' +
		'while(p.hasParent)\n' +
		'{\n' +
		'p = p.parent;\n' +
		'FK -= p.rotation.value;\n' +
		'}\n' +
		'}\n' +
		'return FK;\n' +
		'}\n' +
		'result = IKFK ? ik() : fk();\n' +
		'}\n' +
		'result;';


	var layer2Data = DuAEF.DuAE.Layer.addPseudoEffect(layer2,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer2Data(1).setValue(controller.layer.index);


	layer2.transform.rotation.expression = '//Duik.twoLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer2Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name  + '");\n' +
		'IKFK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
		'layer1 = null;\n' +
		'layer2 = thisLayer;\n' +
		'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + '); }  catch (e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'function ik()\n' +
		'{\n' +
		'endPos = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
		'cw = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.reverseCheckbox + ').value;\n' +
		'function getWorldPos(L)\n' +
		'{\n' +
		'	return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'A = getWorldPos(layer1);\n' +
		'B = getWorldPos(layer2);\n' +
		'C = layer2.toWorld(endPos);\n' +
		'E = getWorldPos(controller);\n' +
		'a = length(B,C);\n' +
		'b = length(E,A);\n' +
		'c = length(A,B);\n' +
		'x = (b*b + c*c - a*a )/(2*b);\n' +
		'alpha = Math.acos(clamp(x/c,-1,1));\n' +
		'y = b - x;\n' +
		'gamma = Math.acos(clamp(y/a,-1,1));\n' +
		'result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);  V1 = B - A;\n' +
		'adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n' +
		'V2 = C - B;\n' +
		'adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n' +
		'IK = result +  adj1 - adj2 + value;\n' +
		'return IK;\n' +
		'}\n' +
		'function fk()\n' +
		'{\n' +
		'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.fkAngle + ');\n' +
		'var delay = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.resistanceSlider + ').value ;\n' +
		'var amp = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.flexibilitySlider + ').value ;\n' +
		'var follow = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.parentRotationCheckbox + ').value;\n' +
		'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.followThroughCheckbox + ').value;\n' +
		'if (!ftEnabled)\n' +
		'{\n' +
		'amp = 0;\n' +
		'delay = 0;\n' +
		'}\n' +
		'else\n' +
		'{\n' +
		'delay = delay / 100;\n' +
		'amp = amp / 100 ;\n' +
		'}\n' +
		'FK = ctrlRot.valueAtTime(time-delay);\n' +
		'if (follow && hasParent)\n' +
		'{\n' +
		'var cP = layer1;\n' +
		'while(cP.hasParent)\n' +
		'{\n' +
		'cP = cP.parent;\n' +
		'FK -= cP.rotation.value - cP.rotation.valueAtTime(time-delay);\n' +
		'}\n' +
		'}\n' +
		'FK = FK - ctrlRot.value ;\n' +
		'FK = FK * amp;\n' +
		'FK = FK - ctrlRot.velocity*(delay/5);\n' +
		'FK += fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerAngle + ').value;\n' +
		'return FK;\n' +
		'}\n' +
		'result = IKFK ? ik() : fk();\n' +
		'}\n' +
		'}\n' +
		'result;';

	layer2.transform.position.expression = '//Duik.twoLayerIK.stretch\n' +
		'var ctrl = null;\n' +
		'var result = value;\n' +
		'try { ctrl = effect("' + layer2Data.name + '")(1); } catch (e){ value };\n' +
		'if (ctrl != null)\n' +
		'{\n' +
		'fx = ctrl.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'result = [211, 25];\n' +
		'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLayer + ')}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.stretchSlider + ').value;\n' +
		'auto = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoStretchCheckbox + ').value;\n' +
		'IK = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
		'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.autoShrinkSlider + ').value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'dist1 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.upperLengthSlider + ').value;\n' +
		'dist2 = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.lowerLengthSlider + ').value;\n' +
		'IKLength = dist1+dist2;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist1/(IKLength);\n' +
		'posC = getWorldPos(ctrl);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n' +
		'result = (' + middlePos + ' -' + rootAp + ')*coef+' + rootAp + ';\n' +
		'}\n' +
		'}\n' +
		'result;';

	if (goal != null)
	{
		var goalData = DuAEF.DuAE.Layer.addPseudoEffect(goal,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
		goalData(1).setValue(controller.layer.index);

		var rotExpr = '//Duik.goal\n' +
			'var ctrl = null;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){};\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'var fx = ctrl.effect("' + ikEffect.name +'");\n' +
			'var ikfk = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.ikCheckbox + ').value;\n' +
			'function ik()\n' +
			'{\n' +
			'var IK = ctrl.rotation.value;\n' +
			'var layer = thisLayer;\n' +
			'while (layer.hasParent)\n' +
			'{\n' +
			'layer = layer.parent;\n' +
			'IK = IK - layer.rotation;\n' +
			'}\n' +
			'return IK;\n' +
			'}\n' +
			'function fk()\n' +
			'{\n' +
			'var FK = value;\n' +
			'var parentRot = parent.transform.rotation ;\n' +
			'var delay = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.resistanceSlider + ').value ;\n' +
			'var amp = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.flexibilitySlider + ').value ;\n' +
			'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.followThroughCheckbox + ').value;\n' +
			'if (!ftEnabled)\n' +
			'{\n' +
			'amp = 0;\n' +
			'delay = 0;\n' +
			'}\n' +
			'else\n' +
			'{\n' +
			'delay = delay / 100;\n' +
			'amp = amp / 100 ;\n' +
			'}\n' +
			'FK = parentRot.valueAtTime(time-delay);\n' +
			'FK = FK * amp;\n' +
			'FK = FK + value + fx(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalAngle + ') - parentRot.valueAtTime(0);\n' +
			'return FK;\n' +
			'}\n' +
			'ikfk ? ik() : fk();\n' +
			'}\n' +
			'else value;\n';


		DuAEF.DuAE.Property.setExpression(goal.transform.rotation,rotExpr);

		goal.transform.position.expression = 'var ctrl = null;\n' +
			'var result = value;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'result = ctrl.effect("' + ikEffect.name + '")(' + DuAEF.Duik.PseudoEffects.TWOLAYER_IK.goalPositionPoint + ').value;\n' +
			'}\n' +
			'result;';
	}

	return controller;
}

/**
	* Creates a three-layer-ik on the layer
	* @param {Layer} layer1 - The root layer
	* @param {Layer} layer2 - The middle layer
	* @param {Layer} layer3 - The end layer
	* @param {Layer|null} [goal] - The goal layer, at the end of the IK
	* @param {Layer|Controller|null} [controller] - The layer to use as a controller, can be automatically created.<br />
	* Must be provided if goal is undefined
	* @return {Controller} The controller created
*/
DuAEF.Duik.Rigging.threeLayerIK = function (layer1,layer2,layer3,goal,controller)
{
	if (goal == undefined) goal = null;
	if (controller == undefined) controller = null;
	if (controller == null && goal == null) throw "You must provide either a goal layer or a controller";

	var comp = layer1.containingComp;

	//Create controller
	if (controller == null)
	{
		var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
		if (DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL) ctrlType = DuAEF.Duik.Controller.Types.NULL;
		controller = DuAEF.Duik.Controller.create(comp, ctrlType, goal);
		goal.parent = null;
		controller.layer.transform.rotation.setValue(goal.transform.rotation.value);
		goal.parent = layer3;
	}
	if (!(controller instanceof Controller)) controller = new Controller(controller);

	//Check if clockwise and lengths

	//unparent
	var rootParent = layer1.parent;
	layer1.parent = null;
	var middleParent = layer2.parent;
	layer2.parent = null;
	var endParent = controller.layer.parent;
	controller.layer.parent = null;

	var upperLength = DuAEF.DuJS.Math.getLength(layer1.transform.position.value,layer2.transform.position.value);
	var lowerLength = DuAEF.DuAE.Layer.getDistance(layer3,controller.layer);
	var middleLength = DuAEF.DuAE.Layer.getDistance(layer3,layer2);
	var endPos = controller.layer.transform.position.value - layer1.transform.position.value;
	var middlePos = layer2.transform.position.value - layer1.transform.position.value;
	var coef = endPos[1]/endPos[0];

	var clockwise = false;
	if (middlePos[1] < middlePos[0]*coef && endPos[0] > 0) clockwise = true;
	if (middlePos[1] > middlePos[0]*coef && endPos[0] < 0) clockwise = true;

	//reparent
	layer1.parent = rootParent;
	layer2.parent = middleParent;
	controller.layer.parent = endParent;


	//add effect
	var name = layer3.name;
	if (goal != undefined) name = goal.name;
	var ikEffect = DuAEF.Duik.PseudoEffects.THREELAYER_IK.apply(controller.layer,DuAEF.Duik.generateName('IK',name));
	if (clockwise) ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox).setValue(1);

	//set layers
	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer).setValue(layer1.index);
	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer).setValue(layer2.index);
	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer).setValue(layer3.index);
	if (goal != undefined) ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalLayer).setValue(goal.index);

	//set lengths
	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider).setValue(upperLength);
	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider).setValue(middleLength);
	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider).setValue(lowerLength);

	//rotation limit
	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.fullRotationLimitAngle).setValue(-180);

	//get some useful coordinates
	var goalPos = [0,0];
	if (goal != null)
	{
		goalPos = goal.transform.position.value;
	}
	else
	{
		ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint).expression = "thisComp.layer(" + layer3.index + ").fromWorld( thisComp.layer(" + controller.layer.index + ").position)";
		goalPos = ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint).value;
		ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint).expression = "";
	}
	DuAEF.DuAE.Property.setValue(ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint),goalPos);
	var rootAp = layer1.transform.anchorPoint.value.toSource();
	var middleAp = layer2.transform.anchorPoint.value.toSource();
	var lowerAp = layer3.transform.anchorPoint.value.toSource();
	var middlePos = layer2.transform.position.value.toSource();
	var lowerPos = layer3.transform.position.value.toSource();

	//add expressions
	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperStretchSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var result = 0;\n' +
		'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'newLength = length(layer1.toWorld(layer1.anchorPoint),layer2.toWorld(layer2.anchorPoint));\n' +
		'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value;\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleStretchSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer2 = null;\n' +
		'var layer3 = null;\n' +
		'var result = 0;\n' +
		'try{layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');}catch(e){}\n' +
		'if (layer3!=null)\n' +
		'{\n' +
		'newLength = length(layer2.toWorld(layer2.anchorPoint),layer3.toWorld(layer3.anchorPoint));\n' +
		'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerStretchSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer3 = null;\n' +
		'var result = 0;\n' +
		'try{layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');}catch(e){}\n' +
		'if (layer3!=null)\n' +
		'{\n' +
		'newLength = length( fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value , layer3.toWorld(layer3.anchorPoint));\n' +
		'result = newLength - fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchScaleSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'result = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperStretchSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleStretchSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerStretchSlider + ').value;\n' +
		'var o = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
		'result += o;\n' +
		'result = result / o * 100;';

	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint).expression = 'var result = value;\n' +
		'fx = effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
		'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
		'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
		'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'var upperAP = ' + rootAp + ';\n' +
		'var middlePos = ' + middlePos + ';\n' +
		'var middleAP = ' + middleAp + ';\n' +
		'var lowerPos = ' + lowerPos + ';\n' +
		'var lowerAP = ' + lowerAp + ';\n' +
		'var zeroPos = ' + goalPos.toSource() + ';\n' +
		'dist1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ');\n' +
		'dist2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ');\n' +
		'dist3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ');\n' +
		'IKLength = dist1+dist2+dist3;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist3/(IKLength);\n' +
		'posC = toWorld(anchorPoint);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist3 != 0 ? coef = (dist3+boneStretch)/dist3 : coef = 1;\n' +
		'result = (middlePos-upperAP)*coef+upperAP;\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var layer3 = null;\n' +
		'var result = [0,0];\n' +
		'try{layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ')}catch(e){}\n' +
		'if (layer3!=null)\n' +
		'{\n' +
		'result = layer3.toWorld(fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value);\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikLengthSlider).expression = 'var fx = effect("' + ikEffect.name + '");\n' +
		'var result = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value + fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
		'var goalPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value;\n' +
		'var layer1 = null;\n' +
		'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); } catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'result = length(layer1.toWorld(layer1.anchorPoint), goalPos);\n' +
		'}\n' +
		'result;';

	ikEffect(DuAEF.Duik.PseudoEffects.THREELAYER_IK.straightCheckbox).expression = 'fx = effect("' + ikEffect.name + '");\n' +
		'var layer1 = null;\n' +
		'var layer2 = null;\n' +
		'var layer3 = null;\n' +
		'var result = false;\n' +
		'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');layer2=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + ');layer3=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + ');}catch(e){}\n' +
		'if (layer1!=null)\n' +
		'{\n' +
		'var a = layer1.toWorld(layer1.anchorPoint);\n' +
		'var b = layer2.toWorld(layer2.anchorPoint);\n' +
		'var c = layer3.toWorld(layer3.anchorPoint);\n' +
		'result = Math.abs(a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) < 10 ;\n' +
		'}\n' +
		'result;';

	//add controller visual feedback
	if (controller.layer instanceof ShapeLayer)
	{
		var ikGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		ikGroup.name = 'IK';
		var ikContent = ikGroup.property("ADBE Vectors Group");
		var shape = ikContent.addProperty("ADBE Vector Shape - Group");
		var ikShape = new Shape();
		ikShape.vertices = [[-8, 16], [8, 16]];
		ikShape.inTangents = [[0, 0], [0, 0]];
		ikShape.outTangents = [[0, 0], [0, 0]];
		ikShape.closed = false;
		shape('ADBE Vector Shape').setValue(ikShape);
		var stroke = ikContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
		stroke("ADBE Vector Stroke Width").setValue(2);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		stroke("ADBE Vector Stroke Opacity").expression = 'var fx = effect("' + ikEffect.name + '");\n' +
			'if (fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.drawGuidesCheckbox + ').value) fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.straightCheckbox + ').value*100; else 0;';

		ikGroup.transform.scale.expression = '[effect("Controller")(4)*2,effect("Controller")(4)*2]';
		ikGroup.transform.position.expression = 'effect("Controller")(3)';
		ikGroup.transform.opacity.expression = 'effect("Controller")(6)';

		if (DuAEF.DuAE.App.version >= 15)
		{
			var lineGroup = controller.layer("ADBE Root Vectors Group").property('IK Line');
			if(!lineGroup)
			{
				lineGroup = controller.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
				lineGroup.name = 'IK Line';
			}
			var lineContent = lineGroup.property("ADBE Vectors Group");
			var shape = lineContent.addProperty("ADBE Vector Shape - Group");
			shape('ADBE Vector Shape').expression = 'if (active){\n' +
				'var fx = effect("' + ikEffect.name + '");\n' +
				'var layer1 = null;\n' +
				'var result = [[0,0]];\n' +
				'if (fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value && fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.drawGuidesCheckbox + ').value)\n' +
				'{\n' +
				'try{layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ');}catch(e){}\n' +
				'if (layer1!=null)\n' +
				'{\n' +
				'var l = layer1.toWorld(layer1.anchorPoint);\n' +
				'l = fromWorld(l);\n' +
				'result = [l,[0,0]];\n' +
				'}\n' +
				'}\n' +
				'createPath(result,[],[],false);\n' +
				'} else value;';
			var stroke = lineContent.property("ADBE Vector Graphic - Stroke");
			if(!stroke) stroke = lineContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
			stroke("ADBE Vector Stroke Width").setValue(2);
			stroke("ADBE Vector Stroke Line Cap").setValue(2);
			stroke("ADBE Vector Stroke Dashes").addProperty("ADBE Vector Stroke Dash 1");
			stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").setValue(5);
		}
	}

	//setup layers
	var layer1Data = DuAEF.DuAE.Layer.addPseudoEffect(layer1,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer1Data(1).setValue(controller.layer.index);

	layer1.transform.rotation.expression = '//Duik.threeLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer1Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name + '");\n' +
		'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
		'layer1 = thisLayer;\n' +
		'layer2 = null;\n' +
		'layer3 = null;\n' +
		'try{ layer2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + '); layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + '); }  catch (e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'function ik()\n' +
		'{\n' +
		'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
		'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
		'limit = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fullRotationLimitAngle + ').value;\n' +
		'function getWorldPos(layer)\n' +
		'{\n' +
		'return layer.toWorld(layer.anchorPoint);\n' +
		'}\n' +
		'function sq(result)\n' +
		'{\n' +
		'return result*result;\n' +
		'}\n' +
		'function getAngle(p1,p2)\n' +
		'{\n' +
		'var dist = p2-p1;\n' +
		'var angle = Math.atan2(dist[1],dist[0]);\n' +
		'return radiansToDegrees(angle);\n' +
		'}\n' +
		'var uPos = getWorldPos(layer1);\n' +
		'var mPos = getWorldPos(layer2);\n' +
		'var cPos = getWorldPos(controller);\n' +
		'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
		'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
		'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
		'var ikLength = length(uPos,cPos);\n' +
		'if (ikLength == 0) ikLength = 1;\n' +
		'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
		'var d2 = sq(ikLength) * (uLength+lLength);\n' +
		'var d3 = -sq(ikLength) * uLength * lLength;\n' +
		'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
		'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
		'var upperA = cw ? -baseA : baseA ;\n' +
		'upperA = radiansToDegrees(upperA);\n' +
		'var uToC =getAngle(uPos,cPos);\n' +
		'var uToM =getAngle(uPos,mPos);\n' +
		'var ikResult = upperA + uToC - uToM;\n' +
		'if (ikResult < limit) ikResult +=360;\n' +
		'return ikResult;\n' +
		'}\n' +
		'function fk()\n' +
		'{\n' +
		'var FK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperAngle + ').value;\n' +
		'FK += fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ').value;\n' +
		'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
		'var p = thisLayer;\n' +
		'if (!follow)\n' +
		'{\n' +
		'while(p.hasParent)\n' +
		'{\n' +
		'p = p.parent;\n' +
		'FK -= p.rotation.value;\n' +
		'}\n' +
		'}\n' +
		'return FK;\n' +
		'}\n' +
		'IKFK ? result += ik() : result += fk();\n' +
		'}\n' +
		'}\n' +
		'result;\n';

	var layer2Data = DuAEF.DuAE.Layer.addPseudoEffect(layer2,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer2Data(1).setValue(controller.layer.index);

	layer2.transform.rotation.expression = '//Duik.threeLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer2Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name + '");\n' +
		'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
		'layer1 = null;\n' +
		'layer2 = thisLayer;\n' +
		'layer3 = null;\n' +
		'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); layer3 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLayer + '); }  catch (e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'function ik()\n' +
		'{\n' +
		'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
		'FK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleAngle + ').value;\n' +
		'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
		'function getWorldPos(layer)\n' +
		'{\n' +
		'return layer.toWorld(layer.anchorPoint);\n' +
		'}\n' +
		'function sq(result)\n' +
		'{\n' +
		'return result*result;\n' +
		'}\n' +
		'function getAngle(p1,p2)\n' +
		'{\n' +
		'var dist = p2-p1;\n' +
		'var angle = Math.atan2(dist[1],dist[0]);\n' +
		'return radiansToDegrees(angle);\n' +
		'}\n' +
		'var uPos = getWorldPos(layer1);\n' +
		'var mPos = getWorldPos(layer2);\n' +
		'var lPos = getWorldPos(layer3);\n' +
		'var cPos = getWorldPos(controller);\n' +
		'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
		'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
		'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
		'var ikLength = length(uPos,cPos);\n' +
		'if (ikLength == 0) ikLength = 1;\n' +
		'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
		'var d2 = sq(ikLength) * (uLength+lLength);\n' +
		'var d3 = -sq(ikLength) * uLength * lLength;\n' +
		'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
		'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
		'var d5 = Math.sqrt( sq(ikLength) + sq(lLength) - 2*ikLength*lLength*Math.cos(baseA));\n' +
		'var middleA = Math.acos(clamp((sq(d5)-sq(uLength)-sq(mLength)) / (-2*uLength*mLength),-1,1));\n' +
		'middleA = cw ? -middleA : middleA ;\n' +
		'middleA = radiansToDegrees(middleA);\n' +
		'var uToM =getAngle(uPos,mPos);\n' +
		'var mToL =getAngle(mPos,lPos);\n' +
		'var ikResult = middleA + uToM - mToL +180;\n' +
		'return ikResult;\n' +
		'}\n' +
		'function fk()\n' +
		'{\n' +
		'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
		'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
		'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
		'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleAngle + ').value;\n' +
		'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
		'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
		'if (!ftEnabled)\n' +
		'{\n' +
		'amp = 0;\n' +
		'delay = 0;\n' +
		'}\n' +
		'else\n' +
		'{\n' +
		'delay = delay / 100;\n' +
		'amp = amp / 100 ;\n' +
		'}\n' +
		'var FK = ctrlRot.valueAtTime(time-delay);\n' +
		'if (follow && hasParent)\n' +
		'{\n' +
		'var cP = parent;\n' +
		'while(cP.hasParent)\n' +
		'{\n' +
		'cP = cP.parent;\n' +
		'if (cP.index = controller.index) follow = false;\n' +
		'FK -= cP.rotation.value - cP.rotation.valueAtTime(time-delay) ;\n' +
		'}\n' +
		'}\n' +
		'FK = FK - ctrlRot.value ;\n' +
		'FK = FK * amp;\n' +
		'FK = FK - ctrlRot.velocity*(delay/5);\n' +
		'if (follow) result -= parent.transform.rotation.valueAtTime(0);\n' +
		'FK += manual;\n' +
		'return FK;\n' +
		'}\n' +
		'IKFK ? result += ik() : result += fk();\n' +
		'}\n' +
		'}\n' +
		'result;\n';

	layer2.transform.position.expression = '//Duik.threeLayerIK.stretch\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try { controller = effect("' + layer2Data.name + '")(1); } catch (e){ value };\n' +
		'if (controller != null)\n' +
		'{\n' +
		'fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
		'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
		'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
		'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'var upperAP = ' + rootAp + ';\n' +
		'var middlePos = ' + middlePos + ';\n' +
		'var middleAP = ' + middleAp + ';\n' +
		'var lowerPos = ' + lowerPos + ';\n' +
		'var lowerAP = ' + lowerAp + ';\n' +
		'var zeroPos = ' + goalPos.toSource() + ';\n' +
		'dist1 = length(upperAP,middlePos);\n' +
		'dist2 = length(middleAP,lowerPos);\n' +
		'dist3 = length(lowerAP,zeroPos);\n' +
		'IKLength = dist1+dist2+dist3;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist1/(IKLength);\n' +
		'posC = getWorldPos(controller);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n' +
		'result = (middlePos-upperAP)*coef+upperAP;\n' +
		'}\n' +
		'}\n' +
		'result;';


	var layer3Data = DuAEF.DuAE.Layer.addPseudoEffect(layer3,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
	layer3Data(1).setValue(controller.layer.index);

	layer3.transform.rotation.expression = '//Duik.threeLayerIK\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try{controller=effect("' + layer3Data.name + '")(1)}catch(e){}\n' +
		'if (controller !=null)\n' +
		'{\n' +
		'var fx = controller.effect("' + ikEffect.name + '");\n' +
		'IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
		'layer1 = null;\n' +
		'layer2 = null;\n' +
		'layer3 = thisLayer;\n' +
		'try{ layer1 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + '); layer2 = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLayer + '); }  catch (e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'function ik()\n' +
		'{\n' +
		'endPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
		'cw = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.reverseCheckbox + ').value;\n' +
		'function getWorldPos(layer)\n' +
		'{\n' +
		'return layer.toWorld(layer.anchorPoint);\n' +
		'}\n' +
		'function sq(result)\n' +
		'{\n' +
		'return result*result;\n' +
		'}\n' +
		'function getAngle(p1,p2)\n' +
		'{\n' +
		'var dist = p2-p1;\n' +
		'var angle = Math.atan2(dist[1],dist[0]);\n' +
		'return radiansToDegrees(angle);\n' +
		'}\n' +
		'var uPos = getWorldPos(layer1);\n' +
		'var mPos = getWorldPos(layer2);\n' +
		'var lPos = getWorldPos(layer3);\n' +
		'var zPos = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalWorldPositionPoint + ').value;\n' +
		'var cPos = getWorldPos(controller);\n' +
		'var uLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLengthSlider + ').value\n' +
		'var mLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.middleLengthSlider + ').value;\n' +
		'var lLength = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerLengthSlider + ').value;\n' +
		'var ikLength = length(uPos,cPos);\n' +
		'if (ikLength == 0) ikLength = 1;\n' +
		'var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n' +
		'var d2 = sq(ikLength) * (uLength+lLength);\n' +
		'var d3 = -sq(ikLength) * uLength * lLength;\n' +
		'var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n' +
		'var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n' +
		'var d6 = Math.sqrt( sq(ikLength) + sq(uLength) - 2*ikLength*uLength*Math.cos(baseA));\n' +
		'var lowerA = Math.acos(clamp((sq(d6) - sq(lLength) - sq(mLength)) / (-2*lLength*mLength),-1,1));\n' +
		'lowerA = cw ? -lowerA : lowerA;\n' +
		'lowerA = radiansToDegrees(lowerA);\n' +
		'var mToL =getAngle(mPos,lPos);\n' +
		'var lToZ =getAngle(lPos,zPos);\n' +
		'var ikResult = lowerA + mToL - lToZ +180;\n' +
		'return ikResult;\n' +
		'}\n' +
		'function fk()\n' +
		'{\n' +
		'var parentRot = parent.transform.rotation ;\n' +
		'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
		'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
		'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
		'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.lowerAngle + ').value;\n' +
		'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
		'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
		'if (!ftEnabled)\n' +
		'{\n' +
		'amp = 0;\n' +
		'delay = 0;\n' +
		'}\n' +
		'else\n' +
		'{\n' +
		'delay = delay / 100;\n' +
		'amp = amp / 100 ;\n' +
		'}\n' +
		'var FK = parentRot.valueAtTime(time-delay);\n' +
		'FK = FK * amp;\n' +
		'FK = FK + manual - parent.transform.rotation.valueAtTime(0);\n' +
		'return FK;\n' +
		'}\n' +
		'IKFK ? result += ik() : result += fk();\n' +
		'}\n' +
		'}\n' +
		'result;\n';

	layer3.transform.position.expression = '//Duik.threeLayerIK.stretch\n' +
		'var controller = null;\n' +
		'var result = value;\n' +
		'try { controller = effect("' + layer3Data.name + '")(1); } catch (e){ value };\n' +
		'if (controller != null)\n' +
		'{\n' +
		'fx = controller.effect("' + ikEffect.name + '");\n' +
		'layer1 = null;\n' +
		'try{layer1=fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.upperLayer + ')}catch(e){}\n' +
		'if (layer1 != null)\n' +
		'{\n' +
		'stretch = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.stretchSlider + ').value;\n' +
		'auto = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoStretchCheckbox + ').value;\n' +
		'IK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
		'shrinkVal = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.autoShrinkSlider + ').value/100;\n' +
		'function getWorldPos(L){\n' +
		'return L.toWorld(L.anchorPoint);\n' +
		'}\n' +
		'var upperAP = ' + rootAp + ';\n' +
		'var middlePos = ' + middlePos + ';\n' +
		'var middleAP = ' + middleAp + ';\n' +
		'var lowerPos = ' + lowerPos + ';\n' +
		'var lowerAP = ' + lowerAp + ';\n' +
		'var zeroPos = ' + goalPos.toSource() + ';\n' +
		'dist1 = length(upperAP,middlePos);\n' +
		'dist2 = length(middleAP,lowerPos);\n' +
		'dist3 = length(lowerAP,zeroPos);\n' +
		'IKLength = dist1+dist2+dist3;\n' +
		'IKStretched = IKLength+stretch;\n' +
		'boneStretch = 0;\n' +
		'proportion = dist2/(IKLength);\n' +
		'posC = getWorldPos(controller);\n' +
		'posR = getWorldPos(layer1);\n' +
		'distC = length(posC,posR);\n' +
		'shrinkMax = IKLength*shrinkVal;\n' +
		'shrink = 0;\n' +
		'if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n' +
		'boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n' +
		'if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n' +
		'else boneStretch += stretch*proportion;\n' +
		'coef = 1;\n' +
		'dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n' +
		'result = (middlePos-upperAP)*coef+upperAP;\n' +
		'}\n' +
		'}\n' +
		'result;';

	if (goal != null)
	{
		var goalData = DuAEF.DuAE.Layer.addPseudoEffect(goal,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"IK");
		goalData(1).setValue(controller.layer.index);

		var rotExpr = '//Duik.goal\n' +
			'var ctrl = null;\n' +
			'var result = value;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){};\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'var fx = ctrl.effect("' + ikEffect.name + '");\n' +
			'var IKFK = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.ikCheckbox + ').value;\n' +
			'function ik()\n' +
			'{\n' +
			'var layer = thisLayer;\n' +
			'var IK = 0;\n' +
			'while (layer.hasParent)\n' +
			'{\n' +
			'layer = layer.parent;\n' +
			'IK = IK - layer.rotation;\n' +
			'}\n' +
			'return IK;\n' +
			'}\n' +
			'function fk()\n' +
			'{\n' +
			'var parentRot = parent.transform.rotation ;\n' +
			'var ctrlRot = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.fkAngle + ');\n' +
			'var delay = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.resistanceSlider + ').value;\n' +
			'var amp = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.flexibilitySlider + ').value;\n' +
			'var ftEnabled = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.followThroughCheckbox + ').value;\n' +
			'var manual = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalAngle + ').value;\n' +
			'var follow = fx(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.parentRotationCheckbox + ').value;\n' +
			'if (!ftEnabled)\n' +
			'{\n' +
			'amp = 0;\n' +
			'delay = 0;\n' +
			'}\n' +
			'else\n' +
			'{\n' +
			'delay = delay / 100;\n' +
			'amp = amp / 100 ;\n' +
			'}\n' +
			'var FK = parentRot.valueAtTime(time-delay);\n' +
			'FK = FK * amp;\n' +
			'FK = FK + manual - parent.transform.rotation.valueAtTime(0);\n' +
			'return FK;\n' +
			'}\n' +
			'IKFK ? result += ik() : result += fk();\n' +
			'}\n' +
			'result;\n' +
			'';

		DuAEF.DuAE.Property.setExpression(goal.transform.rotation,rotExpr);

		goal.transform.position.expression = 'var ctrl = null;\n' +
			'var result = value;\n' +
			'try { ctrl = effect("' + goalData.name + '")(1); } catch (e){ value };\n' +
			'if (ctrl != null)\n' +
			'{\n' +
			'result = ctrl.effect("' + ikEffect.name + '")(' + DuAEF.Duik.PseudoEffects.THREELAYER_IK.goalPositionPoint + ').value;\n' +
			'}\n' +
			'result;';
	}

	return controller;
}

/**
	* Creates a bezier ik on the layers
	* @param {Layer[]|Structure} layers - The layers, ordered from root to end
	* @param {Layer|null} [goal] - The goal layer, at the end of the IK
	* @param {Layer|Controller|null} [controllers] - The layer to use as controller, can be automatically created.<br />
	* Must be provided if goal is undefined.
	* @return {Controller[]} The controllers [curve,end,root]
*/
DuAEF.Duik.Rigging.bezierIK = function (layers,goal,controller)
{
	if (goal == undefined) goal = null;
	if (controller == undefined) controller = null;
	if (controller == null && goal == null) throw "You must provide either a goal layer or a controller";

	if (layers instanceof Structure) layers = layers.elements;

	var comp = layers[0].containingComp;

	//create controllers
	if (controller == null)
	{
		var ctrlType = DuAEF.Duik.Controller.Types.TRANSFORM;
		if (DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL) ctrlType = DuAEF.Duik.Controller.Types.NULL;
		controller = DuAEF.Duik.Controller.create(comp, ctrlType, goal);
		goal.parent = null;
		controller.layer.transform.rotation.setValue(goal.transform.rotation.value);
	}

	if (goal) goal.parent = controller.layer;

	//add effect
	var name = layers[0].name;
	var ikEffect = DuAEF.DuAE.Layer.addPseudoEffect(controller.layer,DuAEF.Duik.PseudoEffects.BEZIER_IK,DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK,DuAEF.Duik.generateName('IK',name));

	//create curve controller
	var curveController = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.Controller.Types.POSITION,layers[0]);
	curveController.layer.transform.scale.expression = '';
	curveController.layer.name = curveController.layer.name + " | Curve";
	if (controller.effect) curveController.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER)(4).setValue(controller.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER)(4).value*1/2);

	//create root controller
	var rootController = DuAEF.Duik.Controller.create(comp,DuAEF.Duik.Controller.Types.POSITION,layers[0]);
	rootController.layer.name = rootController.layer.name + " | Root";
	if (controller.effect) rootController.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER)(4).setValue(controller.layer.effect(DuAEF.Duik.PseudoEffectsMatchNames.CONTROLLER)(4).value*1/2);

	//add effect
	var curveEffect = DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.apply(curveController.layer);
	curveEffect(DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer).setValue(rootController.layer.index);
	curveEffect(DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.curveLayer).setValue(curveController.layer.index);
	curveEffect(DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer).setValue(controller.layer.index);

	//useful positions
	var endPosition = DuAEF.DuAE.Layer.getWorldPos(controller.layer);
	if (goal != null) endPosition = DuAEF.DuAE.Layer.getWorldPos(goal);
	var rootPosition = DuAEF.DuAE.Layer.getWorldPos(layers[0]);
	curveController.layer.transform.position.setValue((endPosition+rootPosition)/2);
	var cOutPosition = (2*endPosition+rootPosition)/3;
	var cInPosition = (endPosition+2*rootPosition)/3;

	//add handles
	var handleInGroup = curveController.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	handleInGroup.name = 'Handle In';
	handleInContent = handleInGroup.property("ADBE Vectors Group");
	var circle = handleInContent.addProperty("ADBE Vector Shape - Ellipse");
	circle("ADBE Vector Ellipse Size").setValue([25,25]);
	var fill = handleInContent.addProperty("ADBE Vector Graphic - Fill");
	fill("ADBE Vector Fill Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]\n';
	handleInGroup.transform.scale.expression = '[effect("Controller")(4),effect("Controller")(4)]';

	handleInGroup.transform.position.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
		'var root = null;\n' +
		'var curve = thisLayer;\n' +
		'var result = value;\n' +
		'try { root = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer + ') ;} catch(e){}\n' +
		'if (root != null)\n' +
		'{\n' +
		'var rootPos = root.toWorld(root.anchorPoint);\n' +
		'rootPos = fromWorld(rootPos);\n' +
		'result += rootPos/2;\n' +
		'}\n' +
		'result;';
	//Auto handle position disabled as it mess up the order of the evaluation of the expressions
	//DuAEF.DuAE.Property.removeExpression(handleInGroup.transform.position);

	handleInGroup.transform.opacity.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
		'fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.showHandlesCheckbox + ').value*100';

	var handleOutGroup = curveController.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
	handleOutGroup.name = 'Handle Out';
	handleOutContent = handleOutGroup.property("ADBE Vectors Group");
	var circle = handleOutContent.addProperty("ADBE Vector Shape - Ellipse");
	circle("ADBE Vector Ellipse Size").setValue([25,25]);
	var fill = handleOutContent.addProperty("ADBE Vector Graphic - Fill");
	fill("ADBE Vector Fill Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]\n';
	handleOutGroup.transform.scale.expression = '[effect("Controller")(4),effect("Controller")(4)]';

	//Auto handle position disabled as it mess up the order of the evaluation of the expressions
	handleOutGroup.transform.position.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
		'var end = null;\n' +
		'var curve = thisLayer;\n' +
		'var result = value;\n' +
		'try { end = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer + '); } catch(e){}\n' +
		'if (end != null)\n' +
		'{\n' +
		'var endPos = end.toWorld(end.anchorPoint);\n' +
		'endPos = fromWorld(endPos);\n' +
		'result += endPos/2;\n' +
		'}\n' +
		'result;';
	//Auto handle position disabled as it mess up the order of the evaluation of the expressions
	//DuAEF.DuAE.Property.removeExpression(handleOutGroup.transform.position);

	handleOutGroup.transform.opacity.expression = 'var fx = effect("' + curveEffect.name + '");\n' +
		'fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.showHandlesCheckbox + ').value*100';

	//add line
	if (DuAEF.DuAE.App.version >= 15)
	{
		var lineGroup = curveController.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		lineGroup.name = 'IK Line';
		var lineContent = lineGroup.property("ADBE Vectors Group");
		var shape = lineContent.addProperty("ADBE Vector Shape - Group");
		shape('ADBE Vector Shape').expression = 'var fx = effect("' + curveEffect.name + '");\n' +
			'var root = null;\n' +
			'var curve = thisLayer;\n' +
			'var end = null;\n' +
			'var result = [[0,0]];\n' +
			'if (fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.drawGuidesCheckbox + ').value)\n' +
			'{\n' +
			'try { root = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.rootLayer + ') ; end = fx(' + DuAEF.Duik.PseudoEffects.BEZIER_IK_CURVE.endLayer + ') } catch(e){}\n' +
			'if (root != null)\n' +
			'{\n' +
			'var r = root.toWorld(root.anchorPoint);\n' +
			'r = fromWorld(r);\n' +
			'var e = end.toWorld(end.anchorPoint);\n' +
			'e = fromWorld(e);\n' +
			'var t1 = content("Handle In").transform.position;\n' +
			'var t2 = content("Handle Out").transform.position;\n' +
			'result = [r,t1,t2,e];\n' +
			'}\n' +
			'}\n' +
			'createPath(result,[],[],false);';
		var stroke = lineContent.addProperty("ADBE Vector Graphic - Stroke");
		stroke("ADBE Vector Stroke Color").expression = 'effect("Controller")(2)-[0.2,0.2,0.2,0]';
		stroke("ADBE Vector Stroke Width").setValue(2);
		stroke("ADBE Vector Stroke Line Cap").setValue(2);
		stroke("ADBE Vector Stroke Dashes").addProperty("ADBE Vector Stroke Dash 1");
		stroke("ADBE Vector Stroke Dashes")("ADBE Vector Stroke Dash 1").setValue(5);
	}

	//setup layers
	var rootIndex = rootController.layer.index;
	var endIndex = controller.layer.index;
	var curveIndex = curveController.layer.index;
	var totalLength = DuAEF.DuJS.Math.getLength(rootPosition,cInPosition) + DuAEF.DuJS.Math.getLength(cOutPosition,cInPosition) + DuAEF.DuJS.Math.getLength(cOutPosition,endPosition);

	//un-parent
	for (var i = 1 ; i < layers.length ; i++)
	{
		layers[i].parent = null;
	}

	layers[0].parent = rootController.layer;

	for (var i = 0 ; i < layers.length ; i++)
	{
		var layer = layers[i];
		//add effect
		var layerEffect = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.BEZIER_IK_LAYER,DuAEF.Duik.PseudoEffectsMatchNames.BEZIER_IK_LAYER,"Bezier IK");
		layerEffect(3).setValue(rootIndex);
		layerEffect(4).setValue(curveIndex);
		layerEffect(5).setValue(endIndex);
		if (i < layers.length -1) layerEffect(6).setValue(layers[i+1].index);
		else layerEffect(6).setValue(controller.layer.index);

		//expressions

		//position
		if (i != 0)
		{
			var index = DuAEF.DuJS.Math.getLength(endPosition,layer.transform.position.value);
			index = index/totalLength;
			layer.transform.position.expression = '//Duik.bezierIK\n' +
				'var end = null;\n' +
				'var root = null;\n' +
				'var curve = null;\n' +
				'var result = value;\n' +
				'var thisFx = effect("' + layerEffect.name + '");\n' +
				'try{end=thisFx(5);curve=thisFx(4);root=thisFx(3);}catch(e){};\n' +
				'if(root !=null)\n' +
				'{\n' +
				'var ind = ' + index + ';\n' +
				'var fx = end.effect("' + ikEffect.name + '");\n' +
				'var offset = thisFx(1)/100;\n' +
				'var generalOffset = fx(2)/100;\n' +
				'var endPosition = end.toComp(end.anchorPoint);\n' +
				'var rootPosition = root.toComp(root.anchorPoint);\n' +
				'var curvePosition1 = curve.toComp(curve.content("Handle Out").transform.position);\n' +
				'var curvePosition2 = curve.toComp(curve.content("Handle In").transform.position);\n' +
				'var t = ind + generalOffset + offset;\n' +
				'var c = 3*(curvePosition1 - endPosition);\n' +
				'var b = 3*(curvePosition2 - curvePosition1) - c;\n' +
				'var a = rootPosition - endPosition - c - b;\n' +
				'result += ((a*t +b )*t + c)*t + endPosition ;\n' +
				'result -= ' + layer.transform.position.value.toSource() + ';\n' +
				'}\n' +
				'result;';
		}

		//rotation
		var expr = '//Duik.bezierIK\n' +
			'var c = null;\n' +
			'var result = value;\n' +
			'var thisFx = effect("' + layerEffect.name + '");\n' +
			'try{c = thisFx(5)}catch(e){}\n' +
			'if (c!=null)\n' +
			'{\n' +
			'var n = c;\n' +
			'try {n=thisFx(6); if (n.index == index) n=c}catch(e){}\n' +
			'var fx = c.effect("' + ikEffect.name + '");\n' +
			'var autoOrient = fx(1).value;\n' +
			'var C = n.toWorld(n.anchorPoint);\n' +
			'var O =  thisLayer.toWorld(thisLayer.anchorPoint);\n' +
			'var vec = O-C;\n' +
			'var angle = Math.atan2(vec[1], vec[0]);\n' +
			'var ik = radiansToDegrees(angle);\n' +
			'if (autoOrient==1) result += ik;\n';
		if (i == 0)
		{
			expr += 'var layer = thisLayer;\n' +
			'while(layer.hasParent)\n' +
			'{\n' +
			'layer = layer.parent;\n' +
			'result -= layer.transform.rotation;\n' +
			'}\n';
		}
		expr += '}\n' +
			'result;';

		DuAEF.DuAE.Property.setExpression(layer.transform.rotation,expr);
	}

	curveController.layer.selected = false;
	controller.layer.moveBefore(curveController.layer);

	return [curveController,controller,rootController];
}

DuAEF.Duik.Rigging.goal = function (layers, controller)
{
	if (layers instanceof Array) layers = DuAEF.DuAE.Layer.sortByParent(layers);
	else layers = [layers];
	var numLayers = layers.length;

	if (controller instanceof Controller) controller = controller.layer;
	//add checkbox and data
	var effect = controller.effect.addProperty("ADBE Checkbox Control");
	effect.name = layers[0].name + " Follow";
	var effectName = effect.name;


	for (var i = 0; i<layers.length;i++)
	{
		var goalData = layers[i].effect.addProperty("ADBE Layer Control");
		goalData.name = "Goal";
		goalData(1).setValue(controller.index);

		var exp = "//Duik.goal\n" +
			"var ctrl = null;\n" +
			"var result = value;\n" +
			"try { ctrl = effect(\"Goal\")(1); } catch (e){};\n" +
			"if (ctrl != null)\n" +
			"{\n" +
			"var goal = ctrl.effect(\"" + effectName + "\")(1).value;\n" +
			"result += ctrl.rotation.value/" + (numLayers/(i+1)) + ";\n" +
			"if (!goal)\n" +
			"{\n" +
			"var layer = thisLayer;\n" +
			"while (layer.hasParent)\n" +
			"{\n" +
			"layer = layer.parent;\n" +
			"result = result - layer.rotation/" + (numLayers/(i+1)) + ";\n" +
			"}\n" +
			"}\n" +
			"}\n" +
			"result;";

		DuAEF.DuAE.Property.setExpression(layers[i].transform.rotation, exp);
	}
}

/**
	* Creates a FK with auto-overlapping and its controller on the layers/the structure.
	* @param {Layer[]|Structure} layers - The layers, already parented or ordered from root (at index 0) to end
	* @param {Layer|Controller|null} [controller] - An already existing controller.
	* @return {Controller} The controller of the FK.
*/
DuAEF.Duik.Rigging.fkOverlap = function (layers,controller)
{
	if (typeof controller === 'undefined') controller = null;
	if (layers instanceof Structure) layers = layers.elements;

	var comp = layers[0].containingComp;

	//check if there is a controller in the selection
	if (controller == null)
	{
		for (var i = 0,num = layers.length; i < num ; i++)
		{
			var l = layers[i];
			if (DuAEF.Duik.isLayerType(l,DuAEF.Duik.LayerTypes.CONTROLLER))
			{
				controller = l;
				layers.splice(i,1);
				break;
			}
		}
	}

	//sort layers and parent them
	var layers = DuAEF.DuAE.Layer.sortByParent(layers);
	//reset rotation and scale if structures
	var it = new Iterator(layers)
	it.do(DuAEF.Duik.Structure.resetTransform);
	DuAEF.DuAE.Layer.parentChain(layers);

	//Create controller
	if (controller == null)
	{
		var ctrlType = DuAEF.Duik.Controller.Types.ROTATION;
		if (DuAEF.Duik.Controller.defaultType == DuAEF.Duik.Controller.Types.NULL) ctrlType = DuAEF.Duik.Controller.Types.NULL;
		controller = DuAEF.Duik.Controller.create(comp,ctrlType,layers[0]);
	}
	if (!(controller instanceof Controller))
	{
		controller = new Controller(controller);
	}

	var name = layers[0].name;
	var fkEffect = DuAEF.DuAE.Layer.addPseudoEffect(controller.layer,DuAEF.Duik.PseudoEffects.FK_OVERLAP,DuAEF.Duik.PseudoEffectsMatchNames.FK_OVERLAP,DuAEF.Duik.generateName('FK Overlap',name));
	fkEffect(7).setValue(-180);
	fkEffect(1).setValue(100);
	fkEffect(2).setValue(10);
	var fkEffectName = fkEffect.name;

	//rig layers
	var it = new Iterator(layers);
	it.do(function(layer) {
		//add Data
		var layerData = DuAEF.DuAE.Layer.addPseudoEffect(layer,DuAEF.Duik.PseudoEffects.IK,DuAEF.Duik.PseudoEffectsMatchNames.IK,"FK Overlap");
		layerData(1).setValue(controller.layer.index);

		//add FK control
		var fkControl = controller.layer('ADBE Effect Parade').addProperty('ADBE Angle Control');
		fkControl.name = layer.name;

		//add expression
		if (it.current == 0)
		{
			layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
				'var controller = null;\n ' +
				'var result = value;\n ' +
				'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
				'if (controller !=null)\n ' +
				'{\n ' +
				'var fx = controller.effect("' + fkEffectName + '");\n ' +
				'result += controller.transform.rotation.value + fx(3).value ;\n ' +
				'var follow = fx(4).value;\n ' +
				'var p = thisLayer;\n ' +
				'if (!follow)\n ' +
				'{\n ' +
				'while(p.hasParent)\n ' +
				'{\n ' +
				'p = p.parent;\n ' +
				'result -= p.rotation.value;\n ' +
				'}\n ' +
				'}\n ' +
				'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
				'{\n ' +
				'var fk = controller("Effects")(i);\n ' +
				'if (fk.name == thisLayer.name)\n ' +
				'{\n ' +
				'result+=fk(1).value;\n ' +
				'break;\n' +
				'}	\n ' +
				'}\n ' +
				'}\n ' +
				'result;';
		}
		else if (it.current == 1)
		{
			layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
				'var controller = null;\n ' +
				'var result = value;\n ' +
				'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
				'if (controller !=null && hasParent)\n ' +
				'{\n ' +
				'var fx = controller.effect("' + fkEffectName + '");\n ' +
				'var ctrlRot = controller.transform.rotation;\n ' +
				'var delay = fx(2).value ;\n ' +
				'var amp = fx(1).value ;\n ' +
				'var uLimit = fx(6).value ;\n ' +
				'var lLimit = fx(7).value ;\n ' +
				'var manual = fx(3).value ;\n ' +
				'var follow = fx(4).value;\n ' +
				'delay = delay / 100;\n ' +
				'amp = amp / 100 ;\n ' +
				'result = ctrlRot.valueAtTime(time-delay) + fx(3).valueAtTime(time-delay);\n ' +
				'if (follow && hasParent)\n ' +
				'{\n ' +
				'var cP = parent;\n ' +
				'while(cP.hasParent)\n ' +
				'{\n ' +
				'cP = cP.parent;\n ' +
				'if (cP.index = controller.index) follow = false;\n ' +
				'result -= cP.rotation.value - cP.rotation.valueAtTime(time-delay) ;\n ' +
				'}\n ' +
				'}\n ' +
				'result = result - ctrlRot.value ;\n ' +
				'result = result * amp;\n ' +
				'result = result - ctrlRot.velocity*(delay/5);\n ' +
				'if (result > uLimit) result = uLimit;\n ' +
				'if (result < lLimit) result = lLimit;\n ' +
				'result = result + value + manual;\n ' +
				'if (follow) result -= parent.transform.rotation.valueAtTime(0);\n ' +
				'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
				'{\n ' +
				'var fk = controller("Effects")(i);\n ' +
				'if (fk.name == thisLayer.name)\n ' +
				'{\n ' +
				'result+=fk(1).value;\n ' +
				'break;\n' +
				'}	\n ' +
				'}\n ' +
				'}\n ' +
				'result;';
		}
		else
		{
			layer.transform.rotation.expression = '//Duik.fkOverlap\n ' +
				'var controller = null;\n ' +
				'var result = value;\n ' +
				'try{controller=effect("' + layerData.name + '")(1)}catch(e){}\n ' +
				'if (controller !=null && hasParent)\n ' +
				'{\n ' +
				'var fx = controller.effect("' + fkEffectName + '");\n ' +
				'var ctrlRot = controller.transform.rotation;\n ' +
				'var parentRot = parent.transform.rotation ;\n ' +
				'var delay = fx(2).value ;\n ' +
				'var amp = fx(1).value ;\n ' +
				'var uLimit = fx(6).value ;\n ' +
				'var lLimit = fx(7).value ;\n ' +
				'var manual = fx(3).value ;\n ' +
				'delay = delay / 100;\n ' +
				'amp = amp / 100 ;\n ' +
				'result = parentRot.valueAtTime(time-delay);\n ' +
				'result = result * amp;\n ' +
				'if (result > uLimit) result = uLimit;\n ' +
				'if (result < lLimit) result = lLimit;\n ' +
				'result = result + value + manual - parent.transform.rotation.valueAtTime(0);\n ' +
				'for (var i = 1 ; i <= controller("Effects").numProperties ; i++)\n ' +
				'{\n ' +
				'var fk = controller("Effects")(i);\n ' +
				'if (fk.name == thisLayer.name)\n ' +
				'{\n ' +
				'result+=fk(1).value;\n ' +
				'break;\n' +
				'}	\n ' +
				'}\n ' +
				'}\n ' +
				'result;';
		}
	});

	controller.layer.selected = true;

	return controller;
}
