/*
	Duik - Duduf IK Tools

	Copyright (c) 2008 - 2017 Nicolas Dufresne, Rainbox Productions

	https://rainboxprod.coop

	__Contributors:__

		Nicolas Dufresne - Lead developer
		Kevin Masson - Developer

	__Translations:__

		eZioPan – Simplified Chinese
		Ana Arce – Spanish
		Adam Szczepański – Polish

	__Thanks to:__

		Dan Ebberts - Writing the first IK Expressions
		Eric Epstein - making the IK's work with 3D Layers
		Kevin Schires – Including images in the script
		Matias Poggini – Bezier IK feature
		Eric Epstein - Making the IK's work with 3D Layers
		Assia Chioukh and Quentin Saint-Georges – User Guides composition
		Motion Cafe – Ideas and feedback
		Fous d’anim – Ideas and feedback
		All 258 Duik 15 indiegogo backers for making this libDuik possible!

	__Duik makes use of:__

		• x2js
		Copyright (c) 2011-2013 Abdulla Abdurakhmanov
		Original sources are available at https://code.google.com/p/x2js/
		Licensed under the Apache License, Version 2.0

		• json2
		See http://www.JSON.org/js.html
		Public Domain

		• seedRandom
		Copyright (c) David Bau
		Licensed under the MIT license

		• FFMpeg
		See http://ffmpeg.org

		• DuFFMpeg
		Copyright (c) 2017 Nicolas Dufresne and Rainbox Productions
		Sources available at https://github.com/Rainbox-dev/DuFFMpeg
		Licensed under the GNU General Public License v3

	This file is part of Duik.

		Duik is free software: you can redistribute it and/or modify
		it under the terms of the GNU General Public License as published by
		the Free Software Foundation, either version 3 of the License, or
		(at your option) any later version.

		Duik is distributed in the hope that it will be useful,
		but WITHOUT ANY WARRANTY; without even the implied warranty of
		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		GNU General Public License for more details.

		You should have received a copy of the GNU General Public License
		along with Duik. If not, see <http://www.gnu.org/licenses/>.

*/

// An object with basic infos required to check if it's needed to reload Duik
var duikUpdate = {};
duikUpdate.init = false;
duikUpdate.version = "16.0.0-alpha";
duikUpdate.majorVersion = 16;
duikUpdate.minorVersion = 0;
duikUpdate.build = 0;

// Check if Duik is up-to-date
(function ()
{
	if (typeof Duik === 'object')
	{
		//check major version
		if (!Duik.majorVersion == undefined) duikUpdate.init = true;
		else if (Duik.majorVersion < majorVersion) duikUpdate.init = true;
		else if (Duik.majorVersion == majorVersion)
		{
			if (!Duik.minorVersion == undefined) duikUpdate.init = true;
			else if (Duik.minorVersion < minorVersion) duikUpdate.init = true;
			else if (Duik.minorVersion == minorVersion)
			{
				if (Duik.build == undefined) duikUpdate.init = true;
				else if (Duik.build < build) duikUpdate.init = true;
			}
		}
	}
	else
	{
		duikUpdate.init = true;
	}
})();

// if Duik has to be updated, load it.
if (duikUpdate.init)
{
	// CUSTOM CLASSES
	{
		/**
		 * DuFFMpeg
		 * Copyright (c) 2017 Nicolas Dufresne and Rainbox Productions
		 * Sources available at https://github.com/Rainbox-dev/DuFFMpeg
		 * Licensed under the GNU General Public License v3
		*/
		{
			/**
			 * Constructs a new FFMpeg encoder.
			 * The constructor will try to find the ffmpeg binary in the same folder as libDuik, or an (ffmpeg) subfolder, or in the scripts folder of After Effects.
			 * If ffmpeg is not in one of those, the property ffmpegPath will be an empty string, and it has to be set by the user.
			 * @class FFMpeg
			 * @classdesc A class used to easily encode medias with ffmpeg
			 * @property {string}	  ffmpegPath		- The path to the FFMpeg binary.
			 * @property {string}	   options			- The options of the encoder. Default: '-stats'
			 * @property {Array}	   queue			- An Array of FFMpegQueueItem
			 */
			function FFMpeg(options)
			{
				//detect os
				var mac = $.os.toLowerCase().indexOf("mac") >= 0;
				this.mac = mac;
				this.win = !mac;

				if (options == undefined) options = '-stats';

				this.ffmpegPath = '';

				//try to detect the ffmpeg path
				var ffmpegBinName = '';
				if (this.win) ffmpegBinName = 'ffmpeg.exe';
				else ffmpegBinName = 'ffmpeg';
				//first, in the same dir
				var ffmpegFile = new File($.fileName.substring(0,$.fileName.lastIndexOf('/')) + '/' + ffmpegBinName);
				//in an (ffmpeg) subfolder
				if (!ffmpegFile.exists)
				{
					ffmpegFile = new File($.fileName.substring(0,$.fileName.lastIndexOf('/')) + '/(ffmpeg)/' + ffmpegBinName);
				}
				//in AE Scripts folder
				if (!ffmpegFile.exists)
				{
					ffmpegFile = new File(Folder.appPackage.absoluteURI + '/Scripts/' + ffmpegBinName);
				}
				//in AE Scripts/(ffmpeg) folder
				if (!ffmpegFile.exists)
				{
					ffmpegFile = new File(Folder.appPackage.absoluteURI + '/Scripts/(ffmpeg)/' + ffmpegBinName);
				}
				//in AE ScriptUI Panels
				if (!ffmpegFile.exists)
				{
					ffmpegFile = new File(Folder.appPackage.absoluteURI + '/Scripts/ScriptUI Panels/' + ffmpegBinName);
				}
				//in AE ScriptUI Panels/(ffmpeg)
				if (!ffmpegFile.exists)
				{
					ffmpegFile = new File(Folder.appPackage.absoluteURI + '/Scripts/ScriptUI Panels/(ffmpeg)/' + ffmpegBinName);
				}

				if (ffmpegFile.exists) this.ffmpegPath = ffmpegFile.fsName;

				this.options = options;
				this.queue = [];
			}

			/**
			 * Launches encoding
			 * @memberof FFMpeg
			 * @return {string} The text returned by ffmpeg (currently works on win only, empty string on mac)
			 */
			FFMpeg.prototype.launch = function ()
			{
				var cmd = '';
				if (this.win) cmd += '"' + this.ffmpegPath + '"';
				else
				{
				  var ffmpegFile = new File(this.ffmpegPath);
				  cmd += '"' + ffmpegFile.parent.fsName + '"/./' + ffmpegFile.name;
				}

				//add options
				cmd += ' ' + this.options;

				//add RenderItems
				for (var i = 0 ; i < this.queue.length ; i++)
				{
					var item = this.queue[i];
					cmd += ' ' + item.input.options;
					cmd += ' -i "' + item.input.inputPath + '"';
					//add outputs
					for (var j = 0 ; j < item.outputs.length ; j++)
					{
						var output = item.outputs[j];
						cmd += ' -c ' + output.codec;
						cmd += ' ' + output.options;
						cmd += ' "' + output.outputPath + '"';
					}
				}

				//launch!

				// mac hack, do not wait for ffmpeg as it freezes AE
				if (this.mac) cmd = cmd + ' &';

				system.callSystem(cmd);

				// mac hack, but let's wait anyway
				if (this.mac)
				{
				  //timeout
				  var currentDate = new Date();
				  var timeout = currentDate.getTime() + 30000;
				  var checkTime = new Date();

				  var cmd = 'ps -A | grep "[f]fmpeg"';

				  //wait
				  while(checkTime.getTime() < timeout)
				  {
					var test = system.callSystem(cmd);
					if (test == '') break;
					$.sleep(300);
					checkTime = new Date();
				  }
				}
			}

			/**
			 * Constructs a new FFMpegInputModule module
			 * @class FFMpegInputModule
			 * @classdesc A class used to easily encode medias with ffmpeg
			 * @property {string}	inputPath		- The path to the input file.
			 * @property {string}	options			- The options for the input file. Default: ''
			 */
			function FFMpegInputModule(inputPath,options)
			{
				if (!inputPath) throw "No input file set";
				if (inputPath == '') throw "No input file set";
				var inputFile = new File(inputPath);
				if (!inputFile.exists) throw "The input file does not exist";

				this.inputPath = inputFile.fsName;

				if (!options) options = '';
				this.options = options;
			}

			/**
			 * Constructs a new FFMpegOutputModule module
			 * @class FFMpegOutputModule
			 * @classdesc A class used to easily encode medias with ffmpeg
			 * @property {string}	codec			- The codec used for transcoding.
			 * @property {string}	outputPath		- The path to the output file.
			 * @property {string}	options			- The options for the output file (other than setting the codec). Default: ''
			 */
			function FFMpegOutputModule(codec,outputPath,options)
			{
				if (!codec) throw "No codec set";
				if (codec == '') throw "No codec set";

				this.codec = codec;

				//f (!outputPath) throw "No output file set";
				//if (outputPath == '') throw "No output file set";

				var outputFile = new File(outputPath);
				this.outputPath = outputFile.fsName;

				if (!options) options = '';
				this.options = options;
			}

			/**
			 * Constructs a new FFMpegQueueItem
			 * @class FFMpegQueueItem
			 * @classdesc A class used to easily encode medias with ffmpeg
			 * @property {FFMpegInputModule}	input	  - The input module.
			 * @property {Array}				outputs	   - An Array of FFMpegOutputModule. The output modules
			 */
			function FFMpegQueueItem(input,outputs)
			{
				if (!input) throw "No input set";

				this.input = input;

				if (!outputs) throw "No output set";
				if (outputs.length < 1) throw "Empty outputs";

				this.outputs = outputs;
			}
		}

		/**
		 * JSON PARSER
		 * json2
		 * See http://www.JSON.org/js.html
		 * Public Domain
		*/
		{
			if(typeof JSON!=="object"){JSON={};}
			(function(){"use strict";var rx_one=/^[\],:{}\s]*$/;var rx_two=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;var rx_three=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;var rx_four=/(?:^|:|,)(?:\s*\[)+/g;var rx_escapable=/[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;var rx_dangerous=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;function f(n){return n<10?"0"+n:n;}
			function this_value(){return this.valueOf();}
			if(typeof Date.prototype.toJSON!=="function"){Date.prototype.toJSON=function(){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+
			f(this.getUTCMonth()+1)+"-"+
			f(this.getUTCDate())+"T"+
			f(this.getUTCHours())+":"+
			f(this.getUTCMinutes())+":"+
			f(this.getUTCSeconds())+"Z":null;};Boolean.prototype.toJSON=this_value;Number.prototype.toJSON=this_value;String.prototype.toJSON=this_value;}
			var gap;var indent;var meta;var rep;function quote(string){rx_escapable.lastIndex=0;return rx_escapable.test(string)?"\""+string.replace(rx_escapable,function(a){var c=meta[a];return typeof c==="string"?c:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4);})+"\"":"\""+string+"\"";}
			function str(key,holder){var i;var k;var v;var length;var mind=gap;var partial;var value=holder[key];if(value&&typeof value==="object"&&typeof value.toJSON==="function"){value=value.toJSON(key);}
			if(typeof rep==="function"){value=rep.call(holder,key,value);}
			switch(typeof value){case"string":return quote(value);case"number":return isFinite(value)?String(value):"null";case"boolean":case"null":return String(value);case"object":if(!value){return"null";}
			gap+=indent;partial=[];if(Object.prototype.toString.apply(value)==="[object Array]"){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||"null";}
			v=partial.length===0?"[]":gap?"[\n"+gap+partial.join(",\n"+gap)+"\n"+mind+"]":"["+partial.join(",")+"]";gap=mind;return v;}
			if(rep&&typeof rep==="object"){length=rep.length;for(i=0;i<length;i+=1){if(typeof rep[i]==="string"){k=rep[i];v=str(k,value);if(v){partial.push(quote(k)+(gap?": ":":")+v);}}}}else{for(k in value){if(Object.prototype.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?": ":":")+v);}}}}
			v=partial.length===0?"{}":gap?"{\n"+gap+partial.join(",\n"+gap)+"\n"+mind+"}":"{"+partial.join(",")+"}";gap=mind;return v;}}
			if(typeof JSON.stringify!=="function"){meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r","\"":"\\\"","\\":"\\\\"};JSON.stringify=function(value,replacer,space){var i;gap="";indent="";if(typeof space==="number"){for(i=0;i<space;i+=1){indent+=" ";}}else if(typeof space==="string"){indent=space;}
			rep=replacer;if(replacer&&typeof replacer!=="function"&&(typeof replacer!=="object"||typeof replacer.length!=="number")){throw new Error("JSON.stringify");}
			return str("",{"":value});};}
			if(typeof JSON.parse!=="function"){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k;var v;var value=holder[key];if(value&&typeof value==="object"){for(k in value){if(Object.prototype.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v;}else{delete value[k];}}}}
			return reviver.call(holder,key,value);}
			text=String(text);rx_dangerous.lastIndex=0;if(rx_dangerous.test(text)){text=text.replace(rx_dangerous,function(a){return"\\u"+
			("0000"+a.charCodeAt(0).toString(16)).slice(-4);});}
			if(rx_one.test(text.replace(rx_two,"@").replace(rx_three,"]").replace(rx_four,""))){j=eval("("+text+")");return(typeof reviver==="function")?walk({"":j},""):j;}
			throw new SyntaxError("JSON.parse");};}}());
		}

		/**
		 * seedRandom
		 * Copyright David Bau
		 * Licensed under the MIT license
		 */
		!function(a,b){function c(c,j,k){var n=[];j=1==j?{entropy:!0}:j||{};var s=g(f(j.entropy?[c,i(a)]:null==c?h():c,3),n),t=new d(n),u=function(){for(var a=t.g(m),b=p,c=0;q>a;)a=(a+c)*l,b*=l,c=t.g(1);for(;a>=r;)a/=2,b/=2,c>>>=1;return(a+c)/b};return u.int32=function(){return 0|t.g(4)},u.quick=function(){return t.g(4)/4294967296},u["double"]=u,g(i(t.S),a),(j.pass||k||function(a,c,d,f){return f&&(f.S&&e(f,t),a.state=function(){return e(t,{})}),d?(b[o]=a,c):a})(u,s,"global"in j?j.global:this==b,j.state)}function d(a){var b,c=a.length,d=this,e=0,f=d.i=d.j=0,g=d.S=[];for(c||(a=[c++]);l>e;)g[e]=e++;for(e=0;l>e;e++)g[e]=g[f=s&f+a[e%c]+(b=g[e])],g[f]=b;(d.g=function(a){for(var b,c=0,e=d.i,f=d.j,g=d.S;a--;)b=g[e=s&e+1],c=c*l+g[s&(g[e]=g[f=s&f+b])+(g[f]=b)];return d.i=e,d.j=f,c})(l)}function e(a,b){return b.i=a.i,b.j=a.j,b.S=a.S.slice(),b}function f(a,b){var c,d=[],e=typeof a;if(b&&"object"==e)for(c in a)try{d.push(f(a[c],b-1))}catch(g){}return d.length?d:"string"==e?a:a+"\0"}function g(a,b){for(var c,d=a+"",e=0;e<d.length;)b[s&e]=s&(c^=19*b[s&e])+d.charCodeAt(e++);return i(b)}function h(){try{if(j)return i(j.randomBytes(l));var b=new Uint8Array(l);return(k.crypto||k.msCrypto).getRandomValues(b),i(b)}catch(c){var d=k.navigator,e=d&&d.plugins;return[+new Date,k,e,k.screen,i(a)]}}function i(a){return String.fromCharCode.apply(0,a)}var j,k=this,l=256,m=6,n=52,o="random",p=b.pow(l,m),q=b.pow(2,n),r=2*q,s=l-1;if(b["seed"+o]=c,g(b.random(),a),"object"==typeof module&&module.exports){module.exports=c;try{j=require("crypto")}catch(t){}}else"function"==typeof define&&define.amd&&define(function(){return c})}([],Math);

		function KeySpatialProperties (){
			this.inTangent = null;
			this.outTangent = null;
			this._continuous = true;
			this._autoBezier = false;
			this._roving = false;
		}

		function KeyFrame(){
			this._time = 0;
			this.value = null;
			this._inInterpolationType = KeyframeInterpolationType.LINEAR;
			this._outInterpolationType = KeyframeInterpolationType.LINEAR;
			this._spatial = false;
			this.spatialProperties = new KeySpatialProperties();
			this.inEase = null;
			this.outEase = null;
			this._continuous = false;
			this._autoBezier = false;
		}

		function PropertyAnim(){
			this._name = "";
			this._matchName = "";
			this.keys = [];
			this.startValue = null;
		}

		function MaskAnim(){
			this._name = "";
			this._matchName = "";
			this.anims = [];
		}

		function EffectAnim(){
			this._name = "";
			this._matchName = "";
			this.anims = [];
		}

		function LayerAnim(){
			this._name = "";
			this._index = 0;
			this.transformAnims = [];
			this.masksAnims = [];
			this.effectsAnims = [];
		}

		/**
		 * Constructs a new IKRig object
		 * @class IKRig
		 * @classdesc Describes an IK
		 * @property {number}	type			- The type of IK (the number of layers controlled by the IK)
		 * @property {Layer}	layer1			- The first layer (root) of the IK
		 * @property {Layer}	layer2			- The second layer (middle) of the IK, or null if type is 1
		 * @property {Layer}	layer3			- The third layer (end) of the IK, or null if type is 1 or 2
		 * @property {Layer}	goal			- The goal of the IK, may be null
		 * @property {Layer}	controller		- The controller of the IK
		 * @property {bool}		threeD			- Wether the IK uses 3D Layers (works only if type is 2)
		 * @property {bool}		frontFacing		- Wether the 3D IK is facing the "front" view of After Effects (if false, the layers face the right or left view)
		 * @property {bool}		clockWise		- Determines the orientation
		 * @property {bool}		created			- Wether the IK is created in After Effects or if this is still a virtual object which still needs to be created
		 */
		function IKRig()
		{
			this.type = 0;
			this.layer1 = null; //root
			this.layer2 = null; //middle
			this.layer3 = null; //end
			this.goal = null;
			this.controller = null;
			this.threeD = false;
			this.frontFacing = false;
			this.clockWise = false;
			this.created = false;
		}

		/**
		 * Creates the IK in After Effects, using the properties of the object which should already be set
		 * Sets the IKRig.created property to true if the IK has been correctly created
		 * @memberof IKRig
		 * @param {bool}	lockLayers	If true, layers (bones) will be locked and set to shy after creation
		 * @returns {bool} 	Wether the IK has been correctly created
		 */
		IKRig.prototype.create = function (lockLayers)
		{
			if (this.created) return false;
			if (this.type == 1 && this.layer1 != null && this.controller != null)
			{
				this.created = Duik.oneLayerIK(this.controller,this.layer1);
				if (!this.created) return false;
				if (this.goal != null)
				{
					if (this.layer1.parent == this.goal) this.layer1.parent = null;
					this.goal.parent = this.layer1;
					Duik.goal(this.goal,this.controller);
				}
			}
			else if (this.type == 2 && this.layer1 != null && this.layer2 != null && this.controller != null)
			{
				//parents
				if (this.layer1.parent == this.layer2) this.layer1.parent = null;
				this.layer2.parent = this.layer1;
				//3d
				this.threeD = this.controller.threeDLayer && this.layer1.threeDLayer && this.layer2.threeDLayer;
				//create
				var zero = Duik.twoLayerIK(this.controller,this.layer1,this.layer2,this.clockWise,this.frontFacing);
				this.created = true;
				//goal
				if (this.goal != null)
				{
					this.goal.parent = this.layer2;
					Duik.goal(this.goal,this.controller);
					if (zero) this.goal.transform.position.expression = "thisComp.layer(\"" + zero.name + "\").position";
					else this.goal.transform.position.expression = "thisComp.layer(\"" + this.layer2.name + "\").effect(\"" + Duik.uiStrings.ikEnd + "\")(1)";
				}
			}
			else if (this.type == 3 && this.layer1 != null && this.layer2 != null && this.layer3 != null && this.controller != null)
			{
				//parents
				if (this.layer2.parent == this.layer3) this.layer2.parent = null;
				if (this.layer1.parent == this.layer2) this.layer1.parent = null;
				this.layer3.parent = this.layer2;
				this.layer2.parent = this.layer1;
				//create
				var zero = Duik.threeLayerIK(this.controller,this.layer1,this.layer2,this.layer3,this.clockWise);
				this.created = true;
				//goal
				if (this.goal != null)
				{
					this.goal.parent = this.layer3;
					Duik.goal(this.goal,this.controller);
					if (zero) this.goal.transform.position.expression = "thisComp.layer(\"" + zero.name + "\").position";
					else this.goal.transform.position.expression = "thisComp.layer(\"" + this.layer3.name + "\").effect(\"" + Duik.uiStrings.ikEnd + "\")(1)";
				}
			}
			//move the controller to avoid bugs, and lock layers
			if (this.created)
			{
				this.controller.transform.position.setValue(this.controller.transform.position.value);

				if (lockLayers)
				{
					if (this.layer1 != null)
					{
						this.layer1.locked = true;
						this.layer1.shy = true;
					}
					if (this.layer2 != null)
					{
						this.layer2.locked = true;
						this.layer2.shy = true;
					}
					if (this.layer3 != null)
					{
						this.layer3.locked = true;
						this.layer3.shy = true;
					}
					if (this.goal != null)
					{
						this.goal.locked = true;
						this.goal.shy = true;
					}
				}

				return true;
			}
		}

		function PropertyDescription()
		{
			this.isEffect = false;
			this.index = 0;
			this.depth = 0;
			this.parentName = "";
			this.dimensions = 0;
			this.canSetExpression = false;
		}

		/**
		 * Constructs a new Controller object
		 * @class Controller
		 * @classdesc Describes a Controller
		 * @property {bool}		locked			- Tells if the controller is locked
		 * @property {bool}	xPosition		- Tells if the controller will be drawn as an X axis
		 * @property {bool}	yPosition		- Tells if the controller will be drawn as an Y axis
		 * @property {bool}	rotation		- Tells if the controller will be drawn as an rotation arrow
		 * @property {bool}	scale			- Tells if the controller will be drawn as a scale manipulator (square handles)
		 * @property {bool}		arc				- Tells if the controller will be drawn as an arc
		 * @property {bool}		eye				- Tells if the controller will be drawn as an eye
		 * @property {bool}		camera			- Tells if the controller will be drawn for a camera
		 * @property {number}	size			- Controller's size in pixels, or if 0 the size will be set automatically depending on the composition dimensions and Duik.settings.controllerSizeHint. Default value is 0.
		 * @property {array}	color			- array of 4 numbers [Red,Green,Blue,Alpha] representing the color
		 * @property {AVLayer}	layer			- The AVLayer used to draw the controller
		 * @property {number}	type			- The layer type of the controller, one of: Duik.layerTypes.VECTOR or Duik.layerTypes.NULL or Duik.layerTypes.SOLID. Default is Duik.layerTypes.VECTOR
		 */
		function Controller()
		{
			this.locked = false;
			this.xPosition = false;
			this.yPosition = false;
			this.rotation = false;
			this.scale = false;
			this.arc = false;
			this.eye = false;
			this.camera = false;
			this.size = 0;
			this.color = [1,1,1,1];
			this.layer = null;
			this.type = Duik.layerTypes.VECTOR;
		}

		/**
		 * Lock the controller
		 * @memberof Controller
		 */
		Controller.prototype.lock = function()
		{
			if (this.layer == null)
			{
				this.locked = false;
				return;
			}
			//get value
			var posValue = this.layer.transform.position.value;
			var rotValue = this.layer.transform.rotation.value;
			var scaValue = this.layer.transform.scale.value;
			if (!this.xPosition && !this.yPosition && !this.eye && !this.camera)
			{
				if (this.layer.transform.position.canSetExpression)
				{
					this.layer.transform.position.expression = "[" + posValue[0] + "," + posValue[1] + "]";
				}
				else
				{
					this.layer.transform.xPosition.expression = posValue[0];
					this.layer.transform.yPosition.expression = posValue[1];
				}
			}
			else if (this.xPosition && !this.yPosition)
			{
				this.layer.transform.position.expression = "[value[0]," + posValue[1] + "]";
			}
			else if (this.yPosition && !this.xPosition)
			{
				this.layer.transform.position.expression = "[" + posValue[0] + ",value[1]]";
			}
			if (!this.rotation && !this.arc && !this.camera)
			{
				this.layer.transform.rotation.expression = rotValue;
			}
			if (!this.scale)
			{
				this.layer.transform.scale.expression = "[" + scaValue[0] + "," + scaValue[1] + "]";
			}
			this.locked = true;
		}

		/**
		 * Unlock the controller
		 * @memberof Controller
		 */
		Controller.prototype.unlock = function()
		{
			if (this.layer == null)
			{
				this.locked = false;
				return;
			}
			//get value
			var posValue = this.layer.transform.position.value;
			var rotValue = this.layer.transform.rotation.value;
			var scaValue = this.layer.transform.scale.value;
			this.layer.transform.position.expression = "";
			this.layer.transform.position.setValue(posValue);
			this.layer.transform.rotation.expression = "";
			this.layer.transform.rotation.setValue(rotValue);
			this.layer.transform.scale.expression = "";
			this.layer.transform.scale.setValue(scaValue);
			this.locked = false;
		}

		/**
		 * Update the controller
		 * Draw the controller depending on its properties
		 * @memberof Controller
		 */
		Controller.prototype.update = function()
		{
			if (this.type != Duik.layerTypes.VECTOR || this.layer == null) return;

			var iconGroup = this.layer.property("ADBE Root Vectors Group")("Icon");
			if (iconGroup != null) iconGroup.remove();

			//controller size
			var controllerSize = this.size;
			if (controllerSize == 0)
			{
				controllerSize = this.layer.containingComp.width/2 + this.layer.containingComp.height/2;
				if (Duik.settings.controllerSizeHint == Duik.sizes.SMALL) controllerSize = Math.floor(controllerSize/40)*100/30;
				else if (Duik.settings.controllerSizeHint == Duik.sizes.MEDIUM) controllerSize = Math.floor(controllerSize/20)*100/30;
				else if (Duik.settings.controllerSizeHint == Duik.sizes.BIG) controllerSize = Math.floor(controllerSize/10)*100/30;
				this.size = controllerSize;
			}

			if (this.arc || this.eye || this.camera)
			{
				this.xPosition = false;
				this.yPosition = false;
				this.rotation = false;
				this.scale = false;
			}

			iconGroup = this.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
			iconGroup.name = "Icon";
			controllerSizeFactor = controllerSize;
			iconGroup("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([controllerSizeFactor,controllerSizeFactor]);
			if (this.rotation)
			{
				//draw
				var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
				group.name = "Rotation";
				var groupContent = group.property("ADBE Vectors Group");
				var ellipse = groupContent.addProperty("ADBE Vector Shape - Ellipse");
				ellipse("ADBE Vector Ellipse Size").setValue([30,30]);
				var trim = groupContent.addProperty("ADBE Vector Filter - Trim");
				trim("ADBE Vector Trim End").setValue(85);
				var arrowShape = new Shape();
				arrowShape.vertices = [[0,-15], [10,-20]];
				arrowShape.closed = false;
				var arrow = groupContent.addProperty("ADBE Vector Shape - Group");
				arrow("ADBE Vector Shape").setValue(arrowShape);
				arrow("ADBE Vector Shape").expression = "value";
				var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
				stroke("ADBE Vector Stroke Color").setValue(this.color);
				stroke("ADBE Vector Stroke Width").setValue(2);
				group("ADBE Vector Transform Group")("ADBE Vector Rotation").setValue(-20);
			}

			if (this.xPosition)
			{
				var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
				group.name = "xPosition";
				var groupContent = group.property("ADBE Vectors Group");
				var horizontalShape = new Shape();
				horizontalShape.vertices = [[15,0], [-15,0]];
				horizontalShape.closed = false;
				var horizontal = groupContent.addProperty("ADBE Vector Shape - Group");
				horizontal("ADBE Vector Shape").setValue(horizontalShape);
				horizontal("ADBE Vector Shape").expression = "value";
				var arrowShape1 = new Shape();
				arrowShape1.vertices = [[10,-7],[15,0], [10,7]];
				arrowShape1.closed = false;
				var arrow1 = groupContent.addProperty("ADBE Vector Shape - Group");
				arrow1("ADBE Vector Shape").setValue(arrowShape1);
				arrow1("ADBE Vector Shape").expression = "value";
				var arrowShape2 = new Shape();
				arrowShape2.vertices = [[-10,7],[-15,0], [-10,-7]];
				arrowShape2.closed = false;
				var arrow2 = groupContent.addProperty("ADBE Vector Shape - Group");
				arrow2("ADBE Vector Shape").setValue(arrowShape2);
				arrow2("ADBE Vector Shape").expression = "value";
				var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
				stroke("ADBE Vector Stroke Color").setValue(this.color);
				if (this.rotation) stroke("ADBE Vector Stroke Width").setValue(2);
				else stroke("ADBE Vector Stroke Width").setValue(2);
				if (this.rotation) group("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([70,70]);
			}

			if (this.yPosition)
			{
				var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
				group.name = "yPosition";
				var groupContent = group.property("ADBE Vectors Group");
				var verticalShape = new Shape();
				verticalShape.vertices = [[0,-15], [0,15]];
				verticalShape.closed = false;
				var vertical = groupContent.addProperty("ADBE Vector Shape - Group");
				vertical("ADBE Vector Shape").setValue(verticalShape);
				vertical("ADBE Vector Shape").expression = "value";
				var arrowShape3 = new Shape();
				arrowShape3.vertices = [[-7,10],[0,15], [7,10]];
				arrowShape3.closed = false;
				var arrow3 = groupContent.addProperty("ADBE Vector Shape - Group");
				arrow3("ADBE Vector Shape").setValue(arrowShape3);
				arrow3("ADBE Vector Shape").expression = "value";
				var arrowShape4 = new Shape();
				arrowShape4.vertices = [[-7,-10],[0,-15], [7,-10]];
				arrowShape4.closed = false;
				var arrow4 = groupContent.addProperty("ADBE Vector Shape - Group");
				arrow4("ADBE Vector Shape").setValue(arrowShape4);
				arrow4("ADBE Vector Shape").expression = "value";
				var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
				stroke("ADBE Vector Stroke Color").setValue(this.color);
				if (this.rotation) stroke("ADBE Vector Stroke Width").setValue(2);
				else stroke("ADBE Vector Stroke Width").setValue(2);
				if (this.rotation) group("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([70,70]);
			}

			if (this.scale)
			{
				var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
				group.name = "Scale";
				var groupContent = group.property("ADBE Vectors Group");
				var cornerShape1 = new Shape();
				cornerShape1.vertices = [[-10,-20],[-20,-20], [-20,-10]];
				cornerShape1.closed = false;
				var corner1 = groupContent.addProperty("ADBE Vector Shape - Group");
				corner1("ADBE Vector Shape").setValue(cornerShape1);
				corner1("ADBE Vector Shape").expression = "value";
				var cornerShape2 = new Shape();
				cornerShape2.vertices = [[10,-20],[20,-20], [20,-10]];
				cornerShape2.closed = false;
				var corner2 = groupContent.addProperty("ADBE Vector Shape - Group");
				corner2("ADBE Vector Shape").setValue(cornerShape2);
				corner2("ADBE Vector Shape").expression = "value";
				var cornerShape3 = new Shape();
				cornerShape3.vertices = [[10,20],[20,20], [20,10]];
				cornerShape3.closed = false;
				var corner3 = groupContent.addProperty("ADBE Vector Shape - Group");
				corner3("ADBE Vector Shape").setValue(cornerShape3);
				corner3("ADBE Vector Shape").expression = "value";
				var cornerShape4 = new Shape();
				cornerShape4.vertices = [[-10,20],[-20,20], [-20,10]];
				cornerShape4.closed = false;
				var corner4 = groupContent.addProperty("ADBE Vector Shape - Group");
				corner4("ADBE Vector Shape").setValue(cornerShape4);
				corner4("ADBE Vector Shape").expression = "value";
				var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
				stroke("ADBE Vector Stroke Color").setValue(this.color);
				stroke("ADBE Vector Stroke Width").setValue(2);
			}

			if (this.arc)
			{
				var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
				group.name = "Arc";
				var groupContent = group.property("ADBE Vectors Group");
				var ellipse = groupContent.addProperty("ADBE Vector Shape - Ellipse");
				ellipse("ADBE Vector Ellipse Size").setValue([30,30]);
				var trim = groupContent.addProperty("ADBE Vector Filter - Trim");
				trim("ADBE Vector Trim End").setValue(35);
				var arrowShape = new Shape();
				arrowShape.vertices = [[0,-15], [10,-20]];
				arrowShape.closed = false;
				var arrow = groupContent.addProperty("ADBE Vector Shape - Group");
				arrow("ADBE Vector Shape").setValue(arrowShape);
				arrow("ADBE Vector Shape").expression = "value";
				var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
				stroke("ADBE Vector Stroke Color").setValue(this.color);
				stroke("ADBE Vector Stroke Width").setValue(2);
				group("ADBE Vector Transform Group")("ADBE Vector Rotation").setValue(-60);
			}

			if (this.eye)
			{
				var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
				group.name = "Eye";
				var groupContent = group.property("ADBE Vectors Group");

				var eyeGroup = groupContent.addProperty("ADBE Vector Group");
				eyeGroup.name = "eye";
				var eyeGroupContent = eyeGroup.property("ADBE Vectors Group");
				var eye = eyeGroupContent.addProperty("ADBE Vector Shape - Group");
				var eyeShape = new Shape();
				eyeShape.vertices = [[-12,0], [12,0]];
				eyeShape.inTangents = [[0,0], [-12,12]];
				eyeShape.outTangents = [[0,0], [-12,-12]];
				eyeShape.closed = true;
				eye("ADBE Vector Shape").setValue(eyeShape);
				eye("ADBE Vector Shape").expression = "value";
				var pupil = eyeGroupContent.addProperty("ADBE Vector Shape - Ellipse");
				pupil("ADBE Vector Ellipse Size").setValue([7,7]);
				var fill = eyeGroupContent.addProperty("ADBE Vector Graphic - Fill");
				fill("ADBE Vector Fill Color").setValue(this.color);

				var xGroup = groupContent.addProperty("ADBE Vector Group");
				xGroup.name = "xPosition";
				var xGroupContent = xGroup.property("ADBE Vectors Group");
				var arrowShape1 = new Shape();
				arrowShape1.vertices = [[10,-7],[15,0], [10,7]];
				arrowShape1.closed = false;
				var arrow1 = xGroupContent.addProperty("ADBE Vector Shape - Group");
				arrow1("ADBE Vector Shape").setValue(arrowShape1);
				arrow1("ADBE Vector Shape").expression = "value";
				var arrowShape2 = new Shape();
				arrowShape2.vertices = [[-10,7],[-15,0], [-10,-7]];
				arrowShape2.closed = false;
				var arrow2 = xGroupContent.addProperty("ADBE Vector Shape - Group");
				arrow2("ADBE Vector Shape").setValue(arrowShape2);
				arrow2("ADBE Vector Shape").expression = "value";
				var stroke = xGroupContent.addProperty("ADBE Vector Graphic - Stroke");
				stroke("ADBE Vector Stroke Color").setValue(this.color);
				stroke("ADBE Vector Stroke Width").setValue(2);

				var yGroup = groupContent.addProperty("ADBE Vector Group");
				yGroup.name = "yPosition";
				var yGroupContent = yGroup.property("ADBE Vectors Group");
				var arrowShape3 = new Shape();
				arrowShape3.vertices = [[-7,10],[0,15], [7,10]];
				arrowShape3.closed = false;
				var arrow3 = yGroupContent.addProperty("ADBE Vector Shape - Group");
				arrow3("ADBE Vector Shape").setValue(arrowShape3);
				arrow3("ADBE Vector Shape").expression = "value";
				var arrowShape4 = new Shape();
				arrowShape4.vertices = [[-7,-10],[0,-15], [7,-10]];
				arrowShape4.closed = false;
				var arrow4 = yGroupContent.addProperty("ADBE Vector Shape - Group");
				arrow4("ADBE Vector Shape").setValue(arrowShape4);
				arrow4("ADBE Vector Shape").expression = "value";
				var stroke = yGroupContent.addProperty("ADBE Vector Graphic - Stroke");
				stroke("ADBE Vector Stroke Color").setValue(this.color);
				stroke("ADBE Vector Stroke Width").setValue(2);

			}

			if (this.camera)
			{
				var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
				group.name = "Camera";
				var groupContent = group.property("ADBE Vectors Group");

				var cam = groupContent.addProperty("ADBE Vector Shape - Group");
				var camShape = new Shape();
				camShape.vertices = [[-15,-7], [-5,-3], [-5,-7], [15,-7], [15,7], [-5,7], [-5,3], [-15,7]];
				camShape.closed = true;
				cam("ADBE Vector Shape").setValue(camShape);
				cam("ADBE Vector Shape").expression = "value";
				var reel1 = groupContent.addProperty("ADBE Vector Shape - Ellipse");
				reel1("ADBE Vector Ellipse Size").setValue([15,15]);
				reel1("ADBE Vector Ellipse Position").setValue([12,-10]);
				var reel2 = groupContent.addProperty("ADBE Vector Shape - Ellipse");
				reel2("ADBE Vector Ellipse Size").setValue([10,10]);
				reel2("ADBE Vector Ellipse Position").setValue([-2,-10]);
				var fill = groupContent.addProperty("ADBE Vector Graphic - Fill");
				fill("ADBE Vector Fill Color").setValue(this.color);
			}
		}

		function TVPCamera ()
		{
			this.points = [];
			this.pointCout = 0;
			this.profileprof = new TVPProfileprof();
		}

		function TVPCameraPoint ()
		{
			this.x = 0.0;
			this.y = 0.0;
			this.zoom = 1.0;
			this.rotation = 0.0;
		}

		function TVPProfileprof ()
		{
			this.points = [];
			this.linear = false;
			this.pointCount = 0;
		}

		function TVPProfileprofPoint ()
		{
			this.u = 0.0;
			this.v = 0.0;
		}

		TVPCamera.prototype.createNull = function(comp,link,useAnchorPoint)
		{
			var camLayer = comp.layers.addNull();
			camLayer.name = "TVPaint Camera";
			this.applyToLayer(camLayer,link,useAnchorPoint);
		}

		TVPCamera.prototype.precompose = function(comp,useAnchorPoint)
		{
			var tvpComp = app.project.items.addComp("TVPaint Camera",comp.width, comp.height, comp.pixelAspect, comp.duration, comp.frameRate)
			var camLayer = tvpComp.layers.add(comp);
			this.applyToLayer(camLayer,false,useAnchorPoint);
		}

		TVPCamera.prototype.applyToLayer = function(camLayer,link,useAnchorPoint)
		{
			var comp = camLayer.containingComp;
			var numPoints = this.pointCount;

			if (link == undefined) link = false;
			if (useAnchorPoint == undefined) useAnchorPoint = false;

			var moveProp = camLayer.transform.anchorPoint;
			var rotationLayer = camLayer;

			// Move
			if (!useAnchorPoint)
			{
			moveProp = camLayer.transform.position;
			rotationLayer = camLayer.containingComp.layers.addNull();
			rotationLayer.name = "TVPaint Rotation & Scale";
			}
			var startPos = camLayer.transform.position.value;
			var intialDif = [0,0];
			for (var i = 0;i< numPoints;i++)
			{
			var point = this.points[i];
			var time = (comp.duration-comp.frameDuration)/(numPoints-1)*i;

			if (i == 0) initialDif = startPos - [point.x,point.y];
			var val;
			useAnchorPoint ? val = [point.x,point.y] : val = 2*startPos-[point.x,point.y]-initialDif;

			moveProp.setValueAtTime(time,val);

			if (i == 0 || i == numPoints-1)
			{
			moveProp.setSpatialTangentsAtKey(i+1,[0,0,0],[0,0,0]);
			}
			else
			{
			moveProp.setSpatialAutoBezierAtKey(i+1,true);
			var inTangent = moveProp.keyInSpatialTangent(i+1);
			var outTangent = moveProp.keyOutSpatialTangent(i+1);
			}
			}

			//rotation & scale
			for (var i =0; i < numPoints;i++)
			{
			var point = this.points[i];
			moveProp.setRovingAtKey(i+1,true);
			time = moveProp.keyTime(i+1);
			rotationLayer.transform.rotation.setValueAtTime(time,point.rotation);
			var zoom = (1+(1-point.zoom))*100;
			rotationLayer.transform.scale.setValueAtTime(time,[zoom,zoom,zoom]);
			}

			//Morpher
			var morpher = camLayer.Effects.addProperty("ADBE Slider Control");
			morpher.name = "Morpher";

			var exp = "valueAtTime((thisComp.layer(\"" + camLayer.name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
			moveProp.expression = exp;
			rotationLayer.transform.rotation.expression = exp;
			rotationLayer.transform.scale.expression = exp;

			//add morpher keys
			var numProfPoints = this.profileprof.pointCount;
			for (var i = 0;i<numProfPoints;i++)
			{
			var point = this.profileprof.points[i];
			morpher(1).setValueAtTime((comp.duration-comp.frameDuration)*point.u,(comp.duration-comp.frameDuration)/comp.frameDuration*point.v);
			}
			//bezier
			if (!this.profileprof.linear)
			{
			for (var i = 1;i<= morpher(1).numKeys;i++)
			{
			morpher(1).setInterpolationTypeAtKey(i,KeyframeInterpolationType.BEZIER);
			if (i != 1 && i != morpher(1).numKeys)
			{
			morpher(1).setTemporalContinuousAtKey(i, true);
			morpher(1).setTemporalAutoBezierAtKey(i, true);
			}
			else
			{
			var easeIn = new KeyframeEase(0,100/3);
			morpher(1).setTemporalEaseAtKey(i,[easeIn]);
			}
			}
			}

			if (!useAnchorPoint) camLayer.parent = rotationLayer;

			if (link)
			{
			for (var i = 1;i<=comp.numLayers;i++)
			{
			if (i == camLayer.index || i == rotationLayer.index) continue;
			if (comp.layer(i).parent == null) comp.layer(i).parent = camLayer;
			}
			}
		}

		function OnionSkin()
		{
			this.activated = false;
			this.duration = 5;
			this.inOpacity = 0;
			this.outOpacity = 50;
			this.exposure = 2;
		}
	}

	/**
	 * Constructs a new instance of LibDuik
	 * @class LibDuik
	 * @classdesc The LibDuik framework
	 * TODO Documentation of the properties
	 */
	function LibDuik()
	{

		// Attributes and initilization
		{
			this.version = duikUpdate.version;
			this.majorVersion = duikUpdate.majorVersion;
			this.minorVersion = duikUpdate.minorVersion;
			this.build = duikUpdate.build;

			//detect OS Version
			var mac = $.os.toLowerCase().indexOf("mac") >= 0;
			this.mac = mac;
			this.win = !mac;

			//detect AE Version
			var reV = /^(\d+\.?\d*)/i;
			var v = app.version.match(reV);
			this.aeVersion = parseFloat(v[1]);
			delete reV;
			delete v;

			this.usePresets = true;

			//issue #295 - this is not needed right now
			//this.presetPath = $.fileName.substring(0,$.fileName.lastIndexOf("/")) + "/";
			//this.presetEffectsInstalledVersion = 0.0;

			this.copiedAnim = [];

			this.detectedExposure = [];

			this.sizes = {};
			this.sizes.SMALL = 0;
			this.sizes.MEDIUM = 1;
			this.sizes.BIG = 2;

			this.layerTypes = {};
			this.layerTypes.VECTOR = 2;
			this.layerTypes.NULL = 1;
			this.layerTypes.SOLID = 0;

			this.getLayers = {};
			this.getLayers.INDEX = 0;
			this.getLayers.NAME = 1;
			this.getLayers.SELECTION_INDEX = 2;

			this.placement = {};
			this.placement.TOP = 0;
			this.placement.BOTTOM = 1;
			this.placement.OVER_LAYER = 2;
			this.placement.UNDER_LAYER = 3;

			this.colors = {};
			this.colors.WHITE = [1,1,1,1];
			this.colors.RED = [1,0,0,1];
			this.colors.RAINBOXRED = [.925,.094,.094,1];
			this.colors.GREEN = [0,1,0,1];
			this.colors.BLUE = [0,0,1,1];
			this.colors.CYAN = [0,1,1,1];
			this.colors.MAGENTA = [1,0,1,1];
			this.colors.YELLOW = [1,1,0,1];
			this.colors.BLACK = [0,0,0,1];
			this.colors.LIGHT_GRAY = [0.7,0.7,0.7,1];
			this.colors.DARK_GRAY = [0.25,0.25,0.25,1];

			this.effects = {};
			this.effects.One_Layer_IK = 'PSEUDO/DUIK_One_Layer_IK';
			this.effects.One_Layer_IK.ffx = 'DUIK_One_Layer_IK';
			this.effects.Two_Layer_IK = 'PSEUDO/DUIK_Two_Layer_IK_v2';
			this.effects.Two_Layer_IK.ffx = 'DUIK_Two_Layer_IK_v2';
			this.effects.Three_Layer_IK = 'PSEUDO/DUIK_Three_Layer_IK_v2';
			this.effects.Three_Layer_IK.ffx = 'DUIK_Three_Layer_IK_v2';
			this.effects.ThreeD_Wiggle = 'PSEUDO/DUIK_3D_Wiggle';
			this.effects.ThreeD_Wiggle.ffx = 'DUIK_3D_Wiggle';
			this.effects.TwoD_Wiggle = 'PSEUDO/DUIK_2D_Wiggle';
			this.effects.TwoD_Wiggle.ffx = 'DUIK_2D_Wiggle';
			this.effects.OneD_Wiggle = 'PSEUDO/DUIK_1D_Wiggle';
			this.effects.OneD_Wiggle.ffx = 'DUIK_1D_Wiggle';
			this.effects.Exposure = 'PSEUDO/DUIK_Exposure';
			this.effects.Exposure.ffx = 'DUIK_Exposure';
			this.effects.RotMorph = 'PSEUDO/DUIK_RotMorph';
			this.effects.RotMorph.ffx = 'DUIK_RotMorph';
			this.effects.Swing = 'PSEUDO/DUIK_Swing';
			this.effects.Swing.ffx = 'DUIK_Swing';
			this.effects.Wheel = 'PSEUDO/DUIK_Wheel';
			this.effects.Wheel.ffx = 'DUIK_Wheel';
			this.effects.LensFlare = 'PSEUDO/DUIK_LensFlare';
			this.effects.LensFlare.ffx = 'DUIK_LensFlare';
			this.effects.LensFlareDistance = 'PSEUDO/DUIK_LensFlareDistance';
			this.effects.LensFlareDistance.ffx = 'DUIK_LensFlareDistance';
			this.effects.DistanceLink = 'PSEUDO/DUIK_DistanceLink';
			this.effects.DistanceLink.ffx = 'DUIK_DistanceLink';
			this.effects.Spring = 'PSEUDO/DUIK_Spring';
			this.effects.Spring.ffx = 'DUIK_Spring';
			this.effects.Spring_Bounce = 'PSEUDO/DUIK_Spring_Bounce';
			this.effects.Spring_Bounce.ffx = 'DUIK_Spring_Bounce';
			this.effects.Paint_Rig = 'PSEUDO/DUIK_Paint_Rig';
			this.effects.Paint_Rig.ffx = 'DUIK_Paint_Rig';
			this.effects.Blink_1D = 'PSEUDO/DUIK_Blink_1D';
			this.effects.Blink_1D.ffx = 'DUIK_Blink_1D';
			this.effects.Blink_2D = 'PSEUDO/DUIK_Blink_2D';
			this.effects.Blink_2D.ffx = 'DUIK_Blink_2D';
			this.effects.Blink_3D = 'PSEUDO/DUIK_Blink_3D';
			this.effects.Blink_3D.ffx = 'DUIK_Blink_3D';
			this.effects.Multiplane = 'PSEUDO/DUIK_Multiplane';
			this.effects.Multiplane.ffx = 'DUIK_Multiplane';
			this.effects.Paint_Group = 'PSEUDO/DUIK_Paint_Group';
			this.effects.Paint_Group.ffx = 'DUIK_Paint_Group';
			this.effects.OneD_List = 'PSEUDO/DUIK_1D_List';
			this.effects.OneD_List.ffx = 'DUIK_1D_List';
			this.effects.TwoD_List = 'PSEUDO/DUIK_2D_List';
			this.effects.TwoD_List.ffx = 'DUIK_2D_List';
			this.effects.ThreeD_List = 'PSEUDO/DUIK_3D_List';
			this.effects.ThreeD_List.ffx = 'DUIK_3D_List';
			this.effects.Bezier_IK = 'PSEUDO/DUIK_Bezier_IK';
			this.effects.Bezier_IK.ffx = 'DUIK_Bezier_IK';
			this.effects.Foot_Roll = 'PSEUDO/DUIK_Foot_Roll';
			this.effects.Foot_Roll.ffx = 'DUIK_Foot_Roll';

			this.expressions = {};
			// Associative array that converts property match names to their compact English expression statements.
			// For simple conversions, quote the result!
			this.expressions.compactExpressions = {
				"ADBE Transform Group":"'transform'",
				// Handle camera/light vs. AV layers
				"ADBE Anchor Point":"((prop.propertyGroup(prop.propertyDepth).property('intensity')!=null) || (prop.propertyGroup(prop.propertyDepth).property('zoom')!=null)) ? '.pointOfInterest' : '.anchorPoint'",
				"ADBE Position":"'.position'",
				"ADBE Scale":"'.scale'",
				"ADBE Orientation":"'.orientation'",
				"ADBE Rotate X":"'.xRotation'",
				"ADBE Rotate Y":"'.yRotation'",
				// Handle 3D vs. 2D layers
				"ADBE Rotate Z":"(prop.propertyGroup(prop.propertyDepth).threeDLayer || (prop.propertyGroup(prop.propertyDepth).property('intensity')!=null) || (prop.propertyGroup(prop.propertyDepth).property('zoom')!=null)) ? '.zRotation' : '.rotation'",
				"ADBE Opacity":"'.opacity'",
				"ADBE Material Options Group":"'materialOption'",
				"ADBE Casts Shadows":"'.castsShadows'",
				"ADBE Light Transmission":"'.lightTransmission'",
				"ADBE Accepts Shadows":"'.acceptsShadows'",
				"ADBE Accepts Lights":"'.acceptsLights'",
				"ADBE Ambient Coefficient":"'.ambient'",
				"ADBE Diffuse Coefficient":"'.diffuse'",
				"ADBE Specular Coefficient":"'.specular'",
				"ADBE Shininess Coefficient":"'.shininess'",
				"ADBE Metal Coefficient":"'.metal'",
				"ADBE Light Options Group":"'lightOption'",
				"ADBE Light Intensity":"'.intensity'",
				"ADBE Light Color":"'.color'",
				"ADBE Light Cone Angle":"'.coneAngle'",
				"ADBE Light Cone Feather 2":"'.coneFeather'",
				"ADBE Light Shadow Darkness":"'.shadowDarkness'",
				"ADBE Light Shadow Diffusion":"'.shadowDiffusion'",
				"ADBE Camera Options Group":"'cameraOption'",
				"ADBE Camera Zoom":"'.zoom'",
				"ADBE Camera Depth of Field":"'.depthOfField'",
				"ADBE Camera Focus Distance":"'.focusDistance'",
				"ADBE Camera Aperture":"'.aperture'",
				"ADBE Camera Blur Level":"'.blurLevel'",
				"ADBE Text Properties":"'text'",
				"ADBE Text Document":"'.sourceText'",
				"ADBE Text Path Options":"'.pathOption'",
				"ADBE Text Path":"'.path'",
				"ADBE Text Reverse Path":"'.reversePath'",
				"ADBE Text Perpendicular To Path":"'.perpendicularToPath'",
				"ADBE Text Force Align Path":"'.forceAlignment'",
				"ADBE Text First Margin":"'.firstMargin'",
				"ADBE Text Last Margin":"'.lastMargin'",
				"ADBE Text More Options":"'.moreOption'",
				"ADBE Text Anchor Point Option":"'.anchorPointGrouping'",
				"ADBE Text Anchor Point Align":"'.groupingAlignment'",
				"ADBE Text Render Order":"'.fillANdStroke'",
				"ADBE Text Character Blend Mode":"'.interCharacterBlending'",
				"ADBE Text Animators":"'.animator'",
				"ADBE Text Selectors":"'.selector'",
				"ADBE Text Percent Start":"'.start'",
				"ADBE Text Percent End":"'.end'",
				"ADBE Text Percent Offset":"'.offset'",
				"ADBE Text Index Start":"'.start'",
				"ADBE Text Index End":"'.end'",
				"ADBE Text Index Offset":"'.offset'",
				"ADBE Text Range Advanced":"'.advanced'",
				"ADBE Text Range Units":"'.units'",
				"ADBE Text Range Type2":"'.basedOn'",
				"ADBE Text Selector Mode":"'.mode'",
				"ADBE Text Selector Max Amount":"'.amount'",
				"ADBE Text Range Shape":"'.shape'",
				"ADBE Text Selector Smoothness":"'.smoothness'",
				"ADBE Text Levels Max Ease":"'.easeHigh'",
				"ADBE Text Levels Min Ease":"'.easeLow'",
				"ADBE Text Randomize Order":"'.randomizeOrder'",
				"ADBE Text Random Seed":"'.randomSeed'",
				"ADBE Text Selector Mode":"'.mode'",
				"ADBE Text Wiggly Max Amount":"'.maxAmount'",
				"ADBE Text Wiggly Min Amount":"'.minAmount'",
				"ADBE Text Range Type2":"'.basedOn'",
				"ADBE Text Temporal Freq":"'.wigglesSecond'",
				"ADBE Text Character Correlation":"'.correlation'",
				"ADBE Text Temporal Phase":"'.temporalPhase'",
				"ADBE Text Spatial Phase":"'.spatialPhase'",
				"ADBE Text Wiggly Lock Dim":"'.lockDimensions'",
				"ADBE Text Wiggly Random Seed":"'.randomSeed'",
				"ADBE Text Range Type2":"'.basedOn'",
				"ADBE Text Expressible Amount":"'.amount'",
				"ADBE Text Animator Properties":"'.property'",
				"ADBE Text Anchor Point 3D":"'.anchorPoint'",
				"ADBE Text Position 3D":"'.position'",
				"ADBE Text Scale 3D":"'.scale'",
				"ADBE Text Skew":"'.skew'",
				"ADBE Text Skew Axis":"'.skewAxis'",
				"ADBE Text Rotation X":"'.xRotation'",
				"ADBE Text Rotation Y":"'.yRotation'",
				"ADBE Text Rotation":"'.zRotation'",
				"ADBE Text Opacity":"'.opacity'",
				"ADBE Text Fill Opacity":"'.fillOpacity'",
				"ADBE Text Fill Color":"'.fillColor'",
				"ADBE Text Fill Hue":"'.fillHue'",
				"ADBE Text Fill Saturation":"'.fillSaturation'",
				"ADBE Text Fill Brightness":"'.fillBrightness'",
				"ADBE Text Stroke Opacity":"'.strokeOpacity'",
				"ADBE Text Stroke Color":"'.strokeColor'",
				"ADBE Text Stroke Hue":"'.strokeHue'",
				"ADBE Text Stroke Saturation":"'.strokeSaturation'",
				"ADBE Text Stroke Brightness":"'.strokeBrightness'",
				"ADBE Text Stroke Width":"'.strokeWidth'",
				"ADBE Text Line Anchor":"'.lineAnchor'",
				"ADBE Text Line Spacing":"'.lineSpacing'",
				"ADBE Text Track Type":"'.trackingType'",
				"ADBE Text Tracking Amount":"'.trackingAmount'",
				"ADBE Text Character Change Type":"'.characterAlignment'",
				"ADBE Text Character Range":"'.characterRange'",
				"ADBE Text Character Replace":"'.characterValue'",
				"ADBE Text Character Offset":"'.characterOffset'",
				"ADBE Text Blur":"'.blur'",
				"ADBE Mask Parade":"'mask'",
				"ADBE Mask Shape":"'.maskPath'",
				"ADBE Mask Feather":"'.maskFeather'",
				"ADBE Mask Opacity":"'.maskOpacity'",
				"ADBE Mask Offset":"'.maskExpansion'",
				"ADBE Effect Parade":"'effect'",
				"ADBE Paint Group":"'.stroke'",
				"ADBE Paint Shape":"'.path'",
				"ADBE Paint Properties":"'.strokeOption'",
				"ADBE Paint Begin":"'.start'",
				"ADBE Paint End":"'.end'",
				"ADBE Paint Color":"'.color'",
				"ADBE Paint Diameter":"'.diameter'",
				"ADBE Paint Angle":"'.angle'",
				"ADBE Paint Hardness":"'.hardness'",
				"ADBE Paint Roundness":"'.roundness'",
				"ADBE Paint Tip Spacing":"'.spacing'",
				"ADBE Paint Target Channels":"'.channels'",
				"ADBE Paint Opacity":"'.opacity'",
				"ADBE Paint Flow":"'.flow'",
				"ADBE Paint Clone Layer":"'.cloneSource'",
				"ADBE Paint Clone Position":"'.clonePosition'",
				"ADBE Paint Clone Time":"'.cloneTime'",
				"ADBE Paint Clone Time Shift":"'.cloneTimeShift'",
				"ADBE Paint Transform":"'.transform'",
				"ADBE Paint Anchor Point":"'.anchorPoint'",
				"ADBE Paint Position":"'.position'",
				"ADBE Paint Scale":"'.scale'",
				"ADBE Paint Rotation":"'.rotation'",
				"ADBE MTrackers":"'motionTracker'",
				"ADBE MTracker Pt Feature Center":"'.featureCenter'",
				"ADBE MTracker Pt Feature Size":"'.featureSize'",
				"ADBE MTracker Pt Search Ofst":"'.searchOffset'",
				"ADBE MTracker Pt Search Size":"'.searchSize'",
				"ADBE MTracker Pt Confidence":"'.confidence'",
				"ADBE MTracker Pt Attach Pt":"'.attachPoint'",
				"ADBE MTracker Pt Attach Pt Ofst":"'.attachPointOffset'",
				"ADBE Audio Group":"'audio'",
				"ADBE Audio Levels":"'.audioLevels'",
				"ADBE Time Remapping":"'timeRemap'",
				"ADBE Layer Styles":"'layerStyle'",
				"ADBE Blend Options Group":"'.blendingOption'",
					"ADBE Global Angle2":"'.globalLightAngle'",
					"ADBE Global Altitude2":"'.globalLightAltitude'",
					"ADBE Adv Blend Group":"'.advancedBlending'",
					"ADBE Layer Fill Opacity2":"'.fillOpacity'",
					"ADBE R Channel Blend":"'.red'",
					"ADBE G Channel Blend":"'.green'",
					"ADBE B Channel Blend":"'.blue'",
					"ADBE Blend Interior":"'.blendInteriorStylesAsGroup'",
					"ADBE Blend Ranges":"'.useBlendRangesFromSource'",
				"dropShadow/enabled":"'.dropShadow'",
					"dropShadow/mode2":"'.blendMode'",
					"dropShadow/color":"'.color'",
					"dropShadow/opacity":"'.opacity'",
					"dropShadow/useGlobalAngle":"'.useGlobalLight'",
					"dropShadow/localLightingAngle":"'.angle'",
					"dropShadow/distance":"'.distance'",
					"dropShadow/chokeMatte":"'.spread'",
					"dropShadow/blur":"'.size'",
					"dropShadow/noise":"'.noise'",
					"dropShadow/layerConceals":"'.layerKnocksOutDropShadow'",
				"innerShadow/enabled":"'.innerShadow'",
					"innerShadow/mode2":"'.blendMode'",
					"innerShadow/color":"'.color'",
					"innerShadow/opacity":"'.opacity'",
					"innerShadow/useGlobalAngle":"'.useGlobalLight'",
					"innerShadow/localLightingAngle":"'.angle'",
					"innerShadow/distance":"'.distance'",
					"innerShadow/chokeMatte":"'.choke'",
					"innerShadow/blur":"'.size'",
					"innerShadow/noise":"'.noise'",
				"outerGlow/enabled":"'.outerGlow'",
					"outerGlow/mode2":"'.blendMode'",
					"outerGlow/opacity":"'.opacity'",
					"outerGlow/noise":"'.noise'",
					"outerGlow/AEColorChoice":"'.colorType'",
					"outerGlow/color":"'.color'",
					"outerGlow/gradientSmoothness":"'.gradientSmoothness'",
					"outerGlow/glowTechnique":"'.technique'",
					"outerGlow/chokeMatte":"'.spread'",
					"outerGlow/blur":"'.size'",
					"outerGlow/inputRange":"'.range'",
					"outerGlow/shadingNoise":"'.jitter'",
				"innerGlow/enabled":"'.innerGlow'",
					"innerGlow/mode2":"'.blendMode'",
					"innerGlow/opacity":"'.opacity'",
					"innerGlow/noise":"'.noise'",
					"innerGlow/AEColorChoice":"'.colorType'",
					"innerGlow/color":"'.color'",
					"innerGlow/gradientSmoothness":"'.gradientSmoothness'",
					"innerGlow/glowTechnique":"'.technique'",
					"innerGlow/innerGlowSource":"'.source'",
					"innerGlow/chokeMatte":"'.choke'",
					"innerGlow/blur":"'.size'",
					"innerGlow/inputRange":"'.range'",
					"innerGlow/shadingNoise":"'.jitter'",
				"bevelEmboss/enabled":"'.bevelAndEmboss'",
					"bevelEmboss/bevelStyle":"'.style'",
					"bevelEmboss/bevelTechnique":"'.technique'",
					"bevelEmboss/strengthRatio":"'.depth'",
					"bevelEmboss/bevelDirection":"'.direction'",
					"bevelEmboss/blur":"'.size'",
					"bevelEmboss/softness":"'.soften'",
					"bevelEmboss/useGlobalAngle":"'.useGlobalLight'",
					"bevelEmboss/localLightingAngle":"'.angle'",
					"bevelEmboss/localLightingAltitude":"'.altitude'",
					"bevelEmboss/highlightMode":"'.highlightMode'",
					"bevelEmboss/highlightColor":"'.highlightColor'",
					"bevelEmboss/highlightOpacity":"'.highlightOpacity'",
					"bevelEmboss/shadowMode":"'.shadowMode'",
					"bevelEmboss/shadowColor":"'.shadowColor'",
					"bevelEmboss/shadowOpacity":"'.shadowOpacity'",
				"chromeFX/enabled":"'.satin'",
					"chromeFX/mode2":"'.blendMode'",
					"chromeFX/color":"'.color'",
					"chromeFX/opacity":"'.opacity'",
					"chromeFX/localLightingAngle":"'.angle'",
					"chromeFX/distance":"'.distance'",
					"chromeFX/blur":"'.size'",
					"chromeFX/invert":"'.invert'",
				"solidFill/enabled":"'.colorOverlay'",
					"solidFill/mode2":"'.blendMode'",
					"solidFill/color":"'.color'",
					"solidFill/opacity":"'.opacity'",
				"gradientFill/enabled":"'.gradientOverlay'",
					"gradientFill/mode2":"'.blendMode'",
					"gradientFill/opacity":"'.opacity'",
					"gradientFill/gradientSmoothness":"'.gradientSmoothness'",
					"gradientFill/angle":"'.angle'",
					"gradientFill/type":"'.style'",
					"gradientFill/reverse":"'.reverse'",
					"gradientFill/align":"'.alignWithLayer'",
					"gradientFill/scale":"'.scale'",
					"gradientFill/offset":"'.offset'",
				"patternFill/enabled":"'.patternOverlay'",
					"patternFill/mode2":"'.blendMode'",
					"patternFill/opacity":"'.opacity'",
					"patternFill/align":"'.linkWithLayer'",
					"patternFill/scale":"'.scale'",
					"patternFill/phase":"'.offset'",
				"frameFX/enabled":"'.stroke'",
					"frameFX/mode2":"'.blendMode'",
					"frameFX/color":"'.color'",
					"frameFX/size":"'.size'",
					"frameFX/opacity":"'.opacity'",
					"frameFX/style":"'.position'",
			};

			this.uiStrings = {};
			this.uiStrings.ik = "IK";
			this.uiStrings.ikDirection = "IK Direction";
			this.uiStrings.ikLimit = "IK Limit"
			this.uiStrings.ikEnd = "IK End";
			this.uiStrings.wiggle = "Wiggle";
			this.uiStrings.exposure = "Exposure";
			this.uiStrings.rotMorph = "Rotation Morph";
			this.uiStrings.swing = "Swing";
			this.uiStrings.wheel = "Wheel";
			this.uiStrings.lensFlare = "Lens Flare";
			this.uiStrings.distanceLink = "Distance Link";
			this.uiStrings.spring = "Spring";
			this.uiStrings.paintRig = "Paint Rig";
			this.uiStrings.paintGroup = "Paint Group";
			this.uiStrings.blink = "Blink";
			this.uiStrings.scale = "Scale";
			this.uiStrings.flip = "Flip";
			this.uiStrings.moveAway = "Distance from parent";
			this.uiStrings.multiplane = "Multiplane";
			this.uiStrings.camInfluence = "Camera Influence";
			this.uiStrings.morpher = "Morpher";
			this.uiStrings.list = "List";
			this.uiStrings.bezierIKOffset = "Bezier IK Offset";
			this.uiStrings.bezierIK = "Bezier IK";
			this.uiStrings.controllers = "Controllers";
			this.uiStrings.bones = "Bones";
			this.uiStrings.zeroes = "Zeroes";
		}

		// SETTINGS
		{
			/**
			 * Constructs a new Settings Class
			 * @class Settings
			 * @memberof LibDuik
			 * @classdesc Manages the settings of Duik
			 */
			function Settings()
			{
				function createAESetting(name,value)
				{
					if (! app.settings.haveSetting('duik', name)){app.settings.saveSetting('duik',name,value);}
				}
				createAESetting("boneType",Duik.layerTypes.SOLID);
				createAESetting("controllerType",Duik.layerTypes.VECTOR);
				createAESetting("boneSize",20);
				createAESetting("ctrlSize",100);
				createAESetting("ctrlSizeAuto",true);
				createAESetting("boneSizeAuto",true);
				createAESetting("boneSizeAutoValue",Duik.sizes.MEDIUM);
				createAESetting("ctrlSizeAutoValue",Duik.sizes.MEDIUM);
				createAESetting("boneColor","FF0000");
				createAESetting("morpherKeyframes",true);
				createAESetting("getLayersMethod",Duik.getLayers.NAME);
				createAESetting("bonePlacement",Duik.placement.OVER_LAYER);
				createAESetting("ctrlPlacement",Duik.placement.TOP);
				createAESetting("controllerColor",Duik.colors.WHITE.toSource());
				createAESetting("lockAndShy",false);
			}

			Settings.prototype.save = function ()
			{
				app.settings.saveSetting("duik","boneType",this.boneType);
				app.settings.saveSetting("duik","controllerType",this.controllerType);
				app.settings.saveSetting("duik","boneSize",this.boneSize);
				app.settings.saveSetting("duik","ctrlSize",this.controllerSize);
				app.settings.saveSetting("duik","ctrlSizeAuto",this.controllerSizeAuto);
				app.settings.saveSetting("duik","boneSizeAuto",this.boneSizeAuto);
				app.settings.saveSetting("duik","boneSizeAutoValue",this.boneSizeHint);
				app.settings.saveSetting("duik","ctrlSizeAutoValue",this.controllerSizeHint);
				app.settings.saveSetting("duik","boneColor",this.boneColor);
				app.settings.saveSetting("duik","morpherKey",this.morpherCreatesKeyframes);
				app.settings.saveSetting("duik","getLayersMethod",this.getLayersMethod);
				app.settings.saveSetting("duik","bonePlacement",this.bonePlacement);
				app.settings.saveSetting("duik","ctrlPlacement",this.ctrlPlacement);
				app.settings.saveSetting("duik","displayProgressPanel",this.displayProgressPanel);
				app.settings.saveSetting("duik","controllerColor",this.controllerColor.toSource());
				app.settings.saveSetting("duik","lockAndShy",this.lockAndShy);
			}

			Settings.prototype.load = function ()
			{
				this.controllerSize = eval(app.settings.getSetting("duik","ctrlSize"));
				this.controllerType = eval(app.settings.getSetting("duik","controllerType"));
				this.controllerSizeAuto = eval(app.settings.getSetting("duik","ctrlSizeAuto"));
				this.controllerSizeHint = eval(app.settings.getSetting("duik","ctrlSizeAutoValue"));
				this.boneType = eval(app.settings.getSetting("duik","boneType"));
				this.boneSize = eval(app.settings.getSetting("duik","boneSize"));
				this.boneSizeAuto = eval(app.settings.getSetting("duik","boneSizeAuto"));
				this.boneSizeHint = eval(app.settings.getSetting("duik","boneSizeAutoValue"));
				this.boneColor = app.settings.getSetting("duik","boneColor");
				this.morpherCreatesKeyframes = eval(app.settings.getSetting("duik","morpherKeyframes"));
				this.getLayersMethod = eval(app.settings.getSetting("duik","getLayersMethod"));
				this.bonePlacement = eval(app.settings.getSetting("duik","bonePlacement"));
				this.ctrlPlacement = eval(app.settings.getSetting("duik","ctrlPlacement"));
				this.displayProgressPanel = eval(app.settings.getSetting("duik","displayProgressPanel"));
				this.controllerColor = eval(app.settings.getSetting("duik","controllerColor"));
				this.lockAndShy = eval(app.settings.getSetting("duik","lockAndShy"));
			}

			Settings.prototype.restoreDefaults = function ()
			{
				this.controllerSize = 100;
				this.controllerType = Duik.layerTypes.VECTOR;
				this.controllerSizeAuto = true;
				this.controllerSizeHint = Duik.sizes.MEDIUM;
				this.boneType = Duik.layerTypes.SOLID;
				this.boneSize = 20;
				this.boneSizeAuto = true;
				this.boneSizeHint = Duik.sizes.MEDIUM;
				this.boneColor = "FF0000";
				this.morpherCreatesKeyframes = true;
				this.getLayersMethod = Duik.getLayers.NAME;
				this.bonePlacement = Duik.placement.OVER_LAYER;
				this.ctrlPlacement = Duik.placement.TOP;
				this.displayProgressPanel = true;
				this.controllerColor = Duik.colors.WHITE;
				this.lockAndShy = false;

				this.save();
			}

			this.settings = new Settings();
			this.settings.load();
		}

		// UI
		{
			/**
			 * Constructs a new UI Class
			 * @class UI
			 * @memberof LibDuik
			 * @classdesc Tools to work with After Effects ScriptUI framework
			 */
			function DuikUI(){};

			DuikUI.prototype.updateProgressPanel = function (val,status)
			{
				var currentDate = new Date();
				var timeElapsed = currentDate.getTime() - Duik.ui.progressStartTime.getTime();
				var iTime = timeElapsed/val;

				var remainingIterations = Duik.ui.progressBar.maxvalue-val;
				var remainingTime = iTime*remainingIterations;
				var remainingSeconds = parseInt(remainingTime/1000);
				var minutes = parseInt(remainingSeconds/60);
				var seconds = remainingSeconds - minutes*60;
				if (minutes == 0) minutes = "00";
				else if (minutes < 10) minutes = "0" + minutes;
				if (seconds == 0) seconds = "00";
				else if (seconds < 10) seconds = "0" + seconds;

				Duik.ui.etr.text = minutes + ":" + seconds + " remaining";

				Duik.ui.progressBar.value = val;
				if (status != undefined) Duik.ui.progressStatus.text = status;
				if (Duik.aeVersion > 9) Duik.ui.progressPanel.update();
			};

			DuikUI.prototype.showProgressPanel = function (maxVal,status)
			{
				Duik.ui.progressStartTime = new Date();
				Duik.ui.progressBar.maxvalue = maxVal;
				Duik.ui.progressBar.value = 0;
				Duik.ui.progressStatus.text = status;
				Duik.ui.progressPanel.show();
				if (Duik.aeVersion > 9) Duik.ui.progressPanel.update();
			};

			DuikUI.prototype.hideProgressPanel = function ()
			{
				Duik.ui.progressIterationDuration = 0;
				Duik.ui.progressPanel.hide();
			};
			/**
			 * Changes the color of the text of a ScriptUI Object
			 * @memberof Duik.ui
			 * @param {ScriptUI Object}		text	- The ScriptUI Object
			 * @param {Array}				color	- The new color [R,V,B,A] Array
			 */
			DuikUI.prototype.setTextColor = function (text,color)
			{
				if (!text) throw "You must provide a ScriptUI Control to change the color of the text";
				var g = text.graphics;
				var textPen = g.newPen(g.PenType.SOLID_COLOR,color,1);
				g.foregroundColor = textPen;
			}
			/**
			 * Creates the main panel of a script
			 * @memberof Duik.ui
			 * @param {ScriptUI Object}		container	- The container ('this' in the root of the calling script), either a Panel (when launched from the 'Window' menu) or null (when launched from 'file/scripts/run...')
			 * @return {ScriptUI Object}	The panel created, either a ScriptUI Panel or a ScriptUI Window
			 */
			DuikUI.prototype.createUI = function (container, scriptName)
			{
				if (!scriptName) scriptName = '';

				var  myPal = null;
				container instanceof Panel ? myPal = container : myPal = new Window('palette',scriptName,undefined, {resizeable:true});

				if (myPal == null) throw "Failed to create User Interface.";

				// Margins and alignment
				myPal.margins = 5;
				myPal.spacing = 2;

				return myPal;
			}
			/**
			 * Resizes and shows the main panel of a script
			 * @memberof Duik.ui
			 * @param {ScriptUI Object}		ui	- The UI created by Duik.ui.createUI
			 */
			DuikUI.prototype.showUI = function (ui)
			{
				ui.layout.layout(true);
				ui.layout.resize();
				ui.onResizing = ui.onResize = function () {this.layout.resize();}

				// If it's a Window, it needs to be shown
				if (ui instanceof Window) {
					//ui.center();
					ui.show();
				}
			}
			/**
			 * Creates a button with an optionnal icon. Must have at least an icon or a text, or both.
			 * @memberof Duik.ui
			 * @param {ScriptUI Object}	container	- The ScriptUI Object which will contain and display the button.
			 * @param {string}					text		- The label of the button. Default: empty string
			 * @param {string}					image		- The path to the icon. Default: empty string
			 * @param {string}					helpTip		- The helptip. Default: empty string
			 * @param {string}					imageOver	- The path to an icon displayed when the mouse is over the button. Default: empty string
			 * @param {bool}					debug		- If true, the errors will be thrown instead of being catched. The default is false to work around a bug in the AE JavaScript Debugger. Default: false
			 * @return {object}					The image button created.
			 */
			DuikUI.prototype.addImageButton = function (container,text,image,helpTip,imageOver,debug)
			{
				if (!text) text = '';
				if (!image) image = '';
				if (!helpTip) helpTip = '';
				if (!imageOver) imageOver = '';

				if (text == '' && image == '') throw "You must provide either a text or an icon to create the button";

				var imageButton = {};

				imageButton.standardImage = image;
				imageButton.imageOver = imageOver;
				imageButton.onClick = function(){};
				imageButton.image = null;
				imageButton.label = null;

				//create a group
				var group = container.add('group');
				group.orientation = 'row';
				group.margins = 0;
				group.spacing = 2;
				imageButton.group = group;

				if (image != '')
				{
					var icon = group.add('image',undefined,image);
					icon.alignment = ['center','center'];
					icon.helpTip = helpTip;
					imageButton.image = icon;
				}

				if (text != '')
				{
					var label = group.add('statictext',undefined,text);
					label.helpTip = helpTip;
					label.alignment = ['left','center'];
					imageButton.label = label;
				}

				//events
				imageButton.clicked = function (e)
				{
					try { imageButton.onClick(); } catch (e) { if (debug) alert('An error has occured at line ' + e.line + '\n\n' + e.description); }
				}

				imageButton.mouseOver = function (e)
				{
					if (icon) if (imageButton.imageOver != '') icon.image = imageButton.imageOver;
					if (label) Duik.ui.setTextColor(imageButton.label,[.925,.094,.094,1]);
				}

				imageButton.mouseOut = function (e)
				{
					if (icon) if (imageButton.standardImage != '') icon.image = imageButton.standardImage;
					if (label) Duik.ui.setTextColor(imageButton.label,[.7,.7,.7,1]);
				}

				//add events
				group.addEventListener("mousedown",imageButton.clicked,true);
				// Hack - CS6 Bug on mouseover with images
				if (Duik.aeVersion >= 11 && Duik.aeVersion < 12)
				{
					if (label) imageButton.label.addEventListener("mouseover",imageButton.mouseOver);
					if (label) imageButton.label.addEventListener("mouseout",imageButton.mouseOut);
				}
				else
				{
					group.addEventListener("mouseover",imageButton.mouseOver);
					group.addEventListener("mouseout",imageButton.mouseOut);
				}


				return imageButton;
			}
			/**
			 * Creates a checkbox with an optionnal icon. Must have at least an icon or a text, or both.
			 * @memberof Duik.ui
			 * @param {ScriptUI Object}			container		- The ScriptUI Object which will contain and display the button.
			 * @param {string}					text			- The label of the button. Default: empty string
			 * @param {string}					image			- The path to the icon. Default: empty string
			 * @param {string}					helpTip			- The helptip. Default: empty string
			 * @param {string}					imageChecked	- The path to an icon displayed when the button is checked. Default: empty string
			 * @param {string}					imageOver		- The path to an icon displayed when the mouse is over the button. Default: same as imageChecked
			 * @param {bool}						debug			- If true, the errors will be thrown instead of being catched. The default is false to work around a bug in the AE JavaScript Debugger. Default: false
			 * @return {object}					The image checkbox created.
			 */
			DuikUI.prototype.addImageCheckBox = function (container,text,image,helpTip,imageChecked,imageOver,debug)
			{
				if (!container) return null;
				if (!text) text = '';
				if (!image) image = '';
				if (!helpTip) helpTip = '';
				if (!imageChecked) imageChecked = '';
				if (!imageOver) imageOver = imageChecked;

				if (text == '' && image == '') throw "You must provide either a text or an icon to create the checkbox";

				var imageButton = {};

				imageButton.standardImage = image;
				imageButton.imageOver = imageOver;
				imageButton.imageChecked = imageChecked;
				imageButton.onClick = function () {};
				imageButton.checked = imageButton.value = false;

				var group = container.add('group');
				group.orientation = 'row';
				group.margins = 0;
				group.spacing = 2;
				imageButton.group = group;

				if (image != '')
				{
					var icon = group.add('image',undefined,image);
					icon.alignment = ['center','center'];
					icon.helpTip = helpTip;
					imageButton.image = icon;
				}

				if (text != '')
				{
					if (image != '')
					{
						var label = group.add('statictext',undefined,text);
						label.helpTip = helpTip;
						label.alignment = ['center','center'];
						imageButton.label = label;
					}
					else
					{
						var label = group.add('checkbox',undefined,text);
						label.helpTip = helpTip;
						label.alignment = ['center','center'];
						imageButton.label = label;
						imageButton.box = true;
					}

				}

				imageButton.setChecked = function (c)
				{
					imageButton.checked = imageButton.value = c;
					if (imageButton.imageChecked != '')
					{
						if (imageButton.checked)
						{
							if (icon) if (imageButton.imageChecked != '') icon.image = imageButton.imageChecked;
							if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.RAINBOXRED);
						}
						else
						{
							if (icon) if (imageButton.standardImage != '') icon.image = imageButton.standardImage;
							if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.LIGHT_GRAY);
						}
					}
				}

				imageButton.clicked = function (e)
				{
					imageButton.setChecked(!imageButton.checked);
					try { imageButton.onClick(); } catch (e) { if (debug) alert('An error has occured at line ' + e.line + '\n\n' + e.description); }
				}

				imageButton.mouseOver = function (e)
				{
					if (icon) if (imageButton.imageOver != '') icon.image = imageButton.imageOver;
					if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.RAINBOXRED);
				}

				imageButton.mouseOut = function (e)
				{
					if (imageButton.checked)
					{
						if (icon) if (imageButton.imageChecked != '') icon.image = imageButton.imageChecked;
						if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.RAINBOXRED);
					}
					else
					{
						if (icon) if (imageButton.standardImage != '') icon.image = imageButton.standardImage;
						if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.LIGHT_GRAY);
					}
				}

				imageButton.group.addEventListener("mousedown",imageButton.clicked,true);
				// Hack - CS6 Bug on mouseover with images
				if (Duik.aeVersion >= 11 && Duik.aeVersion < 12)
				{
					if (label) imageButton.label.addEventListener("mouseover",imageButton.mouseOver);
					if (label) imageButton.label.addEventListener("mouseout",imageButton.mouseOut);
				}
				else
				{
					imageButton.group.addEventListener("mouseover",imageButton.mouseOver);
					imageButton.group.addEventListener("mouseout",imageButton.mouseOut);
				}

				return imageButton;
			}
			/**
			 * Creates a radio button with an optionnal icon. Must have at least an icon or a text, or both.
			 * As the radiobutton will be created in a group, you have to connect its state (using onClick() and setChecked(bool) methods and checked value) to other radio buttons, this is not automatic
			 * @memberof Duik.ui
			 * @param {ScriptUI Object}			container		- The ScriptUI Object which will contain and display the button.
			 * @param {string}					text			- The label of the button. Default: empty string
			 * @param {string}					image			- The path to the icon. Default: empty string
			 * @param {string}					helpTip			- The helptip. Default: empty string
			 * @param {string}					imageChecked	- The path to an icon displayed when the button is checked. Default: empty string
			 * @param {string}					imageOver		- The path to an icon displayed when the mouse is over the button. Default: same as imageChecked
			 * @param {bool}					showBox			- Wether to display a checkbox or only the icon. Default: true
			 * @param {bool}						debug			- If true, the errors will be thrown instead of being catched. The default is false to work around a bug in the AE JavaScript Debugger. Default: false
			 * @return {object}					The image radio button created.
			 */
			DuikUI.prototype.addImageRadioButton = function (container,text,image,helpTip,imageChecked,imageOver,showBox,debug)
			{
				if (!container) return null;
				if (!text) text = '';
				if (!image) image = '';
				if (!helpTip) helpTip = '';
				if (!imageChecked) imageChecked = '';
				if (!imageOver) imageOver = imageChecked;
				if (showBox == undefined) showBox = true;


				if (text == '' && image == '') throw "You must provide either a text or an icon to create the checkbox";

				var imageButton = {};

				imageButton.standardImage = image;
				imageButton.imageOver = imageOver;
				imageButton.imageChecked = imageChecked;
				imageButton.onClick = function () {};
				imageButton.checked = imageButton.value = false;
				imageButton.box = false;

				var group = container.add('group');
				group.orientation = 'row';
				group.margins = 0;
				group.spacing = 2;
				imageButton.group = group;

				if (image != '')
				{
					var icon = group.add('image',undefined,image);
					icon.alignment = ['center','center'];
					icon.helpTip = helpTip;
					imageButton.image = icon;
				}

				if (text != '')
				{
					if (image != '' && !showBox)
					{
						var label = group.add('statictext',undefined,text);
						label.helpTip = helpTip;
						label.alignment = ['center','center'];
						imageButton.label = label;
					}
					else
					{
						var label = group.add('radiobutton',undefined,text);
						label.helpTip = helpTip;
						label.alignment = ['center','center'];
						imageButton.label = label;
						imageButton.box = true;
					}

				}

				imageButton.setChecked = function (c)
				{
					imageButton.checked = imageButton.value = c;
					if (imageButton.box) imageButton.label.value = c;
					if (imageButton.imageChecked != '')
					{
						if (imageButton.checked)
						{
							if (icon) if (imageButton.imageChecked != '') icon.image = imageButton.imageChecked;
							if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.RAINBOXRED);
						}
						else
						{
							if (icon) if (imageButton.standardImage != '') icon.image = imageButton.standardImage;
							if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.LIGHT_GRAY);
						}
					}
				}

				imageButton.clicked = function (e)
				{
					imageButton.setChecked(true);
					try { imageButton.onClick(); } catch (e) { if (debug) alert('An error has occured at line ' + e.line + '\n\n' + e.description); }
				}

				imageButton.mouseOver = function (e)
				{
					if (icon) if (imageButton.imageOver != '') icon.image = imageButton.imageOver;
					if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.RAINBOXRED);
				}

				imageButton.mouseOut = function (e)
				{
					if (imageButton.checked)
					{
						if (icon) if (imageButton.imageChecked != '') icon.image = imageButton.imageChecked;
						if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.RAINBOXRED);
					}
					else
					{
						if (icon) if (imageButton.standardImage != '') icon.image = imageButton.standardImage;
						if (label) Duik.ui.setTextColor(imageButton.label,Duik.colors.LIGHT_GRAY);
					}
				}

				group.addEventListener("mousedown",imageButton.clicked,true);
				// Hack - CS6 Bug on mouseover with images
				if (Duik.aeVersion >= 11 && Duik.aeVersion < 12)
				{
					if (label) imageButton.label.addEventListener("mouseover",imageButton.mouseOver);
					if (label) imageButton.label.addEventListener("mouseout",imageButton.mouseOut);
				}
				else
				{
					group.addEventListener("mouseover",imageButton.mouseOver);
					group.addEventListener("mouseout",imageButton.mouseOut);
				}

				return imageButton;
			}
			/**
			 * Creates a layout to add forms to a UI, using ScriptUI groups.
			 * The object returned is a custom group with two custom attributes:
			 * form.labels is a vertical group on the left
			 * form.buttons is a vertical group on the right
			 * You can easily add controls/fields to this form using Duik.ui.addFormField
			 * @memberof Duik.ui
			 * @param {ScriptUI Object}			container		- The ScriptUI Object which will contain and display the form.
			 * @return {group}					The custom ScriptUI group containing the form.
			 */
			DuikUI.prototype.addForm = function (container)
			{
				var mainGroup = container.add('group');
				mainGroup.orientation = 'row';
				mainGroup.margins = 0;
				mainGroup.spacing = 0;

				var labelsGroup = mainGroup.add('group');
				labelsGroup.alignment = ['left','top'];
				labelsGroup.orientation = 'column';
				labelsGroup.alignChildren = ['left','bottom'];

				var buttonsGroup = mainGroup.add('group');
				buttonsGroup.alignment = ['fill','top'];
				buttonsGroup.orientation = 'column';
				buttonsGroup.alignChildren = ['fill','fill'];

				mainGroup.labels = labelsGroup;
				mainGroup.buttons = buttonsGroup;

				return mainGroup;
			}
			/**
			 * Adds a field to a form
			 * example: Duik.ui.addFormField(form,'Composition:','dropdownlist',['Composition1','Composition2'],'Select a composition')
			 * @memberof Duik.ui
			 * @param {Group}			form		- A custom ScriptUI group as returned by Duik.ui.addForm
			 * @param {string}			label		- The label text.
			 * @param {string}			type		- The type of ScriptUI object to add (like 'button','edittext', etc.).
			 * @param {object}			value		- Optionnal. The default value or content of the field added, depends on the type.
			 * @param {string}			helpTip		- Optionnal. The helpTip of the form control. Default: ''
			 * @return {object}			The ScriptUI object of the type type, added to the form
			 */
			DuikUI.prototype.addFormField = function (form,label,type,value,helpTip)
			{
				if (!helpTip) helpTip = '';
				var control = form.buttons.add(type,undefined,value);
				control.helpTip = helpTip;
				var l = form.labels.add('statictext',undefined,label);
				l.helpTip = helpTip;
				var height = control.preferredSize[1];
				l.minimumSize.height = l.maximumSize.height = height;
				return control;
			}

			this.ui = new DuikUI();
		}

		// JS ---- MOVED TO DuAEF
		{
			/**
			 * Constructs a new JS Class
			 * @class JS
			 * @memberof LibDuik
			 * @classdesc Contains generic javascript tools
			 */
			function DuikJS(){};

			// ESCAPE REGEXP
			DuikJS.prototype.escapeRegExp = function (string)
			{
				return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
			}

			// REPLACE TEXT
			DuikJS.prototype.replaceAll = function (string, find, replace, caseSensitive)
			{
				if (caseSensitive == undefined) caseSensitive = true;
				var re = new RegExp(Duik.js.escapeRegExp(find),caseSensitive ? 'g' : 'gi');
				return string.replace(re, replace);
			}

			/**
			 * Checks if a string ends with a given suffix
			 * @param {string}	str 	The string to check
			 * @param {string}	suffix	The suffix
			 * @return {bool}	Wether the string ends with the given suffix or not
			 */
			DuikJS.prototype.endsWith = 	function (str, suffix)
			{
				return str.indexOf(suffix, str.length - suffix.length) !== -1;
			}

			DuikJS.prototype.random = function (min, max)
			{
				if (min == undefined) min = 0;
				if (max == undefined) max = 1;
				var rng = null;
				$.sleep(1);
				var date = new Date();
				var rng = new Math.seedrandom(date.getTime())();
				//rng = Math.random();

				if (!rng) return 0;
				return rng * (max - min) + min;
			}

			DuikJS.prototype.arrayIndexOf = function (arr,value)
			{
				if (value == undefined) throw "Value can not be undefined";

				for (var i = 0;i<arr.length;i++)
				{
				if (arr[i] == value) return i;
				}
				return -1;
			}

			DuikJS.prototype.arrayHasDuplicates = function (arr)
			{
				for (var i = 0;i<arr.length-1;i++) {
				for (var j=i+1;j<arr.length;j++) {
				if (arr[i] === arr[j]) return true;
				}
				}
				return false;
			}

			DuikJS.prototype.arrayGetDuplicates = function (arr)
			{
				var duplicates = [];
				for (var i = 0;i<arr.length-1;i++) {
				for (var j=i+1;j<arr.length;j++) {
				if (arr[i] === arr[j]) duplicates.push(arr[j]);
				}
				}
				Duik.js.arrayRemoveDuplicates(duplicates);
				return duplicates;
			}

			DuikJS.prototype.arrayRemoveDuplicates = function (arr)
			{
				var removed = [];
				for (var i = 0;i<arr.length-1;i++) {
				for (var j=i+1;j<arr.length;j++) {
				if (arr[i] === arr[j]) {
				removed = removed.concat(arr.splice(j,1));
				}
				}
				}
				return removed;
			}

			/**
			 * A filter function to find folders only into a list.
			 * @param {File}	theFolder	- The File or Folder object to test
			 * @return {bool}	Wether the tested object is a Folder or not
			 */
			DuikJS.prototype.foldersFilter = function (theFolder)
			{
				if(theFolder instanceof Folder)
				{
					return true;
				}
				else
				{
					return false;
				}
			}

			this.js = new DuikJS();
		}

		// BRIDGE
		{
			/**
			 * Contains import and export methods
			 * @class Bridge
			 * @memberof LibDuik
			 * @classdesc Contains import and export methods
			 */
			function Bridge()
			{
				// JSON
				{
					/**
					 * Contains import and export methods for JSON
					 * @class Json
					 * @memberof Bridge
					 * @classdesc Contains import and export methods for JSON
					 */
					function Json(){};

					/**
					 * Copies all the animations (except expressions) on selected layers, store them in Duik.copiedAnim, and saves them to a Json file.
					 * @memberof Duik.bridge.json
					 * @param {File}	file				The file to save the data
					 * @param {Array}	layers 				An array of Layers or LayerCollection with the animation
					 * @param {boolean}	selectedKeysOnly	Wether to copy only selected keys or not
					 * @param {float}	startTime			The start time of the anim to copy. Default: Composition start time
					 * @param {float}	endTime				The end time of the anim to copy. Default: Composition end time
					 * @return {Array}	An array of LayerAnim
					 */
					Json.prototype.exportAnim = function (file,layers,selectedKeysOnly,startTime,endTime)
					{
						var data = {};
						data.duik = {};
						data.duik.version = Duik.version;
						data.duik.animation = true;
						data.duik.rig = false;
						data.layers = [];
						//copy the animation
						var anims  = Duik.copyAnim(layers,selectedKeysOnly,startTime,endTime);
						//clean data
						anims = Duik.bridge.cleanAnimExportData(anims);
						//stringify data
						data.layers = anims;
						data = JSON.stringify(data);
						//save to file
						file.encoding = 'UTF-8';
						file.open('w');
						file.write(data);
						file.close();
					}
					/**
					 * Imports the animation from a JSON file, store them in Duik.copiedAnim, and returns them.
					 * Just run Duik.pasteAnim to actually load the animation on some layers
					 * @memberof Duik.bridge.json
					 * @param {File}	file	The file to import
					 * @return {Array}	An array of LayerAnim
					 */
					Json.prototype.importAnim = function (file)
					{
						//open and load file
						file.encoding = 'UTF-8';
						file.open('r');
						var data = file.read();
						file.close();
						//parse data
						var anim  = JSON.parse(data).layers;
						//clean data
						anim  = Duik.bridge.cleanAnimImportData(anim);
						//copy the animation
						Duik.copiedAnim = anim;
						return anim
					}

					this.json = new Json();
				}

				// XML
				{
					/**
					 * Contains import and export methods for XML
					 * @class Xml
					 * @memberof Bridge
					 * @classdesc Contains import and export methods for XML
					 */
					function Xml(){};

					/**
					 * Parses a javascript object to an XML string
					 * This method includes some parts of x2js
					 * Copyright 2011-2013 Abdulla Abdurakhmanov
					 * Original sources are available at https://code.google.com/p/x2js/
					 * Licensed under the Apache License, Version 2.0
					 * @memberof Duik.bridge.xml
					 * @param {object}		obj		The object to parse
					 * @return {string}		The XML string
					 */
					Xml.prototype.toXmlString = function (obj)
					{
						config = {};
						config.escapeMode = true;
						config.attributePrefix = "_";
						config.arrayAccessForm = "none";
						config.useDoubleQuotes = false;
						config.jsonPropertiesFilter = [];

						function jsonXmlSpecialElem ( jsonObj, jsonObjField )
						{
							if((config.arrayAccessForm=="property" && Duik.js.endsWith(jsonObjField.toString(),("_asArray")))
									|| jsonObjField.toString().indexOf(config.attributePrefix)==0
									|| jsonObjField.toString().indexOf("__")==0
									|| (jsonObj[jsonObjField] instanceof Function) )
								return true;
							else
								return false;
						}

						function jsonXmlElemCount ( jsonObj )
						{
							var elementsCnt = 0;
							if(jsonObj instanceof Object ) {
								for( var it in jsonObj  ) {
									if(jsonXmlSpecialElem ( jsonObj, it) )
										continue;
									elementsCnt++;
								}
							}
							return elementsCnt;
						}

						function checkJsonObjPropertiesFilter(jsonObj, propertyName, jsonObjPath)
						{
							return config.jsonPropertiesFilter.length == 0
								|| jsonObjPath==""
								|| checkInStdFiltersArrayForm(config.jsonPropertiesFilter, jsonObj, propertyName, jsonObjPath);
						}

						function checkInStdFiltersArrayForm(stdFiltersArrayForm, obj, name, path)
						{
							var idx = 0;
							for(; idx < stdFiltersArrayForm.length; idx++) {
								var filterPath = stdFiltersArrayForm[idx];
								if( typeof filterPath === "string" ) {
									if(filterPath == path)
										break;
								}
								else
								if( filterPath instanceof RegExp) {
									if(filterPath.test(path))
										break;
								}
								else
								if( typeof filterPath === "function") {
									if(filterPath(obj, name, path))
										break;
								}
							}
							return idx!=stdFiltersArrayForm.length;
						}

						function getJsonPropertyPath(jsonObjPath, jsonPropName)
						{
							if (jsonObjPath==="") {
								return jsonPropName;
							}
							else
								return jsonObjPath+"."+jsonPropName;
						}

						function parseJSONAttributes ( jsonObj )
						{
							var attrList = [];
							if(jsonObj instanceof Object ) {
								for( var ait in jsonObj  ) {
									if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
										attrList.push(ait);
									}
								}
							}
							return attrList;
						}

						function escapeXmlChars(str)
						{
							if(typeof(str) == "string")
								return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
							else
								return str;
						}

						function parseJSONTextAttrs ( jsonTxtObj )
						{
							var result ="";

							if(jsonTxtObj.__cdata!=null) {
								result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";
							}

							if(jsonTxtObj.__text!=null) {
								if(config.escapeMode)
									result+=escapeXmlChars(jsonTxtObj.__text);
								else
									result+=jsonTxtObj.__text;
							}
							return result;
						}

						function parseJSONTextObject ( jsonTxtObj )
						{
							var result ="";

							if( jsonTxtObj instanceof Object ) {
								result+=parseJSONTextAttrs ( jsonTxtObj );
							}
							else
								if(jsonTxtObj!=null) {
									if(config.escapeMode)
										result+=escapeXmlChars(jsonTxtObj);
									else
										result+=jsonTxtObj;
								}

							return result;
						}

						function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList, jsonObjPath )
						{
							var result = "";
							if(jsonArrRoot.length == 0) {
								result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
							}
							else {
								//result += startTag(jsonArrRoot, jsonArrObj, attrList, false);
								for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
									result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
									result+=parseJSONObject(jsonArrRoot[arIdx], getJsonPropertyPath(jsonObjPath,jsonArrObj));
									result+="\n" + endTag(jsonArrRoot[arIdx], jsonArrObj);
								}
								//result+="\n" + endTag(jsonArrRoot,jsonArrObj);
							}
							return result;
						}

						function startTag(jsonObj, element, attrList, closed)
						{
							if (!isNaN(parseInt(element))) element = 'item' + element;
							var resultStr = "\n<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
							if(attrList!=null) {
								for(var aidx = 0; aidx < attrList.length; aidx++) {
									var attrName = attrList[aidx];
									var attrVal = jsonObj[attrName];
									if(config.escapeMode)
										attrVal=escapeXmlChars(attrVal);
									resultStr+=" "+attrName.substr(config.attributePrefix.length)+"=";
									if(config.useDoubleQuotes)
										resultStr+='"'+attrVal+'"';
									else
										resultStr+="'"+attrVal+"'";
								}
							}
							if(!closed)
								resultStr+=">";
							else
								resultStr+="/>";
							return resultStr;
						}

						function endTag(jsonObj,elementName)
						{
							if (!isNaN(parseInt(elementName))) elementName = 'item' + elementName;
							return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
						}

						function parseJSONObject ( jsonObj, jsonObjPath )
						{
							var result = "";

							var elementsCnt = jsonXmlElemCount ( jsonObj );

							if(elementsCnt > 0) {
								for( var it in jsonObj ) {

									if(jsonXmlSpecialElem ( jsonObj, it) || (jsonObjPath!="" && !checkJsonObjPropertiesFilter(jsonObj, it, getJsonPropertyPath(jsonObjPath,it))) )
										continue;

									var subObj = jsonObj[it];

									var attrList = parseJSONAttributes( subObj )

									if(subObj == null || subObj == undefined) {
										result+=startTag(subObj, it, attrList, true);
									}
									else
									if(subObj instanceof Object) {

										if(subObj instanceof Array) {
											result+=parseJSONArray( subObj, it, attrList, jsonObjPath );
										}
										else if(subObj instanceof Date) {
											result+=startTag(subObj, it, attrList, false);
											result+=subObj.toISOString();
											result+=endTag(subObj,it);
										}
										else {
											var subObjElementsCnt = jsonXmlElemCount ( subObj );
											if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
												result+=startTag(subObj, it, attrList, false);
												result+=parseJSONObject(subObj, getJsonPropertyPath(jsonObjPath,it));
												result+="\n" + endTag(subObj,it);
											}
											else {
												result+=startTag(subObj, it, attrList, true);
											}
										}
									}
									else {
										result+=startTag(subObj, it, attrList, false);
										result+=parseJSONTextObject(subObj);
										result+=endTag(subObj,it);
									}
								}
							}
							result+=parseJSONTextObject(jsonObj);

							return result;
						}

						return parseJSONObject ( obj, "" );
					}
					/**
					 * Parses the value of the XML object
					 * If this object length is not 1, an Array is returned
					 * @memberof Duik.bridge.xml
					 * @param {XML}		xml		The xml to parse
					 * @param {string}	type	The type, one of 'string', 'bool', 'int' or 'float'. Default: 'string'
					 * @return {Array}	The value or an Array of values
					 */
					Xml.prototype.getXMLValue = function (xml,type)
					{
						if (!type) type = 'string';
						var value;
						if(xml.length() > 1)
						{
							value = [];
							for (var i = 0 ; i < xml.length() ; i++)
							{
								var val = Duik.bridge.xml.getXMLValue(xml[i],type);
								value.push(val);
							}
						}
						else
						{
							var xmlString = xml.toString();
							if (type.toLowerCase() == 'float')
							{
								value = parseFloat(xmlString);
							}
							else if (type.toLowerCase() == 'int' || type.toLowerCase() == 'integer')
							{
								value = parseInt(xmlString);
							}
							else if (type.toLowerCase() == 'boolean' || type.toLowerCase() == 'bool')
							{
								if (xmlString == '0' || xmlString == '-1' || xmlString.toLowerCase() == 'false')
								{
									value = false;
								}
								else
								{
									value = true;
								}
							}
							else
							{
								value = xmlString;
							}
						}

						return value;
					}
					/**
					 * Parses the animation of a layer from an XML object
					 * @memberof Duik.bridge.xml
					 * @param {XML}			xml		The XML object of the animation
					 * @return {LayerAnim}	The animation
					 */
					Xml.prototype.parseXmlLayerAnim = function (xml)
					{
						var layerAnim = new LayerAnim();
						layerAnim._name = Duik.bridge.xml.getXMLValue(xml.@name);
						layerAnim._index = Duik.bridge.xml.getXMLValue(xml.@name,'int');

						//transformAnims
						for (var i = 0 ; i < xml.transformAnims.length();i++)
						{
							var prop = xml.transformAnims[i];
							var propertyAnim = Duik.bridge.xml.parseXmlPropertyAnim(prop);
							layerAnim.transformAnims.push(propertyAnim);
						}

						//masksAnims
						if (xml.masksAnims.hasComplexContent())
						{
							for (var i = 0 ; i < xml.masksAnims.length() ; i++)
							{
								var mask = xml.masksAnims[i];
								var maskAnim = new MaskAnim();
								maskAnim._name = Duik.bridge.xml.getXMLValue(mask.@name);
								maskAnim._matchName = Duik.bridge.xml.getXMLValue(mask.@matchName);
								for (var j = 0 ; j < mask.anims.length() ; j++)
								{
									var anim = mask.anims[j];
									var propertyAnim = Duik.bridge.xml.parseXmlPropertyAnim(anim);
									maskAnim.anims.push(propertyAnim);
								}
								layerAnim.masksAnims.push(maskAnim);
							}
						}

						//effectsAnims
						if (xml.effectsAnims.hasComplexContent())
						{
							for (var i = 0 ; i < xml.effectsAnims.length() ; i++)
							{
								var effect = xml.effectsAnims[i];
								var effectAnim = new EffectAnim();
								effectAnim._name = Duik.bridge.xml.getXMLValue(effect.@name);
								effectAnim._matchName = Duik.bridge.xml.getXMLValue(effect.@matchName);
								for (var j = 0 ; j < effect.anims.length() ; j++)
								{
									var anim = effect.anims[j];
									var propertyAnim = Duik.bridge.xml.parseXmlPropertyAnim(anim);
									effectAnim.anims.push(propertyAnim);
								}
								layerAnim.effectsAnims.push(effectAnim);
							}
						}

						return layerAnim;
					}
					/**
					 * Parses the animation of a property from an XML object
					 * @memberof Duik.bridge.xml
					 * @param {XML}				xml		The XML object of the animation
					 * @return {PropertyAnim}	The animation
					 */
					Xml.prototype.parseXmlPropertyAnim = function (xml)
					{
						var propertyAnim = new PropertyAnim();
						propertyAnim._name = Duik.bridge.xml.getXMLValue(xml.@name);
						propertyAnim._matchName = Duik.bridge.xml.getXMLValue(xml.@matchName);
						propertyAnim.startValue = Duik.bridge.xml.getXMLValue(xml.startValue,'float');
						propertyAnim.keys = [];
						//only if there are keyframes
						if (xml.keys.hasComplexContent())
						{
							for (var i = 0 ; i < xml.keys.length() ; i++)
							{
								var key = xml.keys[i];
								var keyFrame = new KeyFrame();
								keyFrame._time = Duik.bridge.xml.getXMLValue(key.@time,'float');
								keyFrame.value = Duik.bridge.xml.getXMLValue(key.value,'float');
								keyFrame._inInterpolationType = Duik.bridge.xml.getXMLValue(key.@inInterpolationType);
								keyFrame._outInterpolationType = Duik.bridge.xml.getXMLValue(key.@outInterpolationType);
								keyFrame._spatial = Duik.bridge.xml.getXMLValue(key.@spatial,'bool');
								if (keyFrame._spatial)
								{
									keyFrame.spatialProperties.inTangent = Duik.bridge.xml.getXMLValue(key.spatialProperties.inTangent,'float');
									keyFrame.spatialProperties.outTangent = Duik.bridge.xml.getXMLValue(key.spatialProperties.outTangent,'float');
									keyFrame.spatialProperties._continuous = Duik.bridge.xml.getXMLValue(key.spatialProperties.@continuous,'bool');
									keyFrame.spatialProperties._autoBezier = Duik.bridge.xml.getXMLValue(key.spatialProperties.@autoBezier,'bool');
									keyFrame.spatialProperties._roving = Duik.bridge.xml.getXMLValue(key.spatialProperties.@roving,'bool');
								}
								keyFrame.inEase = [];
								keyFrame.outEase = [];
								for (var j = 0 ; j < key.inEase.length() ; j++)
								{
									var inEase = {};
									var outEase = {};
									inEase.influence = Duik.bridge.xml.getXMLValue(key.inEase[j].influence,'float');
									inEase.speed = Duik.bridge.xml.getXMLValue(key.inEase[j].speed,'float');
									outEase.influence = Duik.bridge.xml.getXMLValue(key.outEase[j].influence,'float');
									outEase.speed = Duik.bridge.xml.getXMLValue(key.outEase[j].speed,'float');
									keyFrame.inEase.push(inEase);
									keyFrame.outEase.push(outEase);
								}
								keyFrame._continuous = Duik.bridge.xml.getXMLValue(key.@continuous,'bool');
								keyFrame._autoBezier = Duik.bridge.xml.getXMLValue(key.@autoBezier,'bool');

								propertyAnim.keys.push(keyFrame);
							}
						}

						return propertyAnim;
					}
					/**
					 * Copies all the animations (except expressions) on selected layers, store them in Duik.copiedAnim, and saves them to an XML file.
					 * @memberof Duik.bridge.xml
					 * @param {File}	file				The file to save the data
					 * @param {Array}	layers 				An array of Layers or LayerCollection with the animation
					 * @param {boolean}	selectedKeysOnly	Wether to copy only selected keys or not
					 * @param {float}	startTime			The start time of the anim to copy. Default: Composition start time
					 * @param {float}	endTime				The end time of the anim to copy. Default: Composition end time
					 * @return {Array}	An array of LayerAnim
					 */
					Xml.prototype.exportAnim = function (file,layers,selectedKeysOnly,startTime,endTime)
					{
						//copy the animation
						var anim  = Duik.copyAnim(layers,selectedKeysOnly,startTime,endTime);
						//clean data
						anim = Duik.bridge.cleanAnimExportData(anim);

						//convert to XML
						var data = {};
						data.Duik = {};
						data.Duik.layers = anim;
						data.Duik._version = Duik.version;
						data.Duik._animation = true;
						data.Duik._rig = false;
						//convert using x2js
						var xml = Duik.bridge.xml.toXmlString(data);
						//better printing using XML from Adobe
						XML.prettyPrinting = true;
						xml = '<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE duikx>\n' + XML(xml).toString();

						//save to file
						file.encoding = 'UTF-8';
						file.open('w');
						file.write(xml);
						file.close();
					}
					/**
					 * Imports the animation from an XML file, store them in Duik.copiedAnim, and returns them.
					 * Just run Duik.pasteAnim to actually load the animation on some layers
					 * @memberof Duik.bridge.json
					 * @param {File}	file	The file to import
					 * @return {Array}	An array of LayerAnim
					 */
					Xml.prototype.importAnim = function (file)
					{
						//open and load file
						file.encoding = 'UTF-8';
						file.open('r');
						var data = file.read();
						file.close();
						//parse data
						var xml = new XML(data);
						var anim = [];
						for (var i = 0;i<xml.layers.length();i++)
						{
							var layer = xml.layers[i];
							var layerAnim = Duik.bridge.xml.parseXmlLayerAnim(layer);
							anim.push(layerAnim);
						}
						//clean data
						anim  = Duik.bridge.cleanAnimImportData(anim);
						//copy the animation
						Duik.copiedAnim = anim;

						return anim;
					}

					this.xml = new Xml();
				}

				// TVPaint
				{
					/**
					 * Contains import and export methods for TVPaint files and exports
					 * @class TVPaint
					 * @memberof Bridge
					 * @classdesc Contains import and export methods for TVPaint files and exports
					 */
					function TVPaint(){};

					/**
					 * Imports a clip exported from TVPaint with the MJ_AFX_Export_1.0 tool
					 * @memberof Duik.Bridge.TVPaint
					 * @param {File}		clipInfo		The clipinfo.txt file to import. If a string is provided instead of a File object, it will be used as a path for the file.
					 */
					TVPaint.prototype.importClip = function (clipInfo)
					{
						if (!clipInfo) throw "You must provide the clipInfo file.";
						if (typeof clipInfo == 'string') clipInfo = File(clipInfo);
						if (!(clipInfo instanceof File)) throw "clipInfo must be a File or a string path.";
						if (!clipInfo.exists) throw "clipInfo does not exist."

						/**
						 * Gets the number of a frame from an image sequence
						 * The number must be right before the extension
						 * @param {string}	path	- The path of the frame
						 */
						function filepath_getNumber(path)
						{
							var string_noExt = path.substring(0,path.lastIndexOf('.'));
							var numberi = 0;
							var namei = 0;
							for(var i = string_noExt.length-1;i>=0;i--)
							{
								if(isNaN(parseInt(string_noExt.charAt(i))))
								{
									numberi = i+1;
									break;
								}
							}
							number = string_noExt.substring(numberi,string_noExt.length);
							return number;
						}


						//get path
						clipFolder = clipInfo.parent;

						//get infos
						clipInfoData = [];
						clipInfo.open('r');
						while(!clipInfo.eof)
						{
							clipInfoData.push(clipInfo.readln());
						}
						clipInfo.close();
						var framerate,clipDuration,bgColor;
						for (var i = 0 ; i < clipInfoData.length ; i++)
						{
							var data = clipInfoData[i].split(';');
							if (data[0].toLowerCase() == 'framerate')
							{
								framerate = data[1];
							}
							else if (data[0].toLowerCase() == 'duration')
							{
								clipDuration = data[1];
							}
							else if (data[0].toLowerCase() == 'bgcolor')
							{
								bgColor = data[1].split(',');
							}
						}

						if (!framerate || !clipDuration || !bgColor) throw "Invalid clipInfo file. Please re-export from TVPaint."

						//get layers
						projClipFolder = app.project.items.addFolder(clipFolder.displayName);
						myNewCompositions = new Array();
						var folders = clipFolder.getFiles(Duik.js.foldersFilter);
						for(var i = 0; i < folders.length; i++)
						{
							var curLayerFolder = folders[i];
							var folderName = curLayerFolder.displayName;
							var itemArray = curLayerFolder.getFiles("*.png");
							if(itemArray.length > 0)
							{
								itemArray.sort();
							}

							projLayerFolder = app.project.items.addFolder(folderName);
							projLayerFolder.parentFolder = projClipFolder;
							projFramesFolder = app.project.items.addFolder(folderName + "_frames");
							projFramesFolder.parentFolder = projLayerFolder;



							//Importing
							var footage = new Array();
							var files = new Array();
							for(var j = 0; j < itemArray.length;j++)
							{
								var curFile = new File(itemArray[j]);
								var ioRef = new ImportOptions(curFile);
								ioRef.importAs = ImportAsType.FOOTAGE;
								var footageRef = app.project.importFile(ioRef);
								footageRef.parentFolder = projFramesFolder;

								footage[j] = footageRef;
							}

							// read layerinfo
							layerInfopath= curLayerFolder.absoluteURI+"/layerinfo.txt";
							layerInfo = new File(layerInfopath);

							if (layerInfo.exists)
							{
							   layerInfo.open();

								var layerIN = layerInfo.readln();
								layerIN = layerIN.split(";");
								layerIN = layerIN[1];

								 var layerOUT = layerInfo.readln();
								layerOUT = layerOUT.split(";");
								layerOUT = layerOUT[1];

								var layerBlendmode = layerInfo.readln();
								layerBlendmode = layerBlendmode.split(";");
								layerBlendmode = layerBlendmode[1];

								var layerOpacity = layerInfo.readln();
									layerOpacity = layerOpacity.split(";");
									layerOpacity = layerOpacity[1];
								try
								{
									var layerLabel = layerInfo.readln();
									layerLabel = layerLabel.split(";");
									layerLabel = layerLabel[1]*1;
								}
								catch(e)
								{
									layerLabel = 0;
								}


								layerInfo.close();
							}
							else
							{
								layerIN = 1
								layerOUT = layerIN+clipDuration
								layerBlendmode ="COLOR";
							}

							layerDuration = layerOUT-layerIN+1
							layerDuration=layerDuration*(1/framerate)

							//Creating Composition
							curComp = app.project.items.addComp(folderName,footageRef.width,footageRef.height,1,layerDuration,framerate);
							curComp.parentFolder = projLayerFolder;
							var compStats=new Array(curComp,layerIN,layerOUT,layerBlendmode,layerOpacity,layerLabel);
							myNewCompositions.push(compStats);

							//Timing layers
							for(k=0;k<footage.length;k++)
							{
								curImage = footage[k];
								path = curImage.file.absoluteURI;
								imageNUM =  filepath_getNumber(path)*1;

								//frame duration
								var imageIN = imageNUM/framerate-layerIN/framerate;

								if(k==footage.length-1)
								{
									var imageDuration =  curComp.duration-imageIN;
								}
								else
								{
									nextImage = footage[k+1];
									path = nextImage.file.absoluteURI;
									nextNUM =  filepath_getNumber(path)*1;
									var deltaFrame = nextNUM-imageNUM;
									var imageDuration = deltaFrame/framerate;
								}

								//finding file
								try
								{
									mylayers = curComp.layers.add(curImage);
									mylayers.inPoint = imageIN;
									mylayers.outPoint = imageIN+imageDuration;
								}
								catch(e)
								{
									alert("Cant Add Frame "+xsht_file+"\nof "+nameMain+"\n Probably because the footage wasnt imported because there is a write failue in the File");
								}
							}
						}

						//collect Layers In animation Comp
						var collectComp = app.project.items.addComp(clipFolder.displayName,myNewCompositions[0][0].width,myNewCompositions[0][0].height,1,clipDuration/framerate,framerate);
						collectComp.parentFolder = projClipFolder;

						collectComp.bgColor =bgColor;
						for(var p = myNewCompositions.length;p>0 ;p--)
						{
							var curCompStats = myNewCompositions[p-1];
							var curComp=curCompStats[0];
							var curIN=curCompStats[1];
							var curOUT=curCompStats[2];
							var curBLEND=curCompStats[3];
							var curOPACITY=curCompStats[4];
							var curLABEL=curCompStats[5];
							var curLayer = collectComp.layers.add(curComp);
							Duik.bridge.tvPaint.setBlendingMode(curLayer,curBLEND);
							curLayer.startTime =(curIN-1)/framerate;
							curLayer.opacity.setValue(curOPACITY);

							try
							{
									curLayer.label=curLABEL*1;
							}
							catch(e)
							{
									curLayer.label=15;
							}
						}

						//detect exposure in precomps
						for (var j = 1;j<= collectComp.numLayers;j++)
						{
							//get layer
							precompLayer = collectComp.layer(j);
							Duik.getPrecompExposure(precompLayer);
						}
					}
					/**
					 * Parses a string representing camera exported from TVPaint
					 * @memberof Duik.Bridge.TVPaint
					 * @param {string}		camString	The camera to parse
					 * @return {TVPCamera}	The TVPaint Camera object
					 */
					TVPaint.prototype.parseCam = function (camString)
					{
						var camera = new TVPCamera();

						var lines = camString.split("\n");

						var reXPoint = /point\.(\d+)\.x=(-?\d+\.?\d*)/i;
						var reYPoint = /point\.(\d+)\.y=(-?\d+\.?\d*)/i;
						var reZPoint = /point\.(\d+)\.zoom=(\d+\.?\d*)/i;
						var reRPoint = /point\.(\d+)\.rotation=(-?\d+\.?\d*)/i;
						var reLinear = /profileprof_linear=([01])/i;
						var reProfPoint = /profileprof\_point(\d+)=(\d+.?\d*) (\d+.?\d*)/i;
						var rePointCout = /pointcount=(\d+)/i;
						var reProfPointCount = /profileprof_numpoint=(\d+)/i;
						for (var i=0;i<lines.length;i++ )
						{
						var line = lines[i];
						var count = line.match(rePointCout);
						if (count != null)
						{
						camera.pointCount = parseInt(count[1]);
						}
						var xPoint = line.match(reXPoint);
						if (xPoint != null)
						{
						var index = parseInt(xPoint[1]);
						var value = parseFloat(xPoint[2]);
						var point = camera.points[index];
						if (point == undefined) point = new TVPCameraPoint();
						point.x = value ;
						camera.points[index] = point;
						}
						var yPoint = line.match(reYPoint);
						if (yPoint != null)
						{
						var index = parseInt(yPoint[1]);
						var value = parseFloat(yPoint[2]);
						var point = camera.points[index];
						if (point == undefined) point = new TVPCameraPoint();
						point.y = value ;
						camera.points[index] = point;
						}
						var zPoint = line.match(reZPoint);
						if (zPoint != null)
						{
						var index = parseInt(zPoint[1]);
						var value = parseFloat(zPoint[2]);
						var point = camera.points[index];
						if (point == undefined) point = new TVPCameraPoint();
						point.zoom = value ;
						camera.points[index] = point;
						}
						var rPoint = line.match(reRPoint);
						if (rPoint != null)
						{
						var index = parseInt(rPoint[1]);
						var value = parseFloat(rPoint[2]);
						var point = camera.points[index];
						if (point == undefined) point = new TVPCameraPoint();
						point.rotation = value ;
						camera.points[index] = point;
						}
						var linear = line.match(reLinear);
						if (linear != null)
						{
						var lin = parseInt(linear[1]);
						camera.profileprof.linear = (lin == 1);
						}
						var profPoint = line.match(reProfPoint);
						if (profPoint != null)
						{
						var index = parseInt(profPoint[1]);
						var u = parseFloat(profPoint[2]);
						var v = parseFloat(profPoint[3]);
						var point = new TVPProfileprofPoint();
						point.u = u;
						point.v = v;
						camera.profileprof.points[index] = point;
						}
						var profCount = line.match(reProfPointCount);
						if (profCount != null)
						{
						camera.profileprof.pointCount = parseInt(profCount[1]);
						}
						}

						return camera;
					}
					/**
					 * Loads and parses a file reprensenting a camera exported from TVPaint
					 * @memberof Duik.Bridge.TVPaint
					 * @param {File}		camFile		The camera to parse
					 * @return {TVPCamera}	The TVPaint Camera object
					 */
					TVPaint.prototype.loadCamFile = function (camFile)
					{
						camFile.open("r");
						var camString = camFile.read();
						camFile.close();
						var tvpCam = Duik.bridge.tvPaint.parseCam(camString);
						return tvpCam;
					}
					/**
					 * Sets the blending mode of an AE Layer based on the TVPaint blend mode name
					 * @memberof Duik.Bridge.TVPaint
					 * @param {AVLayer}		layer		The layer
					 * @param {string}		blendName	The TVPaint blending mode name
					 */
					TVPaint.prototype.setBlendingMode = function (layer,blendName)
					{
						switch (blendName)
						{
							case "Color":
								layer.blendingMode = BlendingMode.NORMAL;
								break;
							case "Add":
								layer.blendingMode =  BlendingMode.ADD;
							case "Screen":
								layer.blendingMode =  BlendingMode.SCREEN;
								break;
							case "Multiply":
								layer.blendingMode =  BlendingMode.MULTIPLY;
								break;
							case "Overlay":
								layer.blendingMode =  BlendingMode.OVERLAY;
								break;
							default:
								layer.blendingMode = BlendingMode.NORMAL;
						}
					}

					this.tvPaint = new TVPaint();
				}

				// AUDITION
				{
					/**
					 * Contains export methods for Adobe Audition
					 * @class Audition
					 * @memberof Bridge
					 * @classdesc Contains export methods for Adobe Audition
					 */
					function Audition(){};

					/**
					 * Creates an XML master track for an Audition session
					 * @memberof Duik.Bridge.Audition
					 * @param {string}  name		The track name
					 * @param {int}	 id	  	A unique id for this track
					 * @param {int}	 index   	The index of the track
					 * @param {string}	channelType	The audio chanel type, one of 'mono', 'stereo' or 'fivePointOne'. Default: 'stereo'
					 * @return {XML}	The track
					 */
					Audition.prototype.createMasterTrack = function (name,id,index,channelType)
					{
						if (!channelType) channelType = 'stereo';
						if (channelType == '') channelType = 'stereo';
						var xmlString = '<masterTrack automationLaneOpenState="false" id="' + id + '" index="' + index + '" select="false" visible="true">' +
							'<trackParameters trackHeight="134" trackHue="-1" trackMinimized="false">' +
							'<name>' + name + '</name>' +
							'</trackParameters>' +
							'<trackAudioParameters audioChannelType="' + channelType + '" automationMode="1" monitoring="false" recordArmed="false" solo="false" soloSafe="true">' +
							'<trackOutput outputID="1" type="hardwareOutput"/>' +
							'<trackInput inputID="-1"/>' +
							'</trackAudioParameters>' +
							'<editParameter parameterIndex="0" slotIndex="4294967280"/>' +
							'</masterTrack>';
						var trackx = new XML(xmlString);
						return trackx;
					}
					/**
					 * Creates an XML track for an Audition session
					 * @memberof Duik.Bridge.Audition
					 * @param {string}  name	The track name
					 * @param {int}	 id	  A unique id for this track
					 * @param {int}	 index   The index of the track
					 * @param {string}	channelType	The audio chanel type, one of 'mono', 'stereo' or 'fivePointOne'. Default: 'stereo'
					 * @return {XML}	The track
					 */
					Audition.prototype.createTrack = function (name,id,index,channelType)
					{
						if (!channelType) channelType = 'stereo';
						if (channelType == '') channelType = 'stereo';

						var xmlString = '<audioTrack automationLaneOpenState="false" id="' + id + '" index="' + index + '" select="true" visible="true">' +
							'<trackParameters trackHeight="134" trackHue="-1" trackMinimized="false">' +
							'<name>' + name + '</name>' +
							'</trackParameters>' +
							'<trackAudioParameters audioChannelType="' + channelType + '" automationMode="1" monitoring="false" recordArmed="false" solo="false" soloSafe="false">' +
							'<trackOutput outputID="10000" type="trackID"/>' +
							'<trackInput inputID="1"/>' +
							'</trackAudioParameters>' +
							'</audioTrack>';
						var trackx = new XML(xmlString);
						return trackx;
					}
					/**
					 * Creates an XML clip for an Audition session
					 * @memberof Duik.Bridge.Audition
					 * @param {string}  clipName			The clip name
					 * @param {int}	 sourceId			The corresponding source file id
					 * @param {int}	 id					A unique id for this clip
					 * @param {float}   sourceInPoint	   The audio source in point
					 * @param {float}   sourceOutPoint	  The audio source out point
					 * @param {float}   startPoint		  The clip start point in the track
					 * @param {float}   endPoint			The clip end point in the track
					 * @return {XML}  	The clip
					 */
					Audition.prototype.createClip = function (clipName,sourceId,id,sourceInPoint,sourceOutPoint,startPoint,endPoint)
					{
						var xmlString = '<audioClip clipAutoCrossfade="true" crossFadeHeadClipID="-1" crossFadeTailClipID="-1" endPoint="' + endPoint + '" fileID="' + sourceId + '" hue="-1" id="' + id + '" lockedInTime="false" looped="false" name="' + clipName + '" offline="false" select="false" sourceInPoint="' + sourceInPoint + '" sourceOutPoint="' + sourceOutPoint + '" startPoint="' + startPoint + '" zOrder="0">' +
							'<fadeIn crossFadeLinkType="linkedAsymmetric" endPoint="0" shape="0" startPoint="0" type="cosine"/>' +
							'<fadeOut crossFadeLinkType="linkedAsymmetric" endPoint="' + (endPoint-startPoint) + '" shape="0" startPoint="' + (endPoint-startPoint) + '" type="cosine"/>' +
							'<channelMap>' +
							'<channel index="0" sourceIndex="0"/>' +
							'<channel index="1" sourceIndex="1"/>' +
							'</channelMap>' +
							'</audioClip>';
						var clipx = new XML(xmlString);

						return clipx;
					}
					/**
					 * Creates an XML source file for an Audition session
					 * @memberof Duik.Bridge.Audition
					 * @param {File}	file				The audio file
					 * @param {int}	 id				  A unique id for this file
					 * @return {XML}  	The file
					 */
					Audition.prototype.createSourceFile = function (file,id)
					{
						var name = file.name.substring(0,file.name.lastIndexOf('.'));

						xmlString = '<file absolutePath="' + file.fsName + '" id="' + id + '" mediaHandler="AmioWav"/>';
						var filex = new XML(xmlString);

						return filex;
					}
					/**
					 * Creates an XML Audition session file, exported from comp
					 * @memberof Duik.Bridge.Audition
					 * @param {File}		sesxFile			The Audition session XML File to save
					 * @param {CompItem}	comp				The composition to export
					 * @param {bool}   		audioActiveOnly	 Wether to export only layers with the audio enabled, or all layers with audio. Default: false
					 * @param {int}  		sampling	  		The audio sampling, in Hz. Default: 48000
					 * @param {int}   		bits		  		The audio definition, in bits. One of: 16, 24 or 32. Default: 32
					 * @param {string}		channelType			The audio chanel type, one of 'mono', 'stereo' or 'fivePointOne'. Default: 'stereo'
					 * @param {bool}   		execute				Wether to open the exported session in Audition once export is done. Default: false
					 * @param {bool}   		transcode		   Wether to extract and transcore audio from video files. Default: true
					 */
					Audition.prototype.exportComp = function (sesxFile,comp,audioActiveOnly,sampling,bits,channelType,execute,transcode)
					{
						if (!sesxFile) throw "Needs an export file";
						if (!(sesxFile instanceof File)) throw "Session file is not a valid File object";
						if (!comp) throw "Needs a composition to export";
						if (!(comp instanceof CompItem)) throw "Composition is not a valid CompItem";
						if (audioActiveOnly == undefined) audioActiveOnly = false;
						if (!sampling) sampling = 48000;
						if (!bits) bits = 32;
						if (!channelType) channelType = 'stereo';
						if (channelType == '') channelType = 'stereo';
						if (execute == undefined) execute = false;
						if (transcode == undefined) transcode = true;

						//get all layers with audio
						var audioLayers = Utils.prototype.getAudioLayers(comp.layers,audioActiveOnly);

						//build xml
						var xmlString = '<sesx version="1.4">' +
							'<session appBuild="10.1.0.174" appVersion="10.1" audioChannelType="' + channelType + '" bitDepth="' + bits + '" duration="' + (comp.duration * sampling) + '" sampleRate="' + sampling + '">' +
							'<name>' + sesxFile.name + '</name>' +
							'<tracks/>' +
							'<sessionState ctiPosition="0" smpteStart="0">' +
							'<selectionState selectionDuration="0" selectionStart="0"/>' +
							'<viewState horizontalViewDuration="0" horizontalViewStart="0" trackControlsWidth="0" verticalScrollOffset="0"/>' +
							'<timeFormatState beatsPerBar="4" beatsPerMinute="120" customFrameRate="12" linkToDefaultTimeSettings="true" noteLength="4" subdivisions="16" timeCodeDropFrame="false" timeCodeFrameRate="30" timeCodeNTSC="false" timeFormat="timeFormatDecimal"/>' +
							'<mixingOptionState defaultPanModeLogarithmic="false" panPower="-3"/>' +
							'</sessionState>' +
							'<clipGroups/>' +
							'<properties/>' +
							'</session>' +
							'<files/>' +
							'</sesx>';
						var sesx = new XML(xmlString);

						//create tracks and clips

						// the source files list, to keep only one instance of each file
						var sourceFiles = [];
						// the transcoder
						if (transcode)
						{
							var ffmpeg = new FFMpeg('-y -stats');
							var importedFolder = new Folder(sesxFile.parent.absoluteURI + '/Imported Files/');
						}

						//add clips and tracks to xml

						var numTracks = 1;
						for (i = 0 ; i < audioLayers.length ; i++)
						{
							var layer = audioLayers[i];
							var index = layer.index;

							//create a new track for this clip
							var trackChannelType = channelType;
							//in 5.1, tracks are stereo anyway by default in Audition
							if (trackChannelType == 'fivePointOne') trackChannelType = 'stereo';
							var trackx = Duik.bridge.audition.createTrack('Track ' + index,10001+i,numTracks,trackChannelType);

							//get the source file
							var sourceItem = layer.source;
							var clipFile = sourceItem.mainSource.file;
							//check if it already exists and gets the id
							var sourceId = -1;
							for (var j = 0;j < sourceFiles.length ; j++)
							{
								var pathCheck = clipFile.absoluteURI;
								if (sourceItem.hasVideo && transcode)
								{
									var name = pathCheck.substring(pathCheck.lastIndexOf('/')+1,pathCheck.lastIndexOf('.')) + "_audio.wav";
									pathCheck = importedFolder.absoluteURI + '/' + name;
								}
								if (sourceFiles[j][0].absoluteURI == pathCheck)
								{
									sourceId = sourceFiles[j][1];
									break;
								}
							}
							//create a source file
							if (sourceId == -1)
							{
								sourceId = i;
								var sourceFile = clipFile;
								if (sourceItem.hasVideo && transcode)
								{
									var name = clipFile.name.substring(0,clipFile.name.lastIndexOf('.')) + "_audio.wav";
									sourceFile = new File(importedFolder.absoluteURI + '/' + name);
									//add source to the transcoding queue
									var input = new FFMpegInputModule(clipFile.fsName);
									var codec = 'pcm_f32le';
									if (bits == 16) codec = 'pcm_s16le';
									else if (bits == 24) codec = 'pcm_s24le';
									var output = new FFMpegOutputModule(codec,sourceFile.fsName,'-ar ' + sampling + ' -vn');
									var item = new FFMpegQueueItem(input,[output]);
									//add the item to the render queue
									ffmpeg.queue.push(item);
								}
								var filex = Duik.bridge.audition.createSourceFile(sourceFile,sourceId);
								sesx.files.appendChild(filex);
								sourceFiles.push([sourceFile,sourceId])
							}

							//gets cue points
							var startPoint = layer.inPoint * sampling;
							var endPoint = layer.outPoint * sampling;
							var sourceInPoint = (layer.inPoint - layer.startTime) * sampling;
							var sourceOutPoint = (layer.outPoint - layer.startTime) * sampling;

							//create clip
							var clipName = '';
							if (Duik.mac) clipName = clipFile.fsName.substring(clipFile.fsName.lastIndexOf('/')+1,clipFile.fsName.lastIndexOf('.'));
							else clipName = clipFile.fsName.substring(clipFile.fsName.lastIndexOf('\\')+1,clipFile.fsName.lastIndexOf('.'));
							if (sourceItem.hasVideo) clipName = clipName + '_audio';

							var clipx = Duik.bridge.audition.createClip(clipName,sourceId,i,sourceInPoint,sourceOutPoint,startPoint,endPoint);

							//add track and clipFile
							trackx = trackx.appendChild(clipx[0]);
							sesx.session.tracks = sesx.session.tracks.appendChild(trackx);
							numTracks++;
						}

						//add the master track
						var masterTrackx = Duik.bridge.audition.createMasterTrack('Main',10000,numTracks,channelType);
						sesx.session.tracks = sesx.session.tracks.appendChild(masterTrackx);


						//to string with header and doctype
						XML.prettyPrinting = true;
						var xml = '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n<!DOCTYPE sesx>\n' + XML(sesx).toString();

						//save file
						sesxFile.open('w');
						sesxFile.write(xml);
						sesxFile.close();

						if (transcode)
						{
							importedFolder.create();
							ffmpeg.launch();
						}
						if (execute) sesxFile.execute();
					}

					this.audition = new Audition();
				}
			};

			/**
			 * Gets the name of an After Effects interpolation type
			 * @param {KeyframeInterpolationType}	type	The After Effects interpolation type
			 * @return {string}	The interpolation name or empty string if not found
			 */
			Bridge.prototype.keyframeInterpolationTypeToName = function (type)
			{
				if (type == KeyframeInterpolationType.LINEAR) return 'linear';
				if (type == KeyframeInterpolationType.BEZIER) return 'bezier';
				if (type == KeyframeInterpolationType.HOLD) return 'hold';
				else return '';
			}
			/**
			 * Gets the After Effects interpolation type with its name
			 * @param {string}	name	The interpolation name
			 * @return {KeyframeInterpolationType}	The interpolation type or null if not found
			 */
			Bridge.prototype.keyframeInterpolationNameToType = function (name)
			{
				if (!name) return KeyframeInterpolationType.LINEAR;
				name = name.toString();
				if (name.toLowerCase() == 'linear' || name == '6612') return KeyframeInterpolationType.LINEAR;
				else if (name.toLowerCase() == 'bezier' || name == '6613') return KeyframeInterpolationType.BEZIER;
				else if (name.toLowerCase() == 'hold' || name == '6614') return KeyframeInterpolationType.HOLD;
				else return null;
			}
			/**
			 * Cleans data from an After Effects animation before exporting it
			 * @param {object}	data	The animation
			 * @return {object}	The data cleaned
			 */
			Bridge.prototype.cleanAnimExportData = function (data)
			{
				var newData = data;

				// a function to clean a property
				function cleanProp(propData)
				{
					var newPropData = propData;
					for (var k = 0 ; k < newPropData.keys.length ; k++)
					{
						var key = newPropData.keys[k];
						key._inInterpolationType = Duik.bridge.keyframeInterpolationTypeToName(key._inInterpolationType);
						key._outInterpolationType = Duik.bridge.keyframeInterpolationTypeToName(key._outInterpolationType);
					}
					return newPropData;
				}

				for (var i = 0 ; i < newData.length ; i++)
				{
					var layer = newData[i];
					for (var j = 0 ; j < layer.transformAnims.length ; j++)
					{
						layer.transformAnims[j] = cleanProp(layer.transformAnims[j]);
					}
					for (var j = 0 ; j < layer.effectsAnims.length ; j++)
					{
						var effect = layer.effectsAnims[j];
						for (var e = 0 ; e < effect.anims.length ; e++)
						{
							effect.anims[e] = cleanProp( effect.anims[e]);
						}
					}
					for (var j = 0 ; j < layer.masksAnims.length ; j++)
					{
						var mask = layer.masksAnims[j];
						for (var e = 0 ; e < mask.anims.length ; e++)
						{
							mask.anims[e] = cleanProp( mask.anims[e]);
						}
					}
				}
				return newData;
			}
			/**
			 * Cleans data from an After Effects animation before importing it
			 * @param {object}	data	The animation
			 * @return {object}	The data cleaned
			 */
			Bridge.prototype.cleanAnimImportData = function (data)
			{
				var newData = data;

				// a function to clean a property
				function cleanProp(propData)
				{
					var newPropData = propData;
					for (var k = 0 ; k < newPropData.keys.length ; k++)
					{
						var key = newPropData.keys[k];
						//interpolation
						key._inInterpolationType = Duik.bridge.keyframeInterpolationNameToType(key._inInterpolationType);
						key._outInterpolationType = Duik.bridge.keyframeInterpolationNameToType(key._outInterpolationType);
						//ease
						for (var ease = 0 ; ease < key.inEase.length ; ease++)
						{
							key.inEase[ease] = new KeyframeEase(key.inEase[ease].speed, key.inEase[ease].influence);
							key.outEase[ease] = new KeyframeEase(key.outEase[ease].speed, key.outEase[ease].influence);
						}
					}
					return newPropData;
				}

				for (var i = 0 ; i < newData.length ; i++)
				{
					var layer = newData[i];
					for (var j = 0 ; j < layer.transformAnims.length ; j++)
					{
						layer.transformAnims[j] = cleanProp(layer.transformAnims[j])
					}
					for (var j = 0 ; j < layer.effectsAnims.length ; j++)
					{
						var effect = layer.effectsAnims[j];
						for (var e = 0 ; e < effect.anims.length ; e++)
						{
							effect.anims[e] = cleanProp(effect.anims[e])
						}
					}
					for (var j = 0 ; j < layer.masksAnims.length ; j++)
					{
						var mask = layer.masksAnims[j];
						for (var e = 0 ; e < mask.anims.length ; e++)
						{
							mask.anims[e] = cleanProp(mask.anims[e])
						}
					}
				}
				return newData;
			}

			this.bridge = new Bridge();
		}

		// UTILS
		{
			/**
			 * Contains general After Effects scripting utilities
			 * @class Utils
			 * @memberof LibDuik
			 * @classdesc Contains general After Effects scripting utilities
			 */
			function Utils(){};

			// ADD EFFECT - Utils.prototype.rigProperty(layer,prop,duikEffect)
			Utils.prototype.addEffect = function (layer,duikEffect)
			{
				if (Duik.usePresets) effect = Utils.prototype.addPseudoEffect(layer,duikEffect.ffx);
				else effect = layer.effect.addProperty(duikEffect);
				return effect;
			}
			// RIG PROPERTY - Utils.prototype.rigProperty(layer,prop,duikEffect)
			Utils.prototype.rigProperty = function (layer,prop,duikEffect)
			{
				//if prop is an effect, need a way to recover it
				var propDescription = Utils.prototype.prepareProperty(prop);
				if (!propDescription.canSetExpression) return null;
				//pseudo effect
				var effect = null;
				if (Duik.usePresets) effect = Utils.prototype.addPseudoEffect(layer,duikEffect);
				else effect = layer.effect.addProperty(duikEffect);
				if (propDescription.isEffect){ prop = layer.effect(propDescription.parentName)(propDescription.index); }
				return [effect,prop];
			}
			// PREPARE PROPERTY - Utils.prototype.prepareProperty(prop,isFX,ind,prof,parentName,dimensions)
			Utils.prototype.prepareProperty = function (prop)
			{
				var propDescr = new PropertyDescription();
				propDescr.canSetExpression = prop.canSetExpression;
				propDescr.isEffect = prop.parentProperty.isEffect;
				propDescr.index = prop.propertyIndex;
				propDescr.depth = prop.propertyDepth;
				propDescr.parentName = prop.parentProperty.name;
				propDescr.dimensions = Utils.prototype.getPropertyDimensions(prop);

				return propDescr;
			}
			// GET DIMENSIONS - Utils.prototype.getPropertyDimensions(property)
			Utils.prototype.getPropertyDimensions = function (prop)
			{
				var dimensions = 1;
				if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
				{
				//if this is a position or scale and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......
				if ((prop.matchName == "ADBE Scale" || prop.matchName == "ADBE Position") && !app.project.activeItem.selectedLayers[0].threeDLayer)
				{
				dimensions = 2;
				}
				else
				{
				dimensions = 3;
				}
				}
				else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
				{
				dimensions = 2;
				}
				return dimensions;
			}
			// GET LENGTH - Utils.prototype.getLength(value1,value2)
			Utils.prototype.getLength = function (value1,value2)
			{
				if (typeof value1 !== typeof value2)
				{
				return null;
				}
				if (value1.length > 0)
				{
				var result = 0;
				for (var dim = 0;dim<value1.length;dim++)
				{
				result += (value1[dim]-value2[dim])*(value1[dim]-value2[dim]);
				}
				result = Math.sqrt(result);
				return result;
				}
				else return Math.abs(value1 - value2) ;
			}
			// GET AVERAGE SPEED - Utils.prototype.getAverageSpeed(layer,property)
			Utils.prototype.getAverageSpeed = function (layer,prop)
			{
				if (prop.numKeys < 1) return 0;
				//for each frame of the comp
				var frames = layer.containingComp.duration / layer.containingComp.frameDuration ;
				var lastTime = prop.keyTime(prop.numKeys);
				var firstTime = prop.keyTime(1);
				var lastFrame = lastTime/layer.containingComp.frameDuration ;
				var firstFrame = firstTime/layer.containingComp.frameDuration ;
				if (lastFrame > frames) lastFrames = frames;
				if (firstFrame < 1) firstFrame = 1;
				var sum = 0;
				for (var frame = firstFrame ; frame < lastFrame ; frame++)
				{
				var time = frame*app.project.activeItem.frameDuration;
				sum += Utils.prototype.getLength(prop.valueAtTime(time,false),prop.valueAtTime(time-layer.containingComp.frameDuration,false));
				}
				return sum/(lastFrame-firstFrame);
			}
			// GET AVERAGE SPEEDS - Utils.prototype.getAverageSpeeds(layers)
			Utils.prototype.getAverageSpeeds = function (layers)
			{
				var averageSpeed = 0;
				var count = 0;
				for (var i = 0 ; i < layers.length ; i++)
				{
				var layer = Utils.prototype.getItem(layers,i);
				for (var j = 0 ; j < layer.selectedProperties.length ; j++)
				{
				var prop = layer.selectedProperties[j];
				if (prop.propertyType != PropertyType.PROPERTY) continue;
				if (prop.numKeys < 1) continue;
				var newSpeed = Utils.prototype.getAverageSpeed(layer,prop);
				if (newSpeed > 0)
				{
				averageSpeed += newSpeed;
				count++;
				}
				}
				}
				averageSpeed = averageSpeed/count;
				return averageSpeed;
			}
			// ADD PSEUDO EFFECT - Utils.prototype.addPseudoEffect(layer,duikEffect)
			Utils.prototype.addPseudoEffect = function (layer,preset)
			{
				//applyPreset is bugged and always applies presets on selected layers instead of the given one,
				//first deselect everything and select the wanted layer
				var selection = app.project.activeItem.selectedLayers;
				Utils.prototype.deselectLayers();
				layer.selected = true;

				var presetFile = new File(Duik.presetPath + preset + ".ffx");
				layer.applyPreset(presetFile);

				var newEffect = null;

				for (var fx = 1;fx <= layer("Effects").numProperties;fx++)
				{
				if (layer.effect(fx).name == preset )
				{
				newEffect = layer.effect(fx);
				break;
				}
				}

				//restore selection...
				layer.selected = false;
				for (var selectedLayerIndex=0;selectedLayerIndex<selection.length;selectedLayerIndex++)
				{
				selection[selectedLayerIndex].selected = true;
				}

				return newEffect;
			}
			// GET ALL PUPPET PINS FROM A LAYER - Utils.prototype.getPuppetPins(prop)
			Utils.prototype.getPuppetPins = function (prop)
			{
				var coins = [];
				if (prop != null)
				{
				if (prop.matchName == "ADBE FreePin3 PosPin Atom")
				{
				coins.push(prop);
				}
				else if (prop.numProperties > 0)
				{
				//contournement de bug...
				//d'abord recup les proprietes dans un tableau avant de les parcourir
				//sinon l'increment fonctionne pas dans la boucle, allez savoir pourquoi

				var proprietes = [];
				for (var p=1;p<=prop.numProperties;p++)
				{
				proprietes.push(prop.property(p));
				}

				for (var pi = 0;pi < proprietes.length;pi++)
				{
				var newCoins = Utils.prototype.getPuppetPins(proprietes[pi]);
				if (newCoins.length > 0)
				{
				coins = coins.concat(newCoins);
				}
				}
				}
				}

				return coins;
			}
			// MEASURE DISTANCE BETWEEN TWO LAYERS - Utils.prototype.getDistance(layer1,layer2)
			Utils.prototype.getDistance = function (layer1,layer2)
			{
				//parents
				var layer1Parent = layer1.parent;
				var layer2Parent = layer2.parent;
				//unlink
				layer1.parent = null;
				layer2.parent = null;
				var O = layer1.transform.position.value;
				var A = layer2.transform.position.value;
				var OA = Utils.prototype.getLength(O,A);
				//re-link
				layer1.parent = layer1Parent;
				layer2.parent = layer2Parent;
				return Math.round(OA);
			}
			// DESELECT ALL LAYERS - Utils.prototype.deselectLayers()
			Utils.prototype.deselectLayers = function ()
			{
				var sel = app.project.activeItem.selectedLayers;
				for (var selectedLayerIndex=0;selectedLayerIndex<sel.length;selectedLayerIndex++)
				{
				sel[selectedLayerIndex].selected = false;
				}
			}
			// CHECK NAMES - Utils.prototype.checkNames(comp)
			Utils.prototype.checkNames = function (comp)
			{
				if (comp == undefined) comp = app.project.activeItem;
				if (comp == undefined) return false;

				var layers = comp.layers;
				var numLayers = comp.numLayers;
				var renamed = false;

				var counts = {};
				// first pass, assign the counts
				for (var layerI = 1; layerI <= numLayers; layerI++)
				{
				var layer = layers[layerI];
				var name = layer.name;

				if (counts[name] == undefined)
				{
				counts[name] = 1;
				}
				else
				{
				counts[name]++;
				}

				if (counts[name] > 1)
				{
				var l = layer.locked;
				layer.locked = false;
				layer.name = name + " " + counts[name];
				layer.locked = l;
				renamed = true;
				}
				}

				return renamed;
			}
			// GET ITEM from Array or Collection
			Utils.prototype.getItem = function (items,itemIndex)
			{
				if (items instanceof ItemCollection || items instanceof LayerCollection || items instanceof OMCollection || items instanceof RQItemCollection) return items[itemIndex+1];
				else return items[itemIndex];
			}
			// GET KEY at index from property
			//return KeyFrame
			Utils.prototype.getKey = function (prop,keyIndex)
			{
				if (Math.abs(keyIndex) > prop.numKeys || keyIndex == 0)
				{
				return null;
				}
				if (keyIndex < 0)
				{
				keyIndex = prop.numKeys - keyIndex + 1;
				}

				var key = new KeyFrame();
				key._time = prop.keyTime(keyIndex);
				key.value = prop.keyValue(keyIndex);
				key._inInterpolationType = prop.keyInInterpolationType(keyIndex);
				key._outInterpolationType = prop.keyOutInterpolationType(keyIndex);
				if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL )
				{
				key._spatial = true;
				key.spatialProperties.inTangent = prop.keyInSpatialTangent(keyIndex);
				key.spatialProperties.outTangent  = prop.keyOutSpatialTangent(keyIndex);
				key.spatialProperties._continuous = prop.keySpatialContinuous(keyIndex);
				key.spatialProperties._autoBezier = prop.keySpatialAutoBezier(keyIndex);
				key.spatialProperties._roving = prop.keyRoving(keyIndex);
				}
				key.inEase = prop.keyInTemporalEase(keyIndex);
				key.outEase = prop.keyOutTemporalEase(keyIndex);
				key._continuous = prop.keyTemporalContinuous(keyIndex);
				key._autoBezier = prop.keyTemporalAutoBezier(keyIndex);

				return key;
			}
			// GET PROPERTY ANIMS between startTime and Endtime (if propertyGroup, recursive)
			//return Array of PropertyAnim
			Utils.prototype.getPropertyAnims = function (prop,selectedKeysOnly,allKeys,startTime,endTime)
			{
				var anims = [];
				if (prop.propertyType == PropertyType.PROPERTY)
				{
					if (prop.PropertyValueType != PropertyValueType.NO_VALUE)
					{
						var anim = Utils.prototype.getPropertyAnim(prop,selectedKeysOnly,allKeys,startTime,endTime);
						if (anim != null)
						{
							if (selectedKeysOnly && anim.keys.length >= 1) anims.push(anim);
							else if (!selectedKeysOnly) anims.push(anim);
						}
					}
				}
				else if (prop.numProperties > 0)
				{
					for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
					{
						var newAnims = Utils.prototype.getPropertyAnims(prop.property(propIndex),selectedKeysOnly,allKeys,startTime,endTime);
						if (newAnims.length > 0)
						{
							anims = anims.concat(newAnims);
						}
					}
				}
				return anims;
			}
			// GET PROPERTY ANIM between startTime and Endtime (not for PropertyGroup)
			//return PropertyAnim
			Utils.prototype.getPropertyAnim = function (prop,selectedKeysOnly,allKeys,startTime,endTime)
			{
				if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
				if (prop.propertyValueType == PropertyValueType.CUSTOM_VALUE) return null;

				if (startTime == undefined) startTime = 0;
				if (endTime == undefined) endTime = 23000;

				var anim = new PropertyAnim();
				anim._name = prop.name;
				anim._matchName = prop.matchName;

				anim.startValue = prop.valueAtTime(startTime,true);

				if (prop.elided) return anim;

				if (prop.isTimeVarying)
				{
					if (selectedKeysOnly)
					{
						for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
						{
							var key = Utils.prototype.getKey(prop,prop.selectedKeys[keyIndex]);
							if (key._time >= startTime && key._time <= endTime)
							{
								key._time = key._time - startTime;
								anim.keys.push(key);
							}
						}
					}
					else if (prop.numKeys > 0)
					{
						for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
						{
							var time = prop.keyTime(keyIndex);
							if (time >= startTime && time <= endTime || allKeys)
							{
								var key = Utils.prototype.getKey(prop,keyIndex);
								if (!allKeys) key._time = key._time - startTime;
								anim.keys.push(key);
							}
						}
					}
				}
				return anim;
			}
			// SET PROPERTY ANIM
			//return boolean
			Utils.prototype.setPropertyAnim = function (prop,propAnim,startTime,ignoreName)
			{
				if (startTime == undefined) startTime = 0;
				if (ignoreName == undefined) ignoreName = false;

				var name = propAnim._name;
				//trouver la propriete portant ce nom dans la prop demandee
				if (prop.propertyType == PropertyType.PROPERTY && !prop.elided && prop.canVaryOverTime)
				{
					if (!ignoreName && prop.name == name || ignoreName)
					{
						//if there are keys, paste them
						if (propAnim.keys.length > 0)
						{
							for (var iclef = 0; iclef < propAnim.keys.length;iclef++)
							{
								Utils.prototype.addKey(prop,propAnim.keys[iclef],startTime);
							}
						}
						else //set the start value
						{
							try { prop.setValue(propAnim.startValue); } catch (err) {};
						}
						return true;
					}
				}
				else if (prop.numProperties != undefined)
				{
					if (prop.numProperties > 0)
					{
						for (var pi = 1;pi <= prop.numProperties;pi++)
						{
							if (Utils.prototype.setPropertyAnim(prop.property(pi),propAnim,startTime)) return true;
						}
					}
				}
				return false;
			}
			// ADD KEY
			//return void
			Utils.prototype.addKey = function (prop,key,startTime)
			{
				if (prop.elided) return;
				if (startTime == undefined) startTime = 0;
				var time = startTime+key._time;
				try //au cas ou on est sur du XPosition alors que le calque est 2D, par exemple
				{
					var val = key.value;
					var dimensions = val.length;

					//get Value
					if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
					{
						if (dimensions == 2) val = [val[0],val[1],0];
						if (dimensions == 1) val = [val[0],0,0];
					}
					else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
					{
						if (dimensions == 3) val = [val[0],val[1]];
						if (dimensions == 1) val = [val[0],0];
					}
					else
					{
						if (dimensions > 1) val = val[0];
					}
					prop.setValueAtTime(time,val);

					//get the index of the created key
					var index = prop.nearestKeyIndex(time);

					//set interpolations
					if (key._spatial && (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL))
					{
						try{
							prop.setSpatialContinuousAtKey(index,key.spatialProperties._continuous);
							prop.setSpatialAutoBezierAtKey(index,key.spatialProperties._autoBezier);
							prop.setRovingAtKey(index,key.spatialProperties._roving);
							prop.setSpatialTangentsAtKey(index,key.spatialProperties.inTangent,key.spatialProperties.outTangent);
						}
						catch(err)
						{
							alert(err.description);
						};
					}

					try
					{
						prop.setTemporalContinuousAtKey(index,key._continuous);
						prop.setTemporalAutoBezierAtKey(index,key._autoBezier);
						prop.setTemporalEaseAtKey(index,key.inEase,key.outEase);
						prop.setInterpolationTypeAtKey(index,key._inInterpolationType,key._outInterpolationType);
					}
					catch(err)
					{
						alert(err.description);
					}

				}
				catch (err)
				{}
			}
			// GET FIRST KEYTIME in PropertyGroup (recursive)
			//return int
			Utils.prototype.getFirstKeyTime = function (prop)
			{
				var firstKeyTime = 86339;

				if (prop.propertyType == PropertyType.PROPERTY)
				{
				if (prop.selectedKeys.length > 0)
				{
				for (var key = 0;key<prop.selectedKeys.length;key++)
				{
				if (prop.keyTime(prop.selectedKeys[key]) < firstKeyTime)
				{
				firstKeyTime = prop.keyTime(prop.selectedKeys[key]);
				}
				}
				}
				}
				else if (prop.numProperties > 0)
				{
				for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
				{
				testKeyTime = Utils.prototype.getFirstKeyTime(prop.property(propIndex));
				if (testKeyTime < firstKeyTime) firstKeyTime = testKeyTime;
				}
				}

				return firstKeyTime;
			}
			// ARE THERE SELECTED KEYS in PropertyGroup
			//return boolean
			Utils.prototype.hasSelectedKeys = function (prop)
			{
				var yes = false;

				if (prop.propertyType == PropertyType.PROPERTY)
				{
				if (prop.selectedKeys.length >0)
				{
				yes = true;
				}
				}
				else if (prop.numProperties > 0)
				{
				for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
				{
				yes = Utils.prototype.hasSelectedKeys(prop.property(propIndex));
				if (yes) break;
				}
				}
				return yes;
			}
			// ARE THERE SELECTED KEYS in Layers
			//return boolean
			Utils.prototype.layersHaveSelectedKeys = function (layrs)
			{
				var layers = Utils.prototype.convertCollectionToArray(layrs);
				for (var i = 0 ; i < layers.length ; i++)
				{
				if (Utils.prototype.hasSelectedKeys(layers[i]))
				{
				return true;
				}
				}
				return false;
			}
			// CONVERT COLLECTION TO Array
			//return array
			Utils.prototype.convertCollectionToArray = function (collection)
			{
				var arr = [];
				if (collection instanceof ItemCollection || collection instanceof LayerCollection || collection instanceof OMCollection || collection instanceof RQItemCollection)
				{
				for (var i = 1;i<=collection.length;i++)
				{
				arr.push(collection[i]);
				}
				}
				else
				{
				arr = collection;
				}
				return arr;
			}
			/**
			 * Prepare given layers for IK creation
			 *
			 * @return {IKRig} the prepared rig
			 */
			Utils.prototype.prepIK = function (layrs)
			{

				rig = new IKRig();
				if (layrs.length < 2) return rig;
				if (layrs.length > 5) return rig;

				var layers = Utils.prototype.convertCollectionToArray(layrs);


				if (layers.length == 2){
					rig.type = 1;
					rig.layer1 = layers[0];
					rig.controller = layers[1];
				}
				else{
					//find controller
					var found = false;
					var ctrl = null;
					for (var i = 0;i<layers.length;i++){
						var l = layers[i];
						var ok = true;
						for (var j = 0;j<layers.length;j++){
							if (i == j) continue;
							var ll = layers[j];
							if (l.parent != null && l.parent == ll){
								ok = false;
								break;
							}
							if (ll.parent != null && ll.parent == l){
								ok = false;
								break;
							}
						}
						if (ok && found){
							ctrl = null;
							break;
						}
						else if (ok){
							found = true;
							ctrl = l;
						}
					}

					var valid = true;
					if (ctrl == null) valid = false;
					var sortedLayers = [];
					if (valid){
						//sort layers
						//find the one which has no parents, will be the root (first)
						var first = null;
						for (var i = 0;i<layers.length;i++){
							var l = layers[i];
							if (l == ctrl) continue;
							var ok = true;
							//search if l has a parent
							for (var j = 0;j<layers.length;j++){
								if (l.parent == layers[j]){
									ok = false;
									break;
								}
							}
							//if a parent is found, skip
							if (!ok) continue;
							//if we haven't found it already
							if (first == null){
								first = l;
							}
							else{
								first = null;
								break;
							}
						}

						if (first != null){
							sortedLayers.push(first);
							//find children
							while (sortedLayers.length < layers.length-1){
								var found = false;
								var ok = true;
								for (var i = 0;i<layers.length;i++){
									var l = layers[i];
									if (l == ctrl) continue;
									if (l.parent != null){
										if (l.parent == sortedLayers[sortedLayers.length-1]){
											if (found){
												ok = false;
												break;
											}
											else{
												sortedLayers.push(l);
											}
										}
									}
								}
								if (!ok) break;
							}
						}
					}
					if (sortedLayers.length != layers.length-1) valid = false;

					if (layers.length == 3){
						if (valid){
							rig.layer1 = sortedLayers[0];
							rig.layer2 = sortedLayers[1];
							rig.controller = ctrl;
						}
						else{
							rig.layer1 = layers[1];
							rig.layer2 = layers[0];
							rig.controller = layers[2];
						}
						//2 layer or 1+goal ?
						if (Utils.prototype.getDistance(rig.layer2,rig.controller) < 10){
							rig.goal = rig.layer2;
							rig.layer2 = null;
							rig.type = 1;
						}
						else{
							rig.type = 2;
						}
					}
					else if (layers.length == 4){
						if (valid){
							rig.layer1 = sortedLayers[0];
							rig.layer2 = sortedLayers[1];
							rig.layer3 = sortedLayers[2];
							rig.controller = ctrl;
						}
						else{
							rig.layer1 = layers[2];
							rig.layer2 = layers[1];
							rig.layer3 = layers[0];
							rig.controller = layers[3];
						}
						//3 layer or 2+goal ?
						if (Utils.prototype.getDistance(rig.layer3,rig.controller) < 10){
							rig.goal = rig.layer3;
							rig.layer3 = null;
							rig.type = 2;
						}
						else{
							rig.type = 3;
						}
					}
					else if (layers.length == 5){
						if (valid){
							rig.layer1 = sortedLayers[0];
							rig.layer2 = sortedLayers[1];
							rig.layer3 = sortedLayers[2];
							rig.goal = sortedLayers[3];
							rig.controller = ctrl;
							rig.type = 3;
						}
						else{
							rig.layer1 = layers[3];
							rig.layer2 = layers[2];
							rig.layer3 = layers[1];
							rig.goal = layers[0];
							rig.controller = layers[4];
							rig.type = 3;
						}
					}
				}


				//detect 3d
				var threeD = true;
				for (var i = 0 ; i < layers.length ; i++){
					if (!layers[i].threeDLayer){
						threeD = false;
						break;
					}
				}
				rig.threeD = threeD;

				//Detect frontFacing if 3D
				//add a point effect on the layer to get values with expressions
				if (threeD){
					var tempEffect = rig.layer1.effect.addProperty("ADBE Point3D Control");
					tempEffect(1).expression = "C = thisComp.layer(\"" + rig.layer1.name + "\");\n" +
						"u = C.toWorldVec([1,0,0]);\n" +
						"v = C.toWorldVec([0,1,0]);\n" +
						"w = C.toWorldVec([0,0,1]);\n" +
						"sinb = clamp(w[0],-1,1);\n" +
						"b = Math.asin(sinb);\n" +
						"cosb = Math.cos(b);\n" +
						"if (Math.abs(cosb) > .0005){\n" +
						"c = -Math.atan2(v[0],u[0]);\n" +
						"a = -Math.atan2(w[1],w[2]);\n" +
						"}else{\n" +
						"a = Math.atan2(u[1],v[1]);\n" +
						"c = 0;\n" +
						"}\n" +
						"xValue=Math.round(radiansToDegrees(a));\n" +
						"yValue=Math.round(radiansToDegrees(b));\n" +
						"zValue=Math.round(radiansToDegrees(c));\n" +
						"[(xValue),(yValue),(zValue)]\n";
					var orientation = tempEffect(1).value;
					rig.frontFacing = false;
					if (orientation[0]%180 > 10 || orientation[1]%90 >10) rig.threeD = false;
					else if (orientation[1]%180 < 10) rig.frontFacing = true;
					tempEffect.remove();
				}

				//Detect clockwise if IK is of type 2
				if (rig.type == 2 || rig.type == 3){
					rig.clockWise = Utils.prototype.isIKClockwise(rig.layer1,rig.layer2,rig.controller);
				}

				return rig;

			}
			// GET CONTROLLERS
			//return Array of Controllers
			Utils.prototype.getControllers = function (layrs)
			{
				if (layrs == undefined) layrs = app.project.activeItem.layers;
				else if (layrs.length == 0) layrs = app.project.activeItem.layers;
				var layers = Utils.prototype.convertCollectionToArray(layrs);

				var controllers = [];

				for (var i = 0 ; i< layers.length; i++)
				{
				var l = layers[i];
				if (l instanceof ShapeLayer)
				{
				var iconGroup = l.property("ADBE Root Vectors Group")("Icon");
				if (iconGroup == null) continue;
				var controller = new Controller();
				controller.type = Duik.layerTypes.VECTOR;
				controller.layer = l;
				controller.size = iconGroup("ADBE Vector Transform Group")("ADBE Vector Scale").value[0];
				//check properties
				for (var j = 1 ; j <= iconGroup("ADBE Vectors Group").numProperties ; j++)
				{
				if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "rotation")
				{
				controller.rotation = true;
				controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
				}
				else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "xposition")
				{
				controller.xPosition = true;
				controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
				}
				else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "yposition")
				{
				controller.yPosition = true;
				controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
				}
				else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "scale")
				{
				controller.scale = true;
				controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
				}
				else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "arc")
				{
				controller.arc = true;
				controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
				}
				else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "eye")
				{
				controller.eye = true;
				controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")(2)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
				}
				else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "camera")
				{
				controller.camera = true;
				controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Fill")("ADBE Vector Fill Color").value;
				}
				}
				controllers.push(controller);
				}
				else if (l instanceof AVLayer && l.name.indexOf("C_") == 0)
				{
				var controller = new Controller();
				controller.type = Duik.layerTypes.NULL;
				controller.layer = l;
				controllers.push(controller);
				}
				}
				return controllers;
			}
			/**
			 * Gets an expression link to the property
			 * @memberof Duik.utils
			 * @param {Property}	prop			- The property
			 * @param {bool}		useThisComp		- Wether to begin the expression by 'thisComp' or 'comp("name")', default: false
			 * @return {str}		The expression link to the property
			 */
			Utils.prototype.getExpressionLink = function (prop,useThisComp)
			{
				if (useThisComp == undefined) useThisComp = false;

				//get compact expression from matchName, if available
				function getCompactExpression(prop, matchName, name)
				{
					var translatedName = Duik.expressions.compactExpressions[matchName];

					if (translatedName !== undefined)
						return eval(translatedName);
					else
						return ("(" + name + ")");
				}

				var exprCode = "";
				var name;
				while (prop.parentProperty !== null)
				{
					if (prop.propertyType == PropertyType.PROPERTY ) name = prop.propertyIndex;
					else name = "\"" + prop.name + "\"";
					compactName = getCompactExpression(prop, prop.matchName, name);
					exprCode = compactName + exprCode;

					// Traverse up the property tree
					prop = prop.parentProperty;
				}

				var comp = prop.containingComp;
				// Prefix the layer reference
				name = "\"" + prop.name + "\"";
				exprCode = "layer(" + name + ")." + exprCode;
				// Prefix the comp reference
				if (useThisComp) exprCode = "thisComp." + exprCode;
				else exprCode = "comp(\"" + comp.name + "\")." + exprCode;

				return exprCode;
			}
			/**
			 * Adds an expression to the child property, linking it to the parent property
			 * @memberof Duik.utils
			 * @param {Property}	childProp		- The child property (the one which gets an expression).
			 * @param {Property}	parentProp 		- The parent property.
			 * @param {bool}		useThisComp		- Wether to begin the expression by 'thisComp' or 'comp("name")', default: will detect if the properties are in the same comp
			 */
			Utils.prototype.pickWhip = function (childProp,parentProp,useThisComp)
			{
				if (!childProp.canSetExpression) return;

				if (useThisComp == undefined)
				{
					var parentComp = Utils.prototype.getPropertyComp(parentProp);
					var childComp = Utils.prototype.getPropertyComp(childProp);
					if (parentComp.id == childComp.id) useThisComp = true;
					else useThisComp = false;
				}
				childProp.expression = Utils.prototype.getExpressionLink(parentProp,useThisComp);
			}
			/**
			 * Link all the properties found in childProp to all the same properties of parentProp (this is a recursive method)
			 * @memberof Duik.utils
			 * @param {PropertyGroup}	childProp			- The child property
			 * @param {PropertyGroup}	parentProp			- The parent property
			 * @param {bool}		useThisComp				- Wether to begin the expression by 'thisComp' or 'comp("name")', default: will detect if the properties are in the same comp
			 */
			Utils.prototype.linkProperties = function (childProp,parentProp,useThisComp)
			{
				for (var p = 1 ; p <= childProp.numProperties ; p++)
				{
					if (childProp(p).propertyType == PropertyType.PROPERTY && !childProp(p).elided)
					{
						//copy paste the animation / value
						var anim = Utils.prototype.getPropertyAnim(childProp(p),false,true);
						if (anim != null) Utils.prototype.setPropertyAnim(parentProp(p),anim,0,true);
						//get the expression
						if (parentProp(p).canSetExpression && childProp(p).expression != "")
						{
							try { parentProp(p).expression = childProp(p).expression; }
							catch (err) {};
						}
						//set the link
						Utils.prototype.pickWhip(childProp(p),parentProp(p),useThisComp);
					}
					else
					{
						Utils.prototype.linkProperties(childProp(p),parentProp(p),useThisComp);
					}
				}
			}
			// SMART COMP DUPLICATE: DUPLICATE COMP
			//returns void
			Utils.prototype.duplicateComp = function (comp,prefix)
			{

				if (Duik.settings.displayProgressPanel) Duik.ui.showProgressPanel(100,"Duplicating " + comp.name);

				var previousComps = [];

				//NEEDED FUNCTIONS

				//gets an item with its ID
				function getItemWithID(id)
				{
				for (var x=1; x<=app.project.numItems; x++)
				{
				if (app.project.item(x).id == id)
				{
				return app.project.item(x);
				}
				}
				return null;
				}

				//duplicates a comp (recursive through precomps)
				function duplicateStructure(comp,parentFolder,prefix) {
				// Duplicate the incoming comp
				var newCompName = prefix + comp.name;
				var comp = comp.duplicate();
				comp.name = newCompName;

				// For each layer in the comp, check for subcomps
				for (var i=1; i<=comp.numLayers; i++)
				{
				var layer = comp.layer(i);
				//Check if layer has a source and that its type is a composition
				if (layer.source)
				{
				if (layer.source instanceof CompItem)
				{
				// Check if this comp has already been duplicated
				var check = null;
				if (previousComps[layer.source.id])
				{
				check = getItemWithID(previousComps[layer.source.id]);
				}

				if (check == null)
				{
				// The subcomp hasn't been duplicated before

				// Store the original comp id to remember the correlation
				var sourceID = layer.source.id;
				// Replace the source of the layer, and recursively check in that subcomp for sub-subcomps
				layer.replaceSource(duplicateStructure(layer.source, parentFolder,prefix), false);
				// Store the new comp id to remember the correlation
				var destID = layer.source.id;
				//Add the correlation to an array
				previousComps[sourceID] = destID;
				} else
				{
				// Replace the source with the already duplicated comp
				layer.replaceSource(check, false);
				}
				}

				}
				}

				//Move the comp to the folder
				comp.parentFolder = parentFolder;

				// For the recursion, return the duplicated comp
				return comp;
				}

				//LET's GO

				//create a new folder
				var parentFolder = app.project.items.addFolder(prefix + comp.name);

				// If the mainComp is not in the root of the project, then put the new folder on the same hierarchy level as the original parent folder
				if (comp.parentFolder.parentFolder)
				{
				parentFolder.parentFolder = comp.parentFolder.parentFolder;
				} else
				{
				parentFolder.parentFolder = comp.parentFolder;
				}

				if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(1,"Duplicating precomps");

				//go
				var newMainComp = duplicateStructure(comp, parentFolder,prefix);

				//add the main comp to the comps duplicated
				previousComps[comp.id] = newMainComp.id;

				if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(2,"Updating expressions");

				//update expressions
				for (var i=0;i<previousComps.length;i++ )
				{
				//for each comp, get the new name
				var oldComp = getItemWithID(i);
				if (!oldComp) continue;
				var newComp = getItemWithID(previousComps[i]);
				if (!newComp) continue;
				var oldName = oldComp.name;
				var newName = newComp.name;
				if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(Duik.ui.progressBar.value + 1,"Updating expressions: " + newName);
				//in all comps, update the name in the expressions
				for (var j=0;j<previousComps.length;j++ )
				{
				var oldComp2 = getItemWithID(j);
				if (!oldComp2) continue;
				var newComp2 = getItemWithID(previousComps[j]);
				if (!newComp2) continue;
				//double quotes
				var old = "comp(\"" + oldName + "\"";
				var newExpr = "comp(\"" + newName + "\"";
				Utils.prototype.replaceInLayersExpressions(newComp2.layers,old,newExpr);
				//single quotes
				var old = "comp('" + oldName + "'";
				var newExpr = "comp('" + newName + "'";
				Utils.prototype.replaceInLayersExpressions(newComp2.layers,old,newExpr);
				}
				}

				if (Duik.settings.displayProgressPanel) Duik.ui.hideProgressPanel();

				return newMainComp;
			}
			// REPLACE IN EXPRESSIONS - Utils.prototype.replaceInExpressions(prop,oldString,newString,caseSensitive)
			Utils.prototype.replaceInExpressions = function (prop,oldString,newString,caseSensitive)
			{
				if (prop.propertyType == PropertyType.PROPERTY)
				{
				if (prop.canSetExpression)
				{
				var expr = prop.expression;
				expr = Duik.js.replaceAll(expr,oldString,newString,caseSensitive);
				try { prop.expression = expr; }
				catch(err){};
				delete expr;
				}
				}
				else if (prop.numProperties > 0)
				{
				for (var propertyIndex = 1;propertyIndex <= prop.numProperties;propertyIndex++)
				{
				Utils.prototype.replaceInExpressions(prop.property(propertyIndex),oldString,newString);
				}
				}
			}
			/* REPLACE IN LAYERS EXPRESSIONS - Utils.prototype.replaceInLayersExpressions(layers,oldString,newString,caseSensitive);

			Replaces all occurences of oldString by newString in all the expressions of all the layers.

			parameters
			layers | Array of AVLayers or LayerCollection
			oldString | string
			newString | string

			returns
			void

			*/
			Utils.prototype.replaceInLayersExpressions = function (layrs,oldString,newString,caseSensitive)
			{
				if (caseSensitive == undefined) caseSensitive = true;
				var layers = Utils.prototype.convertCollectionToArray(layrs);
				for (var layerIndex = 0 ; layerIndex<layers.length ; layerIndex++)
				{
					var l = layers[layerIndex];
					var locked = l.locked;
					l.locked = false;
					Utils.prototype.replaceInExpressions(l,oldString,newString,caseSensitive);
					l.locked = locked;
					delete l;
					delete locked;
				}
			}
			// RENAME LAYER
			Utils.prototype.renameLayer = function (layer,newName,updateExpressions,currentComp)
			{
				if (layer == undefined) return;
				if (newName == undefined) return;
				if (newName == "") return;
				if (updateExpressions == undefined) updateExpressions = true;

				app.beginSuppressDialogs();

				var oldName = layer.name;
				layer.name = newName;

				var compName = layer.containingComp.name;
				//update expressions
				if (updateExpressions)
				{

				//all items
				if (!currentComp)
				{
				for (var j = 1;j<=app.project.items.length;j++)
				{
				var comp = app.project.item(j);
				if (comp instanceof CompItem)
				{
				try
				{
				//double quotes
				var old = "comp(\"" + compName + "\").layer(\"" + oldName + "\"";
				var newExpr = "comp(\"" + compName + "\").layer(\"" + newName + "\"";
				Utils.prototype.replaceInLayersExpressions(comp.layers,old,newExpr);
				//single quotes
				var old = "comp('" + compName + "').layer('" + oldName + "'";
				var newExpr = "comp('" + compName + "').layer('" + newName + "'";
				Utils.prototype.replaceInLayersExpressions(comp.layers,old,newExpr);
				}
				catch (err) {};
				}
				}
				}

				//containing comp (thisComp)
				try
				{
				//double quotes
				var old = "layer(\"" + oldName + "\"";
				var newExpr = "layer(\"" + newName + "\"";
				Utils.prototype.replaceInLayersExpressions(app.project.activeItem.layers,old,newExpr);
				//single quotes
				var old = "layer('" + oldName + "'";
				var newExpr = "layer('" + newName + "'";
				Utils.prototype.replaceInLayersExpressions(app.project.activeItem.layers,old,newExpr);
				}
				catch (err) {};
				}

				app.endSuppressDialogs(false);
			}
			// RENAME ITEM
			Utils.prototype.renameItem = function (item,newName,updateExpressions)
			{
				if (item == undefined) return;
				if (newName == undefined) return;
				if (newName == "") return;
				if (updateExpressions == undefined) updateExpressions = true;

				var oldName = item.name;
				item.name = newName;


				app.beginSuppressDialogs();

				//update expressions
				if (updateExpressions && item instanceof CompItem)
				{
				for (var j = 1;j<=app.project.items.length;j++)
				{
				var comp = app.project.item(j);
				if (comp instanceof CompItem)
				{
				try
				{
				//double quotes
				var old = "comp(\"" + oldName + "\"";
				var newExpr = "comp(\"" + newName + "\"";
				Utils.prototype.replaceInLayersExpressions(comp.layers,old,newExpr);
				//single quotes
				var old = "comp('" + oldName + "'";
				var newExpr = "comp('" + newName + "'";
				Utils.prototype.replaceInLayersExpressions(comp.layers,old,newExpr);
				}
				catch (err) {};
				}
				}
				}

				app.endSuppressDialogs(false);
			}
			/**
			 * Gets the layer containing a given property
			 * @param {PropertyBase}	prop	The Property
			 * @return	{Layer}			The containing layer
			 */
			Utils.prototype.getPropertyLayer = function (prop)
			{
				if (prop == undefined) return null;
				var parentProp = prop;
				while (parentProp.parentProperty !== null)
				{
					// Traverse up the property tree
					parentProp = parentProp.parentProperty;
				}
				return parentProp;
			}
			// GET PROP COMP
			Utils.prototype.getPropertyComp = function (prop)
			{
				var layer = Utils.prototype.getPropertyLayer(prop);
				return layer.containingComp;
			}
			// AUTO RENAME EFFECT
			Utils.prototype.renameEffect = function (effect,name)
			{
				var layer = Utils.prototype.getPropertyLayer(effect);
				var ok = false;
				var num = 1;
				while(!ok)
				{
				ok = true;
				for (var i = 1;i<=layer.effect.numProperties;i++)
				{
				if (layer.effect(i).name == name)
				{
				if (num == 1)
				{
				name = name + "_";
				}
				num++;
				name = name.substr(0,name.lastIndexOf("_")+1) + num;
				ok = false;
				break;
				}
				}
				}
				effect.name = name;
			}
			// GET FOOTAGE EXPOSURE
			Utils.prototype.getFootageExposure = function (layer,accuracy,tolerance,r,g,b,a)
			{
				if (layer == undefined) return [];
				var comp = layer.containingComp;
				if (accuracy == undefined) accuracy = 50;
				precision = accuracy / 100;
				if (tolerance == undefined) tolerance = 10;
				tolerance = tolerance/1000;
				if (r == undefined) r = true;
				if (g == undefined) g = true;
				if (b == undefined) b = true;
				if (a == undefined) a = false;

				var numSamplesX = 10;
				var numSamplesY = numSamplesX;

				//detected expo
				var detectedExposure = [];

				//Expression to get samples

				exp = "var numSamplesX = " + numSamplesX + ";\n" +
				"var numSamplesY = " + numSamplesY + ";\n" +
				"var precision = " + precision + ";\n" +
				"var result = [0,0,0,0];\n" +
				"for ( i = 1 ; i <= numSamplesX ; i++)\n" +
				"for (j = 1 ; j <= numSamplesY ; j++)\n" +
				"result = result + sampleImage([i*(width/numSamplesX)-(width/numSamplesX/2),j*(height/numSamplesY)-(height/numSamplesY/2)],[width/2/numSamplesX*precision,height/2/numSamplesY*precision]);\n" +
				"result = result/(numSamplesX+numSamplesY);"
				"result;";

				//color
				var color = layer.Effects.addProperty("ADBE Color Control");
				var colorProp = color(1);
				colorProp.expression = exp;

				//add keyframes
				var frames = comp.duration / comp.frameDuration;
				var inFrame = layer.inPoint / comp.frameDuration;
				var outFrame = layer.outPoint / comp.frameDuration;
				if (inFrame < 0) inFrame = 0;
				if (outFrame > (comp.duration/comp.frameDuration)) outFrame = comp.duration /comp.frameDuration;

				if (Duik.settings.displayProgressPanel) Duik.ui.showProgressPanel(outFrame-inFrame,"Exposure detection from layer " + layer.name);

				var prevColor = colorProp.valueAtTime(layer.inPoint,false);

				detectedExposure.push(layer.inPoint);

				var progressValue = 0;
				for (var frame = inFrame ; frame < outFrame ; frame++)
				{
				progressValue++;
				if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Exposure detection: " + layer.name + " - Frame: " + frame);
				var time = frame*comp.frameDuration;
				comp.time = time;
				if (Duik.aeVersion >= 13.5)
				{
				$.sleep(500);
				}
				var hasChanged = false;
				var currentColor = colorProp.valueAtTime(time,false);
				var rVariation = Math.abs(prevColor[0] - currentColor[0]);
				var gVariation = Math.abs(prevColor[1] - currentColor[1]);
				var bVariation = Math.abs(prevColor[2] - currentColor[2]);
				var aVariation = Math.abs(prevColor[3] - currentColor[3]);
				if (r && rVariation > tolerance )
				{
				hasChanged = true;
				}
				else if (g && gVariation > tolerance )
				{
				hasChanged = true;
				}
				else if (b && bVariation > tolerance )
				{
				hasChanged = true;
				}
				else if (a && aVariation > tolerance )
				{
				hasChanged = true;
				}

				if (hasChanged)
				{
				detectedExposure.push(time);
				prevColor = currentColor;
				}
				}

				if (Duik.settings.displayProgressPanel) Duik.ui.hideProgressPanel();

				color.remove();

				if (Duik.settings.displayProgressPanel) Duik.ui.hideProgressPanel();

				Duik.detectedExposure = detectedExposure;

				return detectedExposure;
			}
			// STEP SELECTED PROPERTIES
			Utils.prototype.stepSelectedProperties = function (layrs)
			{
				var layers = Utils.prototype.convertCollectionToArray(layrs);
				for (var i = 0 ; i < layers.length ; i++)
				{
				var layer = layers[i];
				if (layer.selectedProperties.length == 0) continue;
				for (var j = 0 ; j < layer.selectedProperties.length ; j++)
				{
				var prop = layer.selectedProperties[j];
				if (prop.propertyType != PropertyType.PROPERTY) continue;
				if (prop.numKeys == 0) continue;
				for (var keyIndex = 1;keyIndex <= prop.numKeys;keyIndex++)
				{
				prop.setInterpolationTypeAtKey(keyIndex,KeyframeInterpolationType.HOLD,KeyframeInterpolationType.HOLD);
				}
				}
				}
			}
			// ADD NULL ON LAYER
			Utils.prototype.addNullOnLayer = function (layer)
			{
				if (layer == undefined) return null;
				layerParent = layer.parent;
				layer.parent = null;
				var nullLayer = layer.containingComp.layers.addNull();
				nullLayer.transform.position.setValue(layer.transform.position.value);
				layer.parent = layerParent;
				nullLayer.moveBefore(layer);
				nullLayer.name = "N_" + layer.name;
				return nullLayer;
			}
			// IS IK Clockwise
			Utils.prototype.isIKClockwise = function (root,middle,end)
			{
				if (root == undefined) return false;
				if (middle == undefined) return false;
				if (end == undefined) return false;

				//unparent
				var rootParent = root.parent;
				root.parent = null;
				var middleParent = middle.parent;
				middle.parent = null;
				var endParent = end.parent;
				end.parent = null;

				var endPos = end.transform.position.value - root.transform.position.value;
				var middlePos = middle.transform.position.value - root.transform.position.value;
				var coef = endPos[1]/endPos[0];

				var clockwise = false;

				if (middlePos[1] < middlePos[0]*coef && endPos[0] > 0) clockwise = true;
				if (middlePos[1] > middlePos[0]*coef && endPos[0] < 0) clockwise = true;

				//reparent
				root.parent = rootParent;
				middle.parent = middleParent;
				end.parent = endParent;

				return clockwise;
			}
			// GET LAYER BY PARTIAL NAME
			Utils.prototype.getLayerByName = function (layrs,name)
			{
				if (layrs == undefined) return null;
				if (name == undefined) return null;

				var layers = Utils.prototype.convertCollectionToArray(layrs);

				var layer = null;

				for (var i = 0; i < layers.length ; i++)
				{
				if (layers[i].name.toLowerCase().indexOf(name.toLowerCase()) >= 0 )
				{
				layer = layers[i];
				break;
				}
				}

				return layer;
			}
			// GET LAYER BY PARTIAL NAMES
			Utils.prototype.getLayerByNames = function (layrs,names)
			{
				if (layrs == undefined) return null;
				if (names == undefined) return null;

				var layers = Utils.prototype.convertCollectionToArray(layrs);

				var layer = null;

				for (var i = 0 ; i < names.length ; i++)
				{
				layer = Utils.prototype.getLayerByName(layers,names[i]);
				if (layer) break;
				}

				return layer;
			}
			// GET LAYERS BY PARTIAL NAME
			Utils.prototype.getLayersByName = function (layrs,name)
			{
				if (layrs == undefined) return null;
				if (name == undefined) return null;

				var layers = Utils.prototype.convertCollectionToArray(layrs);

				var results = [];

				for (var i = 0; i < layers.length ; i++)
				{
				if (layers[i].name.toLowerCase().indexOf(name.toLowerCase()) >= 0 )
				{
				results.push(layers[i]);
				}
				}

				return results;
			}
			// GET LAYERS BY PARTIAL NAMES
			Utils.prototype.getLayersByNames = function (layrs,names)
			{
				if (layrs == undefined) return null;
				if (names == undefined) return null;

				var layers = Utils.prototype.convertCollectionToArray(layrs);

				var results = [];

				for (var i = 0 ; i < names.length ; i++)
				{
				results = results.concat(Utils.prototype.getLayersByName(layers,names[i]));
				}

				return results;
			}
			// GET LAYER READABLE LIST: Index - Name
			Utils.prototype.getLayersReadableList = function (layrs)
			{
				var list = [];

				if (layrs == undefined) return list;

				var layers = Utils.prototype.convertCollectionToArray(layrs);

				for (var i = 0 ; i < layers.length ; i++)
				{
				list.push(layers[i].index + " - " + layers[i].name);
				}

				return list;
			}
			// SORT LAYERS BY DISTANCE FROM REF
			Utils.prototype.sortByDistance = function (layrs,from)
			{
				if (layrs == undefined) return layrs;

				var layers = Utils.prototype.convertCollectionToArray(layrs);

				var fromPos = Utils.prototype.getWorldPos(from);

				function sorter(l1,l2)
				{
				var l1Pos = Utils.prototype.getWorldPos(l1);
				var l2Pos = Utils.prototype.getWorldPos(l2);

				var l1d = Utils.prototype.getLength(l1Pos,fromPos);
				var l2d = Utils.prototype.getLength(l2Pos,fromPos);

				return l1d-l2d;
				}

				if (layers.length >= 2) layers.sort(sorter);

				return layers;
			}
			// GET WORLD POSITION
			Utils.prototype.getWorldPos = function (l)
			{
				if (!l) return [];
				var p = l.parent;
				l.parent = null;
				var pos = l.transform.position.value;
				l.parent = p;
				return pos;
			}
			//SORT LAYERS BY INDEX
			Utils.prototype.sortLayersByIndex = function (layrs)
			{
				var layers = Utils.prototype.convertCollectionToArray(layrs);
				function compareLayerIndexes(lay1,lay2)
				{
				return lay1.index-lay2.index;
				}
				return layers.sort(compareLayerIndexes);
			}
			//CONVERT HEX COLOR TO RVB
			Utils.prototype.hexColorToRVB = function (hexColor,isString)
			{
					if (isString == undefined) isString = true;
					if (isString)
					{
						if (hexColor.indexOf("#") == 0) hexColor = hexColor.replace("#","");
						var red = parseInt(hexColor.substr(0,2),16)/255.0;
						var green = parseInt(hexColor.substr(2,2),16)/255.0;
						var blue = parseInt(hexColor.substr(4,2),16)/255.0;
						return [red,green,blue];
					}
					else
					{
							var r = hexColor >> 16;
							var g = (hexColor & 0x00ff00) >> 8;
							var b = hexColor & 0xff;
							return [r/255,g/255,b/255,1];
					}
				}
			//CONVERT RVB COLOR TO HEX
			Utils.prototype.rvbColorToHex = function (rvbColor)
			{
				var red = rvbColor[0]*255;
				var green = rvbColor[1]*255;
				var blue = rvbColor[2]*255;
				var hexR = red.toString(16)
				var hexG = green.toString(16)
				var hexB = blue.toString(16);
				if (hexR.length == 1) hexR = "0" + hexR;
				if (hexG.length == 1) hexG = "0" + hexG;
				if (hexB.length == 1) hexB = "0" + hexB;
				var hex = hexR+hexG+hexB;
				return hex;
			}
			//ADD LAYER TO DUGROUP
			Utils.prototype.addLayerToDuGroup = function (layer,group)
			{
				var groupComment = '|' + group + '| ';
				if (layer.comment.indexOf(groupComment) < 0)
				{
				layer.comment = layer.comment + groupComment;
				}
			}
			//RANDOM COLOR
			Utils.prototype.randomColor = function ()
			{
				var color = [0,0,0,1];
				for (var i = 0 ; i < 3 ; i++)
				{
					color[i] = Duik.js.random();
					$.sleep(10);
				}
				return color;
			}
			/**
			 * Gets all the layers with audio in the collection
			 * @param {LayerCollection}	 layers			  An Array or LayerCollection where the audio will be searched
			 * @param {bool}				audioActiveOnly	 If true, does not get muted layers. Default: false
			 * @return {Array}			  An array of AVLayer containing the audio layers
			 */
			Utils.prototype.getAudioLayers = function (layers,audioActiveOnly)
			{
				layers = Utils.prototype.convertCollectionToArray(layers);
				var audioLayers = [];
				for (var i = 0;i < layers.length ; i++)
				{
					if (audioActiveOnly == undefined) audioActiveOnly = false;

					var layer = layers[i];
					if (layer.hasAudio)
					{
						if (audioActiveOnly && layer.audioEnabled || !audioActiveOnly)
						{
							audioLayers.push(layer);
						}
					}
				}
				return audioLayers;
			}

			this.utils = new Utils();
		}

		// AUTORIG
		{
			/**
			 * Contains Duik's Autorig methods
			 * @class Autorig
			 * @memberof LibDuik
			 * @classdesc Contains Duik's Autorig methods
			 */
			function Autorig()
			{
				// DIGITIGRADE
				{
					function Digitigrade(){};

					// DIGITIGRADE FRONT LEG
					Digitigrade.prototype.frontLeg = function (shoulder,humerus,radius,carpus,claws,tiptoe)
					{
						//checks
						if (claws && !humerus) return null;
						if (claws && !radius) return null;
						if ( !carpus) return null;

						//unparent
						if (radius && humerus) radius.parent = null;
						if (carpus && (humerus || tibia)) carpus.parent = null;
						if (claws) claws.parent = null;
						if (tiptoe) tiptoe.parent = null;


						//add nulls and controllers
						var clawsNull, handNull;
						if (claws)
						{
						//claws
						clawsNull = Utils.prototype.addNullOnLayer(claws);
						clawsNull.name = "IK " + claws.name

						var handSize = claws.transform.position.value[0] - carpus.transform.position.value[0];
						//tiptoe
						if (!tiptoe)
						{
						tiptoe = Utils.prototype.addNullOnLayer(claws);
						tiptoe.name = "IK tiptoe " + claws.name
						tiptoe.transform.position.setValue([clawsNull.transform.position.value[0] + handSize,clawsNull.transform.position.value[1]]);
						}

						//foot
						handNull = Utils.prototype.addNullOnLayer(carpus);
						handNull.name = "IK  " + carpus.name;

						if (handSize < 0) clockwise = true;
						}
						//Controller
						var ctrl = Duik.addController(carpus,true,true,true,true,false);
						Duik.addZero(ctrl.layer);

						//parent
						if (claws) claws.parent = carpus;
						if (radius) {
						carpus.parent = radius;
						if (humerus) radius.parent = humerus;
						}
						else if (humerus) carpus.parent = humerus;
						if (claws) {
						handNull.parent = clawsNull;
						clawsNull.parent = tiptoe;
						tiptoe.parent =  ctrl.layer;
						}
						if (shoulder) {
						if (humerus) humerus.parent = shoulder;
						else if (radius) radius.parent = shoulder;
						else carpus.parent = shoulder;
						}



						//IKs
						if (claws) {
						//claws
						Duik.autoIK([claws,tiptoe]);
						//leg
						Duik.autoIK([carpus,radius,humerus,handNull]);
						//foot
						Duik.autoIK([carpus,clawsNull]);
						}
						else {
						if (humerus && radius) Duik.autoIK([carpus,radius,humerus,ctrl.layer]);
						else if (radius) Duik.autoIK([carpus,radius,ctrl.layer]);
						else if (humerus) Duik.autoIK([carpus,humerus,ctrl.layer]);
						}
						if (shoulder) {

						Duik.addZero(shoulder);
						Duik.autoIK([shoulder,ctrl.layer]);
						var ikShoulderCtrl = ctrl.layer.effect(Duik.effects.One_Layer_IK);
						ikShoulderCtrl(1).setValue(50);
						ikShoulderCtrl(3).setValue(-shoulder.transform.rotation.value);
						}

						//Controls
						if (claws) {
						//add an IK effect on the controller
						var ikCtrl = Utils.prototype.addEffect(ctrl.layer,Duik.effects.Two_Layer_IK);
						//the effect on the null of the foot
						var ikEffect = handNull.effect(Duik.effects.Two_Layer_IK);
						ikCtrl.name = ikEffect.name;
						//link the properties
						Utils.prototype.linkProperties(ikEffect,ikCtrl);

						//tiptoe, heel and footroll
						var handCtrl = Utils.prototype.addEffect(ctrl.layer,Duik.effects.Foot_Roll);
						handCtrl.name = carpus.name + " Foot roll";
						tiptoe.transform.rotation.expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(1);";
						clawsNull.transform.rotation.expression = "//Duik.footRoll\n" +
						"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(3);\n" +
						"var tiptoe = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(1);\n" +
						"ctrl-tiptoe;";
						tiptoe.effect(Duik.effects.One_Layer_IK)(3).expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(2);";
						}
						if (shoulder) {
						var shoulderCtrl = ctrl.layer.effect.addProperty("ADBE Slider Control");
						shoulderCtrl.name = shoulder.name + " auto-position %";
						shoulderCtrl(1).setValue(10);

						//get Ctrl position
						var parent = ctrl.layer.parent;
						ctrl.layer.parent = null;
						var posC = ctrl.layer.transform.position.value;
						ctrl.layer.parent = parent;

						//get shoulder position
						parent = shoulder.parent;
						shoulder.parent = null;
						var posS = shoulder.transform.position.value;
						shoulder.parent = parent;

						delete parent;

						var pos = posS-posC;

						shoulder.transform.position.expression = "//Duik.shoulder\n" +
						"var w = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + shoulderCtrl.name + "\")(1);\n" +
						"var z = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
						"var p = thisComp.layer(\"" + ctrl.layer.name + "\").toWorld(thisComp.layer(\"" + ctrl.layer.name + "\").anchorPoint);\n" +
						"((p-z)+" + pos.toSource() + ")* w/100 + value;";
						}

						//hide and lock
						if (claws){
						tiptoe.enabled = false;
						tiptoe.shy = true;
						tiptoe.locked = true;
						clawsNull.enabled = false;
						clawsNull.shy = true;
						clawsNull.locked = true;
						handNull.enabled = false;
						handNull.shy = true;
						handNull.locked = true;
						}

						//select controller
						Utils.prototype.deselectLayers();
						ctrl.layer.selected = true;
						return ctrl;
					}
					// DIGITIGRADE BACK LEG
					Digitigrade.prototype.backLeg = function (femur,tibia,tarsus,claws,tiptoe)
					{
						//checks
						if (claws && !femur) return null;
						if (claws && !tibia) return null;
						if ( !tarsus) return null;

						//unparent
						if (tibia && femur) tibia.parent = null;
						if (tarsus && (tibia || femur)) tarsus.parent = null;
						if (claws) claws.parent = null;
						if (tiptoe) tiptoe.parent = null;

						//add nulls and controllers
						var clawsNull, footNull;
						if (claws)
						{
						//claws
						clawsNull = Utils.prototype.addNullOnLayer(claws);
						clawsNull.name = "IK " + claws.name

						var footSize = claws.transform.position.value[0] - tarsus.transform.position.value[0];
						//tiptoe
						if (!tiptoe)
						{
						tiptoe = Utils.prototype.addNullOnLayer(claws);
						tiptoe.name = "IK tiptoe " + claws.name
						tiptoe.transform.position.setValue([clawsNull.transform.position.value[0] + footSize,clawsNull.transform.position.value[1]]);
						}

						//foot
						footNull = Utils.prototype.addNullOnLayer(tarsus);
						footNull.name = "IK  " + tarsus.name;

						if (footSize > 0) clockwise = true;
						}
						//Controller
						var ctrl = Duik.addController(tarsus,true,true,true,true,false);
						Duik.addZero(ctrl.layer);

						//parent
						if (claws) claws.parent = tarsus;
						if (tibia) {
						tarsus.parent = tibia;
						if (femur) tibia.parent = femur;
						}
						else if (femur) tarsus.parent = femur;
						if (claws) {
						footNull.parent = clawsNull;
						clawsNull.parent = tiptoe;
						tiptoe.parent = ctrl.layer
						}



						//IKs
						if (claws) {
						//claws
						Duik.autoIK([claws,tiptoe]);
						//leg
						Duik.autoIK([tarsus,tibia,femur,footNull]);
						//foot
						Duik.autoIK([tarsus,clawsNull]);
						}
						else {
						if (femur && tibia) Duik.autoIK([tarsus,tibia,femur,ctrl.layer]);
						else if (tibia) Duik.autoIK([tarsus,tibia,ctrl.layer]);
						else if (femur) Duik.autoIK([tarsus,femur,ctrl.layer]);
						}

						//Controls
						if (claws) {
						//add an IK effect on the controller
						var ikCtrl = Utils.prototype.addEffect(ctrl.layer,Duik.effects.Two_Layer_IK);
						//the effect on the null of the foot
						var ikEffect = footNull.effect(Duik.effects.Two_Layer_IK);
						ikCtrl.name = ikEffect.name;
						//link the properties
						Utils.prototype.linkProperties(ikEffect,ikCtrl);

						//tiptoe, heel and footroll
						var footCtrl = Utils.prototype.addEffect(ctrl.layer,Duik.effects.Foot_Roll);
						footCtrl.name = tarsus.name + " Foot roll";
						tiptoe.transform.rotation.expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(1);";
						clawsNull.transform.rotation.expression = "//Duik.footRoll\n" +
						"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(3);\n" +
						"var tiptoe = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(1);\n" +
						"ctrl-tiptoe;";
						tiptoe.effect(Duik.effects.One_Layer_IK)(3).expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(2);";
						}

						//hide and lock
						if (claws){
						tiptoe.enabled = false;
						tiptoe.shy = true;
						tiptoe.locked = true;
						clawsNull.enabled = false;
						clawsNull.shy = true;
						clawsNull.locked = true;
						footNull.enabled = false;
						footNull.shy = true;
						footNull.locked = true;
						}

						//select controller
						Utils.prototype.deselectLayers();
						ctrl.layer.selected = true;
						return ctrl;
					}

					this.digitigrade = new Digitigrade();
				}

				// PLANTIGRADE
				{
					function Plantigrade(){};

					// PLANTIGRADE FRONT LEG
					Plantigrade.prototype.frontLeg = function (shoulder,humerus,radius,carpus,claws,tiptoe,palm)
					{

						//checks
						if (claws && !humerus) return null;
						if (claws && !radius) return null;
						if ( !carpus) return null;


						//unparent
						if (radius && humerus) radius.parent = null;
						if (carpus && (humerus || radius)) carpus.parent = null;
						if (claws) claws.parent = null;
						if (tiptoe) tiptoe.parent = null;
						if (palm) palm.parent = null;

						//orientation
						var right = false;
						if (claws) {
						var clawsPos = Utils.prototype.getWorldPos(claws);
						var carpusPos = Utils.prototype.getWorldPos(carpus);
						right = clawsPos[0] - carpusPos[0] > 0;
						}

						//add nulls and controllers
						var clawsNull, handNull;
						if (claws)
						{
						//claws
						clawsNull = Utils.prototype.addNullOnLayer(claws);
						clawsNull.name = "IK " + claws.name

						var handSize = claws.transform.position.value[0] - carpus.transform.position.value[0];
						//tiptoe
						if (!tiptoe)
						{
						tiptoe = Utils.prototype.addNullOnLayer(claws);
						tiptoe.name = "IK tiptoe " + claws.name
						tiptoe.transform.position.setValue([clawsNull.transform.position.value[0] + handSize,clawsNull.transform.position.value[1]]);
						}

						if (!palm)
						{
						palm = Utils.prototype.addNullOnLayer(claws);
						palm.name = "IK heel " + carpus.name
						palm.transform.position.setValue([carpus.transform.position.value[0],clawsNull.transform.position.value[1]]);
						}

						//foot
						handNull = Utils.prototype.addNullOnLayer(carpus);
						handNull.name = "IK  " + carpus.name;

						if (handSize < 0) clockwise = true;
						}
						//Controller
						var ctrl = Duik.addController(carpus,true,true,true,true,false);
						Duik.addZero(ctrl.layer);

						//parent
						if (claws) claws.parent = carpus;
						if (radius) {
						carpus.parent = radius;
						if (humerus) radius.parent = humerus;
						}
						else if (humerus) carpus.parent = humerus;
						if (claws) {
						handNull.parent = clawsNull;
						clawsNull.parent = tiptoe;
						tiptoe.parent = palm;
						palm.parent = ctrl.layer;
						}
						if (shoulder) {
						if (humerus) humerus.parent = shoulder;
						else if (radius) radius.parent = shoulder;
						else carpus.parent = shoulder;
						}



						//IKs
						if (claws) {
						//claws
						Duik.autoIK([claws,tiptoe]);
						//leg
						Duik.autoIK([carpus,radius,humerus,handNull]);
						//foot
						Duik.autoIK([carpus,clawsNull]);
						}
						else {
						if (humerus && radius) Duik.autoIK([carpus,radius,humerus,ctrl.layer]);
						else if (radius) Duik.autoIK([carpus,radius,ctrl.layer]);
						else if (humerus) Duik.autoIK([carpus,humerus,ctrl.layer]);
						}
						if (shoulder) {

						Duik.addZero(shoulder);
						Duik.autoIK([shoulder,ctrl.layer]);
						var ikShoulderCtrl = ctrl.layer.effect(Duik.effects.One_Layer_IK);
						ikShoulderCtrl(1).setValue(50);
						ikShoulderCtrl(3).setValue(-shoulder.transform.rotation.value);
						}

						//Controls
						if (claws) {

						//add an IK effect on the controller
						var ikCtrl = Utils.prototype.addEffect(ctrl.layer,Duik.effects.Two_Layer_IK);
						//the effect on the null of the foot
						var ikEffect = handNull.effect(Duik.effects.Two_Layer_IK);
						ikCtrl.name = ikEffect.name;
						//link the properties
						Utils.prototype.linkProperties(ikEffect,ikCtrl);

						//tiptoe, heel and footroll
						var handCtrl = Utils.prototype.addEffect(ctrl.layer,Duik.effects.Foot_Roll);
						handCtrl.name = carpus.name + " Foot roll";
						tiptoe.transform.rotation.expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(1);";
						var op  = right ? "<" : ">";
						palm.transform.rotation.expression = "//Duik.footRoll\n" +
						"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(2);\n" +
						"var roll = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(3);\n" +
						"roll " + op + " 0 ? roll+ctrl : ctrl;";
						op = right ? ">" : "<";
						clawsNull.transform.rotation.expression = "//Duik.footRoll\n" +
						"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(3);\n" +
						"ctrl " + op + " 0 ? ctrl : 0;";
						}
						if (shoulder) {
						var shoulderCtrl = ctrl.layer.effect.addProperty("ADBE Slider Control");
						shoulderCtrl.name = shoulder.name + " auto-position %";
						shoulderCtrl(1).setValue(0);

						//get Ctrl position
						var parent = ctrl.layer.parent;
						ctrl.layer.parent = null;
						var posC = ctrl.layer.transform.position.value;
						ctrl.layer.parent = parent;

						//get shoulder position
						parent = shoulder.parent;
						shoulder.parent = null;
						var posS = shoulder.transform.position.value;
						shoulder.parent = parent;

						delete parent;

						var pos = posS-posC;

						shoulder.transform.position.expression = "//Duik.shoulder\n" +
						"var w = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + shoulderCtrl.name + "\")(1);\n" +
						"var z = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
						"var p = thisComp.layer(\"" + ctrl.layer.name + "\").toWorld(thisComp.layer(\"" + ctrl.layer.name + "\").anchorPoint);\n" +
						"((p-z)+" + pos.toSource() + ")* w/100 + value;";
						}

						//hide and lock
						if (claws){
						tiptoe.enabled = false;
						tiptoe.shy = true;
						tiptoe.locked = true;
						palm.enabled = false;
						palm.shy = true;
						palm.locked = true;
						clawsNull.enabled = false;
						clawsNull.shy = true;
						clawsNull.locked = true;
						handNull.enabled = false;
						handNull.shy = true;
						handNull.locked = true;
						}

						//select controller
						Utils.prototype.deselectLayers();
						ctrl.layer.selected = true;
						return ctrl;
					}
					// PLANTIGRADE BACK LEG
					Plantigrade.prototype.backLeg = function (femur,tibia,tarsus,claws,tiptoe,heel)
					{

						//checks
						if (claws && !femur) return null;
						if (claws && !tibia) return null;
						if ( !tarsus) return null;

						//unparent
						if (tibia && femur) tibia.parent = null;
						if (tarsus && (tibia || femur)) tarsus.parent = null;
						if (claws) claws.parent = null;
						if (tiptoe) tiptoe.parent = null;
						if (heel) heel.parent = null;

						//detect right or left
						var right = false;
						if (claws)
						{
							var clawsPos = Utils.prototype.getWorldPos(claws);
							var tarsusPos = Utils.prototype.getWorldPos(tarsus);
							right = (clawsPos[0] - tarsusPos[0]) > 0;
						}




						//add nulls and controllers
						var clawsNull, footNull;
						if (claws)
						{
							//claws
							clawsNull = Utils.prototype.addNullOnLayer(claws);
							clawsNull.name = "IK " + claws.name

							var footSize = claws.transform.position.value[0] - tarsus.transform.position.value[0];
							//tiptoe
							if (!tiptoe)
							{
								tiptoe = Utils.prototype.addNullOnLayer(claws);
								tiptoe.name = "IK tiptoe " + claws.name
								tiptoe.transform.position.setValue([clawsNull.transform.position.value[0] + footSize,clawsNull.transform.position.value[1]]);
							}

							if (!heel)
							{
								heel = Utils.prototype.addNullOnLayer(claws);
								heel.name = "IK heel " + tarsus.name
								heel.transform.position.setValue([tarsus.transform.position.value[0],clawsNull.transform.position.value[1]]);
							}

							//foot
							footNull = Utils.prototype.addNullOnLayer(tarsus);
							footNull.name = "IK  " + tarsus.name;

							if (footSize > 0) clockwise = true;
						}
						//Controller
						var ctrl = Duik.addController(tarsus,true,true,true,true,false);
						Duik.addZero(ctrl.layer);

						//parent
						if (claws) claws.parent = tarsus;
						if (tibia)
						{
							tarsus.parent = tibia;
							if (femur) tibia.parent = femur;
						}
						else if (femur) tarsus.parent = femur;
						if (claws)
						{
							footNull.parent = clawsNull;
							clawsNull.parent = tiptoe;
							tiptoe.parent = heel;
							heel.parent = ctrl.layer;
						}



						//IKs
						if (claws)
						{
							//claws
							Duik.autoIK([claws,tiptoe]);
							//leg
							Duik.autoIK([tarsus,tibia,femur,footNull]);
							//foot
							Duik.autoIK([tarsus,clawsNull]);
						}
						else {
							if (femur && tibia) Duik.autoIK([tarsus,tibia,femur,ctrl.layer]);
							else if (tibia) Duik.autoIK([tarsus,tibia,ctrl.layer]);
							else if (femur) Duik.autoIK([tarsus,femur,ctrl.layer]);
						}

						//Controls
						if (claws) {

							//add an IK effect on the controller
							var ikCtrl = Utils.prototype.addEffect(ctrl.layer,Duik.effects.Two_Layer_IK);
							//the effect on the null of the foot
							var ikEffect = footNull.effect(Duik.effects.Two_Layer_IK);
							ikCtrl.name = ikEffect.name;
							//link the properties
							Utils.prototype.linkProperties(ikEffect,ikCtrl);

							//tiptoe, heel and footroll
							var footCtrl = Utils.prototype.addEffect(ctrl.layer,Duik.effects.Foot_Roll);
							footCtrl.name = tarsus.name + " Foot roll";
							tiptoe.transform.rotation.expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(1);";
							var op  = right ? "<" : ">";
							heel.transform.rotation.expression = "//Duik.footRoll\n" +
							"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(2);\n" +
							"var roll = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(3);\n" +
							"roll " + op + " 0 ? roll+ctrl : ctrl;";
							op  = right ? ">" : "<";
							clawsNull.transform.rotation.expression = "//Duik.footRoll\n" +
							"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(3);\n" +
							"ctrl " + op + " 0 ? ctrl : 0;";
						}

						//hide and lock
						if (claws){
							tiptoe.enabled = false;
							tiptoe.shy = true;
							tiptoe.locked = true;
							heel.enabled = false;
							heel.shy = true;
							heel.locked = true;
							clawsNull.enabled = false;
							clawsNull.shy = true;
							clawsNull.locked = true;
							footNull.enabled = false;
							footNull.shy = true;
							footNull.locked = true;
						}

						//select controller
						Utils.prototype.deselectLayers();
						ctrl.layer.selected = true;
						return ctrl;
					}

					this.plantigrade = new Plantigrade();
				}

				// UNGULATE
				{
					function Ungulate(){};

					// UNGULATE FRONT LEG
					Ungulate.prototype.frontLeg = function (shoulder,humerus,radius,carpus,claws)
					{
						//checks
						if (claws && !humerus) return null;
						if (claws && !radius) return null;
						if ( !carpus) return null;

						//unparent
						if (radius && humerus) radius.parent = null;
						if (carpus && (humerus || tibia)) carpus.parent = null;
						if (claws) claws.parent = null;

						//Controller
						var ctrl;
						if (claws)  ctrl = Duik.addController(claws,true,true,true,true,false);
						else ctrl = Duik.addController(carpus,true,true,true,true,false);
						Duik.addZero(ctrl.layer);

						//parent
						if (claws) claws.parent = carpus;
						if (radius) {
						carpus.parent = radius;
						if (humerus) radius.parent = humerus;
						}
						else if (humerus) radius.parent = humerus;
						if (shoulder) {
						if (humerus) humerus.parent = shoulder;
						else if (radius) radius.parent = shoulder;
						else carpus.parent = shoulder;
						}


						//IKs
						if (claws) {
						//claws
						Duik.autoIK([claws,carpus,radius,ctrl.layer]);
						//leg
						Duik.autoIK([humerus,ctrl.layer]);
						}
						else {
						if (humerus && radius) Duik.autoIK([carpus,radius,humerus,ctrl.layer]);
						else if (radius) Duik.autoIK([carpus,radius,ctrl.layer]);
						else if (humerus) Duik.autoIK([carpus,humerus,ctrl.layer]);
						}
						if (shoulder) {

						Duik.addZero(shoulder);
						Duik.autoIK([shoulder,ctrl.layer]);
						var ikShoulderCtrl = ctrl.layer.effect(Duik.uiStrings.ik + " "  + shoulder.name);
						ikShoulderCtrl(1).setValue(50);
						ikShoulderCtrl(3).setValue(-shoulder.transform.rotation.value);
						}

						//Controls
						if (shoulder) {
						var shoulderCtrl = ctrl.layer.effect.addProperty("ADBE Slider Control");
						shoulderCtrl.name = shoulder.name + " auto-position %";
						shoulderCtrl(1).setValue(10);

						//get Ctrl position
						var parent = ctrl.layer.parent;
						ctrl.layer.parent = null;
						var posC = ctrl.layer.transform.position.value;
						ctrl.layer.parent = parent;

						//get shoulder position
						parent = shoulder.parent;
						shoulder.parent = null;
						var posS = shoulder.transform.position.value;
						shoulder.parent = parent;

						delete parent;

						var pos = posS-posC;

						shoulder.transform.position.expression = "//Duik.shoulder\n" +
						"var w = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + shoulderCtrl.name + "\")(1);\n" +
						"var z = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
						"var p = thisComp.layer(\"" + ctrl.layer.name + "\").toWorld(thisComp.layer(\"" + ctrl.layer.name + "\").anchorPoint);\n" +
						"((p-z)+" + pos.toSource() + ")* w/100 + value;";
						}

						//select controller
						Utils.prototype.deselectLayers();
						ctrl.layer.selected = true;
						return ctrl;
					}
					// UNGULATE BACK LEG
					Ungulate.prototype.backLeg = function (femur,tibia,tarsus,claws)
					{
						//checks
						if (claws && !femur) return null;
						if (claws && !tibia) return null;
						if ( !tarsus) return null;

						//unparent
						if (tibia && femur) tibia.parent = null;
						if (tarsus && (tibia || femur)) tarsus.parent = null;
						if (claws) claws.parent = null;

						//Controller
						var ctrl;
						if (claws)  ctrl = Duik.addController(claws,true,true,true,true,false);
						else ctrl = Duik.addController(tarsus,true,true,true,true,false);
						Duik.addZero(ctrl.layer);

						//parent
						if (claws) claws.parent = tarsus;
						if (tibia) {
						tarsus.parent = tibia;
						if (femur) tibia.parent = femur;
						}
						else if (femur) tarsus.parent = femur;

						//IKs
						if (claws) {
						//claws
						Duik.autoIK([claws,tarsus,tibia,ctrl.layer]);
						//leg
						Duik.autoIK([femur,ctrl.layer]);
						}
						else {
						if (femur && tibia) Duik.autoIK([tarsus,tibia,femur,ctrl.layer],clockwise);
						else if (tibia) Duik.autoIK([tarsus,tibia,ctrl.layer]);
						else if (femur) Duik.autoIK([tarsus,femur,ctrl.layer]);
						}

						//select controller
						Utils.prototype.deselectLayers();
						ctrl.layer.selected = true;
						return ctrl;
					}

					this.ungulate = new Ungulate();
				}
			};

			// SPINE
			Autorig.prototype.spine = function (hips,back,neck,head)
			{
				if (!head) return null;
				if (!hips && !back) return null;

				if (neck) if (neck.length == 0) neck = null;
				if (back) if (back.length == 0) back = null;

				//unparent
				var hipsParent = null;
				if (hips) {
				hipsParent = hips.parent;
				hips.parent = null;
				}
				if (back) for (var i=0;i<back.length;i++ ) back[i].parent = null;
				if (neck) for (var i=0;i<neck.length;i++ ) neck[i].parent = null;
				if (head) head.parent = null;

				var controllers = [];

				//controllers
				var hipsCtrl = null;
				var bigHipsCtrl = null;
				var shoulderCtrl = null;
				var headCtrl = null;
				if (hips) {
				bigHipsCtrl = Duik.addController(hips,true,true,true,true,false);
				hipsCtrl = Duik.addController(bigHipsCtrl.layer,true,true,true,true,false);
				bigHipsCtrl.size = bigHipsCtrl.size*1.5;
				bigHipsCtrl.color = bigHipsCtrl.color *0.5;
				bigHipsCtrl.update();

				}
				else if (back) {
				bigHipsCtrl = Duik.addController(back[back.length-1],true,true,true,true,false);
				hipsCtrl = Duik.addController(bigHipsCtrl.layer,true,true,true,true,false);
				bigHipsCtrl.size = bigHipsCtrl.size*1.5;
				bigHipsCtrl.color = bigHipsCtrl.color *0.5;
				bigHipsCtrl.update();
				}
				controllers.push(bigHipsCtrl);
				controllers.push(hipsCtrl);
				if (neck) {
				shoulderCtrl = Duik.addController(neck[neck.length-1],true,true,true,true,false);
				shoulderCtrl.layer.name = "C_Shoulders";
				controllers.push(shoulderCtrl);
				headCtrl = Duik.addController(head,false,true,false,false,false);
				}
				else
				{
					headCtrl = Duik.addController(head,false,true,true,true,false);
				}
				controllers.push(headCtrl);

				//parent
				//bones
				if (hips) {
				hips.parent = hipsCtrl.layer;
				}
				if (back) {
				if (!hips) back[back.length-1].parent = hipsCtrl.layer;
				else back[back.length-1].parent = hips;
				}
				if (neck) {
				if (back) neck[neck.length-1].parent = back[0];
				else neck[neck.length-1].parent = hips;
				for (var i = 0;i<neck.length-1;i++) {
				neck[i].parent = neck[i+1];
				}
				}
				if (head) {
				if (neck) head.parent = neck[0];
				else if (back) head.parent = back[0];
				else if (hips) head.parent = hips;
				}
				//controllers
				bigHipsCtrl.layer.parent = hipsParent;
				hipsCtrl.layer.parent = bigHipsCtrl.layer;
				if (shoulderCtrl) {
				shoulderCtrl.layer.parent = bigHipsCtrl.layer;
				headCtrl.layer.parent = shoulderCtrl.layer;
				}
				else {
				headCtrl.layer.parent = bigHipsCtrl.layer;
				}
				headCtrl.lock();

				//IK
				if (hips && !back) {
				if (shoulderCtrl) Duik.autoIK([hips,shoulderCtrl.layer]);
				else Duik.autoIK([hips,headCtrl.layer]);
				}
				else if (back.length == 1) {
				if (shoulderCtrl) Duik.autoIK([back[0],shoulderCtrl.layer]);
				else Duik.autoIK([back[0],headCtrl.layer]);
				}
				else {
				var bezLayers = back;
				var rootNull = Utils.prototype.addNullOnLayer(back[back.length-1]);
				rootNull.parent = hipsCtrl.layer;
				rootNull.name = "IK " + back[back.length-1].name;
				if (shoulderCtrl) bezLayers.push(shoulderCtrl.layer);
				else bezLayers.push(headCtrl.layer);
				bezLayers.push(rootNull);
				var backCurveCtrl = Duik.bezierIK(bezLayers);
				backCurveCtrl.layer.parent = bigHipsCtrl.layer;
				controllers.push(backCurveCtrl);
				rootNull.shy = true;
				rootNull.enabled = false;
				rootNull.locked = true;
				delete bezLayers;
				}

				//controls
				//neck
				if (neck) {
				var goalCtrl;
				var goalCtrlLayerName = "";
				if (shoulderCtrl) {
				goalCtrl = shoulderCtrl.layer.effect.addProperty("ADBE Checkbox Control");
				goalCtrlLayerName = shoulderCtrl.layer.name;
				}
				else {
				goalCtrl = headCtrl.layer.effect.addProperty("ADBE Checkbox Control");
				goalCtrlLayerName = headCtrl.layer.name;
				}
				goalCtrl.name = neck[neck.length-1].name + " goal";
				goalCtrl(1).setValue(1);

				for (var i=0;i<neck.length;i++ )
				{
					var l = neck[i];
					var torsoName = "";
					var torsoRot = 0;
					var torsoCount = 1;
					if (back)
					{
						torsoName = back[0].name;
						torsoRot = back[0].transform.rotation.value;
						torsoCount = back.length;
					}
					else
					{
						torsoName = hips.name;
						torsoRot = hips.transform.rotation.value;
					}
					var hipsName = hipsCtrl.layer.name;
					var exp = "//Duik.neck\n" +
					"var goal = thisComp.layer(\"" + goalCtrlLayerName + "\").effect(\"" + goalCtrl.name + "\")(1) == 1;\n" +
					"var torso = thisComp.layer(\"" + torsoName + "\").rotation;\n" +
					"var hips = thisComp.layer(\"" + hipsName + "\").rotation;\n" +
					"var ctrl = thisComp.layer(\"" + shoulderCtrl.layer.name + "\").rotation;\n" +
					"var numNeckLayers = " + neck.length + ";\n" +
					"var numTorsoLayers = " + torsoCount + ";\n" +
					"var result = value;\n" +
					"result = result + ctrl/numNeckLayers;\n" +
					"if (numTorsoLayers == 1) torso = torso + hips;\n" +
					"if (torso < 180+" + torsoRot + ") torso += 360;\n" +
					"goal ? result-torso/numNeckLayers+(360+" + torsoRot + ")/numNeckLayers : result;";

					l.transform.rotation.expression = exp;
				}
				}

				//head
				Duik.goal(head,headCtrl.layer);

				return controllers;

			}
			// TAIL
			Autorig.prototype.tail = function (hips,tail,cubic)
			{
				if (!hips) return;
				if (!tail) return;
				if (!tail.length) return;

				if (cubic == undefined) cubic = false;

				//unparent
				for (var i=0;i<tail.length;i++ ) tail[i].parent = null;

				var controllers = [];

				//controllers
				var tailCtrl = Duik.addController(tail[0],false,false,true,true,false);
				controllers.push(tailCtrl);

				var tailCtrlPos = [0,0,0];
				var endPos = tail[tail.length-1].transform.position.value;
				var prevPos = tail.length > 1 ? tail[tail.length-2].transform.position.value : hips.transform.position.value;

				tailCtrlPos = endPos + [endPos[0]-prevPos[0],endPos[1]-prevPos[1],0];

				tailCtrl.layer.transform.position.setValue(tailCtrlPos);

				//IK
				var numCtrl = cubic ? 2 : 1;
				var rootNull = Utils.prototype.addNullOnLayer(tail[0]);
				rootNull.parent = hips;
				rootNull.name = "IK " + tail[0].name;
				var bezLayers = tail.reverse();
				bezLayers.push(tailCtrl.layer);
				bezLayers.push(rootNull);
				var curveCtrls = Duik.bezierIK(bezLayers,numCtrl);

				rootNull.shy = true;
				rootNull.enabled = false;
				rootNull.locked = true;

				controllers = controllers.concat(curveCtrls);

				tailDialog.hide();
				return controllers;
			}

			this.autorig = new Autorig();
		}

		/**
		 * This block checks if Duik (and the pseudo effects) has been correctly installed
		 * This is going to change a lot issue #295
		 */
		{
			//=======================
			//===== METHODS =========
			//=======================

			/*
				if (typeof this.setup !== 'object')
				{
					this.setup = {};
					//Duik.setup.presetEffects String
					{
						this.setup.presetEffects = "<!-- BEGIN DUIK PSEUDO EFFECTS v15.5 -->\r\n" +
								"<Effect matchname='PSEUDO/DUIK_One_Layer_IK' name='$$$/AE/Preset/1ik=DUIK_One_Layer_IK'>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikWeight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='true'/>\r\n" +
								"	<Angle name='$$$/AE/Preset/DuikFK=FK' default='0'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Two_Layer_IK_v2' name='$$$/AE/Preset/2ik=DUIK_Two_Layer_IK'>\r\n" +
								"	<Checkbox name='$$$/AE/Preset/DuikClockwise=Clockwise' default='false'/>\r\n" +
								"	<Group name='$$$/AE/Preset/DuikFK=FK'>\r\n" +
								"		<Checkbox name='$$$/AE/Preset/DuikDisableIK=Disable IK' default='false'/>\r\n" +
								"		<Angle name='$$$/AE/Preset/DuikUpperFK=Upper FK' default='0'/>\r\n" +
								"		<Angle name='$$$/AE/Preset/DuikLowerFK=Lower FK' default='0'/>\r\n" +
								"	</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/Stretch=Stretch'>\r\n" +
								"		<Checkbox name='$$$/AE/Preset/DuikAuto-Stretch=Auto-Stretch' default='true'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikStretch=Stretch' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikAuto-Shrink=Auto-Shrink' default='10' valid_min='-150' valid_max='100' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"	</Group>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Three_Layer_IK_v2' name='$$$/AE/Preset/2ik=DUIK_Three_Layer_IK'>\r\n" +
								"	<Checkbox name='$$$/AE/Preset/DuikClockwise=Clockwise' default='false'/>\r\n" +
								"	<Group name='$$$/AE/Preset/DuikFK=FK'>\r\n" +
								"		<Checkbox name='$$$/AE/Preset/DuikDisableIK=Disable IK' default='false'/>\r\n" +
								"		<Angle name='$$$/AE/Preset/DuikUpperFK=Upper FK' default='0'/>\r\n" +
								"		<Angle name='$$$/AE/Preset/DuikMiddleFK=Middle FK' default='0'/>\r\n" +
								"		<Angle name='$$$/AE/Preset/DuikLowerFK=Lower FK' default='0'/>\r\n" +
								"	</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/Stretch=Stretch'>\r\n" +
								"		<Checkbox name='$$$/AE/Preset/DuikAuto-Stretch=Auto-Stretch' default='true'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikStretch=Stretch' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikAuto-Shrink=Auto-Shrink' default='10' valid_min='-150' valid_max='100' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"	</Group>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_3D_Wiggle' name='$$$/AE/Preset/3dwiggle=DUIK_3D_Wiggle'>\r\n" +
								"	<Group name='$$$/AE/Preset/DuikAmplitudes=Amplitudes'>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikXAmp=X Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikYAmp=Y Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikZAmp=Z Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
								"	</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/DuikFrequencies=Frequencies'>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikXFrequ=X Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikYFreq=Y Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikZFreq=Z Freq' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"	</Group>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_2D_Wiggle' name='$$$/AE/Preset/2dwiggle=DUIK_2D_Wiggle'>\r\n" +
								"	<Group name='$$$/AE/Preset/DuikAmplitudes=Amplitudes'>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikXAmp=X Amp.' default='0' valid_min='0' valid_max='10000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikYAmp=Y Amp.' default='0' valid_min='0' valid_max='10000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
								"	</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/DuikFrequencies=Frequencies'>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikXFreq=X Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikYFreq=Y Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"	</Group>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_1D_Wiggle' name='$$$/AE/Preset/1dwiggle=DUIK_1D_Wiggle'>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikAmplitude=Amplitude' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikFrequency=Frequency' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Exposure' name='$$$/AE/Preset/exposure=DUIK_Exposure'>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikExposure=Exposure (frames)' default='1' valid_min='1' valid_max='1000' slider_min='1' slider_max='30' precision='1'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_RotMorph' name='$$$/AE/Preset/rotmorph=DUIK_RotMorph'>\r\n" +
								"	<Layer name='$$$/AE/Preset/DuikReferenceLayer=Reference Layer' default_self='true'/>\r\n" +
								"	<Angle name='$$$/AE/Preset/DuikMin.Angle=Min. Angle' default='0'/>\r\n" +
								"	<Angle name='$$$/AE/Preset/DuikMax.Angle=Max. Angle' default='0'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Swing' name='$$$/AE/Preset/swing=DUIK_Swing'>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikAmplitude=Amplitude' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikFrequency=Frequency' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='50' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikOffset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikDamping=Damping' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Wheel' name='$$$/AE/Preset/wheel=DUIK_Wheel'>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikRadius=Radius' default='100' valid_min='1' valid_max='10000' slider_min='1' slider_max='1000' precision='1'/>\r\n" +
								"	<Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='false'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_LensFlare' name='$$$/AE/Preset/lensflare=DUIK_LensFlare'>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikIntensity=Intensity' default='100' valid_min='0' valid_max='1000' slider_min='0' slider_max='200' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikScale=Scale' default='100' valid_min='0' valid_max='1000' slider_min='0' slider_max='200' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_LensFlareDistance' name='$$$/AE/Preset/lensflaredistance=DUIK_LensFlareDistance'>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikDistance=Distance' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_DistanceLink' name='$$$/AE/Preset/distancelink=DUIK_DistanceLink'>\r\n" +
								"	<Group name='$$$/AE/Preset/DuikRange=Range'>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikMinimumDistance=Minimum Distance' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
								"		<Slider name='$$$/AE/Preset/DuikMaximumDistance=Maximum Distance' default='500' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
								"	</Group>\r\n" +
								"	<Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='false'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikFalloff=Falloff' default='10' valid_min='0' valid_max='1000' slider_min='0' slider_max='100' precision='1'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Spring' name='$$$/AE/Preset/spring=DUIK_Spring'>\r\n" +
								"   <Slider name='$$$/AE/Preset/DuikElasticity=Elasticity' default='10' valid_min='0' valid_max='100' slider_min='0' slider_max='25' precision='1'/>\r\n" +
								"   <Slider name='$$$/AE/Preset/DuikDamping=Damping' default='5' valid_min='0' valid_max='100' slider_min='0' slider_max='20' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikSpeedLimit=Trigger speed' default='0.1' valid_min='0' valid_max='1000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Spring_Bounce' name='$$$/AE/Preset/springbounce=DUIK_Spring_Bounce'>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikElasticity=Elasticity' default='10' valid_min='0' valid_max='100' slider_min='0' slider_max='25' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikDamping=Damping' default='5' valid_min='0' valid_max='100' slider_min='0' slider_max='20' precision='1'/>\r\n" +
								"	<Checkbox name='$$$/AE/Preset/DuikBounce=Bounce' default='false'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/DuikSpeedLimit=Trigger speed' default='0.1' valid_min='0' valid_max='1000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Paint_Rig' name='$$$/AE/Preset/DUIK_Paint_Rig=DUIK_Paint_Rig'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Start=Start' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/End=End' default='100' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Diameter=Diameter' default='0' valid_min='-1000' valid_max='10000' slider_min='-100' slider_max='100' precision='0'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Blink_1D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_1D'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Offvalue=Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Blink_2D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_2D'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/xOffvalue=X Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/yOffvalue=Y Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Blink_3D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_3D'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/xOffvalue=X Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/yOffvalue=Y Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/zOffvalue=Z Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Multiplane\' name='$$$/AE/Preset/DUIK_Multiplane=DUIK_Multiplane'>\r\n" +
								"	<Point name='$$$/AE/Preset/Pan=Pan' default_x='0.5' default_y='0.5'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Zoom=Zoom' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/TruckInOut=Truck In Out' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Angle name='$$$/AE/Preset/Tilt=Tilt' default='0.0'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Paint_Group' name='$$$/AE/Preset/DUIK_Paint_Group=DUIK_Paint_Group'>\r\n" +
								"<Group name='$$$/AE/Preset/StrokeOptions=Stroke Options'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Start=Start' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/End=End' default='100' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Color name='$$$/AE/Preset/Color=Color' default_red='255' default_green='0' default_blue='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Diameter=Diameter' default='0' valid_min='-32000' valid_max='32000' slider_min='-100' slider_max='100' precision='1'/>\r\n" +
								"</Group>\r\n" +
								"<Group name='$$$/AE/Preset/Transform=Transform'>\r\n" +
								"	<Point name='$$$/AE/Preset/AnchorPoint=Anchor Point' default_x='0.5' default_y='0.5'/>\r\n" +
								"	<Point name='$$$/AE/Preset/Position=Position' default_x='0.5' default_y='0.5'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Scale=Scale' default='100' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Angle name='$$$/AE/Preset/Rotation=Rotation' default='0.0'/>\r\n" +
								"</Group>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_1D_List' name='$$$/AE/Preset/DUIK_1D_List=DUIK_1D_List'>\r\n" +
								"<Group name='$$$/AE/Preset/1=1'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/2=2'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/3=3'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/4=4'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/5=5'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_2D_List' name='$$$/AE/Preset/DUIK_2D_List=DUIK_2D_List'>\r\n" +
								"<Group name='$$$/AE/Preset/1=1'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"<Group name='$$$/AE/Preset/2=2'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"<Group name='$$$/AE/Preset/3=3'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"<Group name='$$$/AE/Preset/4=4'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"<Group name='$$$/AE/Preset/5=5'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_3D_List' name='$$$/AE/Preset/DUIK_3D_List=DUIK_3D_List'>\r\n" +
								"<Group name='$$$/AE/Preset/1=1'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/2=2'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/3=3'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/4=4'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"	<Group name='$$$/AE/Preset/5=5'>\r\n" +
								"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
								"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
								"</Group>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Bezier_IK' name='$$$/AE/Preset/DUIK_Bezier_IK=DUIK_Bezier_IK'>\r\n" +
								"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
								"	<Checkbox name='$$$/AE/Preset/AutoOrientation=Auto Orientation' default='true'/>\r\n" +
								"</Effect>\r\n" +
								"<Effect matchname='PSEUDO/DUIK_Foot_Roll' name='$$$/AE/Preset/DUIK_Foot_Roll=DUIK_Foot_Roll'>\r\n" +
								"	<Angle name='$$$/AE/Preset/Tiptoe=Tiptoe' default='0.0'/>\r\n" +
								"	<Angle name='$$$/AE/Preset/Heel=Heel' default='0.0'/>\r\n" +
								"	<Angle name='$$$/AE/Preset/FootRoll=Foot roll' default='0.0'/>\r\n" +
								"</Effect>\r\n" +
								"<!-- END DUIK PSEUDO EFFECTS -->\r\n";
					}
					// INSTALL PSEUDO EFFECTS - Duik.setup.installCustomEffects();
					this.setup.installPseudoEffects = function ()
					{
						//-------------------------------------------------------------
						//------ Edit presetEffects.xml to add Duik Effects -----------
						//-------------------------------------------------------------
						if (this.allowedToWriteFiles && this.presetEffectsInstalledVersion < this.versionNumber)
						{
						var appPath = Folder.appPackage.fsName;
						var presetEffectsFile = new File(appPath + "\\PresetEffects.xml");
						if (Duik.mac) presetEffectsFile = new File(appPath + "/Contents/Resources/PresetEffects.xml");
						if (presetEffectsFile.exists)
						{
						presetEffectsFile.open("r","TEXT");
						var presetEffectsString = presetEffectsFile.read();
						presetEffectsFile.close();
						//update
						var startIndex = presetEffectsString.indexOf("<!-- BEGIN DUIK PSEUDO EFFECTS v");
						var endIndex = presetEffectsString.indexOf("<!-- END DUIK PSEUDO EFFECTS -->") + 32;
						if (startIndex >= 0)
						{
						var stringToRemove = presetEffectsString.substring(startIndex,endIndex);
						presetEffectsString = presetEffectsString.replace(stringToRemove,Duik.setup.presetEffects);
						}
						else
						{
						presetEffectsString = presetEffectsString.replace("</Effects>",Duik.setup.presetEffects + "\r\n</Effects>");
						}
						//gets write access
						if (Duik.mac)
						{
						var cmd = "chmod u+rw  " + "\"" + appPath + "/PresetEffects.xml\"";
						system.callSystem(cmd);
						}
						else
						{
						var cmd = "cmd /c attrib -r /S /D \"" + appPath + "\"";
						system.callSystem(cmd);
						cmd = "cmd /c attrib -r /S /D \"" + appPath + "\\PresetEffects.xml\"";
						system.callSystem(cmd);
						}
						//backup file
						presetEffectsFile.copy(presetEffectsFile.fullName + ".bak");
						//write the new file
						var isReadOnly = presetEffectsFile.readonly;
						presetEffectsFile.readonly = false;
						presetEffectsFile.open("w","TEXT");
						presetEffectsFile.write(presetEffectsString);
						presetEffectsFile.close();
						presetEffectsFile.readonly = isReadOnly;
						}
						Duik.setup.checkPresetEffectsVersion();
						}
					}
					Duik.setup.checkPresetEffectsVersion = function ()
					{
						var presetEffectsFile = new File(Folder.appPackage.absoluteURI + "/PresetEffects.xml");
						if ($.os.toLowerCase().indexOf("mac") >= 0) presetEffectsFile = new File(Folder.appPackage.absoluteURI + "/Contents/Resources/PresetEffects.xml");
						Duik.presetEffectsInstalledVersion = 0;
						if (presetEffectsFile.exists)
						{
						presetEffectsFile.open("r","TEXT");
						var presetEffectsString = presetEffectsFile.read();
						presetEffectsFile.close();
						//find version
						var startIndex = presetEffectsString.indexOf("<!-- BEGIN DUIK PSEUDO EFFECTS v");
						if (startIndex >= 0)
						{
						startIndex += 32 ;
						Duik.presetEffectsInstalledVersion = parseFloat(presetEffectsString.substr(startIndex,7));
						}
						}
					}

				}
			*/

			// PRESETEFFECTS.XML CHECKING DISBALED
			// Github issue #295
			// Will only use ffx files instead, and just keep a method to install pseudo effects if the user wants it

			// needs to set Duik.usePresets to false right now so that Duik continues to work
			// this will be removed too
			this.usePresets = false;

			/* PRESETEFFECTS.XML CHECKING DISBALED Github issue #295
				//-----------------------------------------------------------------
				//--------- Check if presetEffects.xml is up-to-date --------------
				//-----------------------------------------------------------------
				//
				Duik.setup.checkPresetEffectsVersion();
				if (Duik.presetEffectsInstalledVersion == Duik.versionNumber)
				{
					Duik.usePresets = false;
				}

				//-----------------------------------------------------------------
				//--------- Check if scripts are allowed to write files -----------
				//-----------------------------------------------------------------
				Duik.allowedToWriteFiles = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;

				//-----------------------------------------------------------------
				//------------------------------ INSTALL --------------------------
				//-----------------------------------------------------------------
				if (Duik.usePresets)
				{
					Duik.setup.installPseudoEffects();
				}
			*/
		}
	}

	// LIBDUIK MAIN methods
	{
		/*	ADD IK - Duik.autoIK(layers,frontFacing)
		adds an IK to the layers

		parameters:
		layers | Array of AVLayers or LayerCollection
		clockWise | boolean, used only with two-layer and three-layer IK, default: false
		frontFacing | boolean, default: false

		returns
		IKRig object
		*/
		LibDuik.prototype.autoIK = function (layers,frontFacing)
		{
			if (frontFacing == undefined) frontFacing = false;

			var ik = Utils.prototype.prepIK(layers);
			ik.frontFacing = frontFacing;
			ik.create();

			return ik;
		}
		/**
		 * Creates a Bézier IK
		 * @memberof LibDuik
		 * @param {Array}		layers			- An Array of layers which will be in the Bezier IK.
		 * @param {number}		numControllers	- The number of controllers for the curvature, 1 by default.
		 * @param {bool}		lockAndShy		- Wether to lock and shy layers after IK creation or not. Default : Duik.settings.lockAndShy
		 * @return {Array}		An array containing one or two controllers created for the curvature
		 */
		LibDuik.prototype.bezierIK = function (layers,numControllers,lockAndShy)
		{
			if (layers == undefined) return;
			if (layers.length < 3) return;
			if (numControllers == undefined) numControllers = 1;
			if (lockAndShy == undefined) lockAndShy = Duik.settings.lockAndShy;

			var endController = layers[layers.length-2];
			var rootController = layers[layers.length-1];

			var endParent = endController.parent;
			var rootParent = rootController.parent;

			//get controller positions
			endController.parent = null;
			rootController.parent = null;
			var endPosition = endController.transform.position.value;
			var rootPosition = rootController.transform.position.value;
			endController.parent = endParent;
			rootController.parent = rootParent;

			Utils.prototype.checkNames(endController.containingComp);

			//create curvature controllers
			var curveCtrl1 = Duik.addController(endController,false,false,true,true,false);
			curveCtrl1.layer.name = endController.name + "_curve";


			if (numControllers == 1)
			{
				curveCtrl1.layer.transform.position.setValue((endPosition+rootPosition)/2);
			}
			else
			{
				var curveCtrl2 = Duik.addController(rootController,false,false,true,true,false);
				curveCtrl2.layer.name = rootController.name + "_curve";
				curveCtrl1.layer.transform.position.setValue((2*endPosition+rootPosition)/3);
				curveCtrl2.layer.transform.position.setValue((endPosition+2*rootPosition)/3);
			}

			//pseudo effect
			var effect;
			effect = Utils.prototype.addEffect(endController,Duik.effects.Bezier_IK);
			effect.name = Duik.uiStrings.bezierIK + " "  + endController.name;

			//create expressions
			var prevLayerName = "";
			for (var i = 0 ; i<layers.length-2;i++)
			{
				var layer = layers[i];
				layer.parent = null;
				if (i == 0) prevLayerName = endController.name;
				//offset cursor
				var offsetEffect = layer.Effects.addProperty("ADBE Slider Control");
				offsetEffect.name = Duik.uiStrings.bezierIKOffset;
				//index
				var index = i/(layers.length-2)+1.5/layers.length;

				//position
				var opos = layer.transform.position.value;
				if (numControllers == 1)
				{
					layer.transform.position.expression = "//Duik.bezierIK\n" +
					"var end = thisComp.layer(\"" + endController.name + "\");\n" +
					"var root = thisComp.layer(\"" + rootController.name + "\");\n" +
					"var curve = thisComp.layer(\"" + curveCtrl1.layer.name + "\");\n" +
					"var ind = " + index + ";\n" +
					"var offset = effect(\"" + offsetEffect.name + "\")(1)/100;\n" +
					"var generalOffset = end.effect(\"" + effect.name + "\")(1)/100;\n" +
					"var endPosition = end.toComp(end.anchorPoint);\n" +
					"var rootPosition = root.toComp(root.anchorPoint);\n" +
					"var curvePosition = curve.toComp(curve.anchorPoint);\n" +
					"var t = ind + generalOffset + offset;\n" +
					"result = ((1-t)*(1-t))*endPosition+2*t*(1-t)*curvePosition+t*t*rootPosition;\n" +
					"result + value - " + layer.transform.position.value.toSource() + ";";
				}
				else
				{
					layer.transform.position.expression = "//Duik.bezierIK\n" +
					"var end = thisComp.layer(\"" + endController.name + "\");\n" +
					"var root = thisComp.layer(\"" + rootController.name + "\");\n" +
					"var curve1 = thisComp.layer(\"" + curveCtrl1.layer.name + "\");\n" +
					"var curve2 = thisComp.layer(\"" + curveCtrl2.layer.name + "\");\n" +
					"var ind = " + index + ";\n" +
					"var offset = effect(\"" + offsetEffect.name + "\")(1)/100;\n" +
					"var generalOffset = end.effect(\"" + effect.name + "\")(1)/100;\n" +
					"var endPosition = end.toComp(end.anchorPoint);\n" +
					"var rootPosition = root.toComp(root.anchorPoint);\n" +
					"var curvePosition1 = curve1.toComp(curve1.anchorPoint);\n" +
					"var curvePosition2 = curve2.toComp(curve2.anchorPoint);\n" +
					"var t = ind + generalOffset + offset;\n" +
					"var c = 3*(curvePosition1 - endPosition);\n" +
					"var b = 3*(curvePosition2 - curvePosition1) - c;\n" +
					"var a = rootPosition - endPosition - c - b;\n" +
					"result = ((a*t +b )*t + c)*t + endPosition ;\n" +
					"result + value - " + layer.transform.position.value.toSource() + ";";
				}

				var npos = layer.transform.position.value;
				layer.transform.position.setValue(-npos+2*opos);

				//rotation
				var orot = layer.transform.rotation.value;
				layer.transform.rotation.expression = "//Duik.bezierIK\n" +
				"var CName = \"" + prevLayerName + "\";\n" +
				"var autoOrient = thisComp.layer(\"" + endController.name + "\").effect(\"" + effect.name + "\")(2);\n" +
				"var C = thisComp.layer(CName).toWorld(thisComp.layer(CName).anchorPoint);\n" +
				"var O =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
				"var vec = O-C;\n" +
				"var result = value;\n" +
				"var angle = Math.atan2(vec[1], vec[0]);\n" +
				"var ik = radiansToDegrees(angle);\n" +
				"if (autoOrient==1) result += ik;\n" +
				"result;";
				var nrot = layer.transform.rotation.value;
				layer.transform.rotation.setValue(-nrot+2*orot);

				prevLayerName = layer.name;
			}

			// add description in controllers
			var comment = " [Duik.bezierIK";
			for (var i = 0 ; i<layers.length-2;i++)
			{
				comment += "|layer" + i + ":" + layers[i].name;
			}
			comment += "|rootController:" + rootController.name + "|endController:" + endController.name;
			comment += "|curveController1:" + curveCtrl1.layer.name;
			if (numControllers != 1) comment += "|curveController2:" + curveCtrl2.layer.name;
			comment += "]";

			rootController.comment = rootController.comment + comment;
			endController.comment = endController.comment + comment;
			curveCtrl1.layer.comment = curveCtrl1.layer.comment + comment;
			if (numControllers != 1) curveCtrl2.layer.comment = curveCtrl2.layer.comment + comment;

			//lock and shy layers
			if (lockAndShy)
			{
				for (var i = 0 ; i<layers.length-2 ; i++)
				{
					layers[i].shy = true;
					layers[i].locked = true;
				}
			}

			if (numControllers == 1) return curveCtrl1; // Todo return array (update the use of this function in Duik.jsx too) // this will break backwards compatibility, do it in Duik16, not before
			else return [curveCtrl1,curveCtrl2];
		}
		/**
		 * Creates a one-layer IK
		 * @memberof LibDuik
		 * @param {Layer}	ctrl		- The controller layer.
		 * @param {Layer}	layer1 		- The layer of the IK.
		 * @returns {bool}	True if the creation worked, false if anything went wrong
		 */
		LibDuik.prototype.oneLayerIK = function (ctrl,layer1)
		{
			//if there's not at least one controller and one layer, abort creation
			if (ctrl == undefined || layer1 == undefined) return false;

			//check names
			Utils.prototype.checkNames(ctrl.containingComp);

			var controllerName = ctrl.name;

			//is right ?
			var ctrlPos = Utils.prototype.getWorldPos(ctrl);
			var bonePos = Utils.prototype.getWorldPos(layer1);

			var right = (ctrlPos[0] - bonePos[0]) < 0;

			//pseudo effect
			var effect;
			effect = Utils.prototype.addEffect(ctrl,Duik.effects.One_Layer_IK);
			effect.name = Duik.uiStrings.ik + " "  + layer1.name;

			if (right) effect(2).setValue(1);
			else effect(2).setValue(0);

			//original rotation value
			var orot = layer1.transform.rotation.value;
			//remove expression
			layer1.transform.rotation.expression = "";
			layer1.transform.rotation.setValue(orot);

			//=========================================================
			//EXPRESSION TO INSERT
			var expression = "//Duik.oneLayerIK\r\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\r\n" +
				"C = controller.toWorld(controller.anchorPoint);\r\n" +
				"O =  thisLayer.toWorld(thisLayer.anchorPoint);\r\n" +
				"W = controller.effect(\"" + effect.name + "\")(1)/100;\r\n" +
				"FK = controller.effect(\"" + effect.name + "\")(3);\r\n" +
				"R = controller.effect(\"" + effect.name + "\")(2);\r\n" +
				"var vec = R == 1 ? O-C : C-O;\r\n" +
				"var result = value+FK;\n" +
				"var layer = thisLayer;\n" +
				"while (layer.hasParent)\n" +
				"{\n" +
				"layer = layer.parent;\n" +
				"result = result - layer.rotation;\n" +
				"}\n" +
				"var angle = Math.atan2(vec[1], vec[0]);\n" +
				"angle = radiansToDegrees(angle);\n" +
				"angle = angle*W;\r\n" +
				"result += angle;"
				"var layer = thisLayer;\r\n" +
				"while (layer.hasParent)\r\n" +
				"{\r\n" +
				"layer = layer.parent;\r\n" +
				"result = result - layer.rotation;\r\n" +
				"}\r\n" +
				"result;";
			//=========================================================

			layer1.transform.rotation.expression = expression;

			//new rotation
			var nrot = layer1.transform.rotation.value;

			layer1.transform.rotation.setValue(-nrot+2*orot);

			//select controller
			Utils.prototype.deselectLayers();
			ctrl.selected = true;

			//add description in the comment of the controller
			ctrl.comment = ctrl.comment + " [Duik.oneLayerIK|layer:" + layer1.name + "]";

			return true;
		}
		/**
		 * Creates a two-layer IK. This works with 3D layers: all layers must have the 3D attribute enabled in this case, otherwise the IK will be rigged as 2 dimensonnal.
		 * @memberof LibDuik
		 * @param {Layer}	controller		- The controller layer.
		 * @param {Layer}	root 			- The first layer of the IK.
		 * @param {Layer}	end 			- The second layer of the IK.
		 * @param {bool}	clockWise 		- The orientation of the IK.
		 * @param {bool}	frontFacing 	- If the layers are 3D, true if they face the front/rear view of After Effects, false if they face the right/left view.
		 */
		LibDuik.prototype.twoLayerIK = function (controller,root,end,clockWise,frontFacing)
		{
			//if there's not at least one controller and two layers, abort creation
			if (controller == undefined) throw "A controller is needed for the IK";
			if (root == undefined) throw "The first layer of the IK is missing";
			if (end == undefined) throw "The second layer of the IK is missing";
			if (frontFacing == undefined) frontFacing = false;
			threeD = controller.threeDLayer && root.threeDLayer && end.threeDLayer;

			//detect if shape layers are used
			var shapeLayer = false;
			if (root instanceof ShapeLayer || end instanceof ShapeLayer) shapeLayer = true;

			//check names
			Utils.prototype.checkNames(controller.containingComp);

			//Names
			var endName = end.name;
			var rootName = root.name;
			var controllerName = controller.name;

			//pseudo effect
			var effect;
			effect = Utils.prototype.addEffect(controller,Duik.effects.Two_Layer_IK);
			effectName = Duik.uiStrings.ik + " "  + endName;
			effect.name = effectName;
			if (clockWise) effect(1).setValue(1);
			effect(10).setValue(0);

			if (threeD) {
				direction = controller.Effects.addProperty("ADBE Angle Control");
				direction.name = Duik.uiStrings.ikDirection + " " + endName;
			}

			//limit
			limit = root.Effects.addProperty("ADBE Angle Control");
			limit.name = Duik.uiStrings.ikLimit;

			//ZERO
			var endZero = null;

			if (shapeLayer)
			{
				//if shape layer, create zero
				endZero = controller.containingComp.layers.addNull();
				endZero.threeDLayer = true;
				var controllerParent = controller.parent;
				controller.parent = null;
				endZero.position.setValue(controller.position.value);
				endZero.name = "IK_zero " + endName.slice(-24);
				controller.parent = controllerParent;

				//link zero
				endZero.parent = end;

				//verrouiller et masquer le zero
				endZero.moveToEnd();
				endZero.guideLayer = true;
				endZero.locked = true;
				endZero.enabled = false;
				endZero.shy = true;

				endZeroName = endZero.name;
			}
			else
			{
				//add an effect to store the goal stretch
				var endEffect = end.Effects.addProperty("ADBE Point Control");
				endEffect.name = Duik.uiStrings.ikEnd;
				//set the value of the effect and store it
				endEffect(1).expression = "bonePos = thisComp.layer(\"" + controllerName + "\").toWorld(thisComp.layer(\"" + controllerName + "\").anchorPoint);\nfromWorld(bonePos)";
				var zeroValue = endEffect(1).value;
				endEffect(1).expression = "";
				endEffect(1).setValue(zeroValue);
			}

			//=========================================================
			//EXPRESSION FOR THE END
			var endExpression = "//Duik.twoLayerIK\r\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"layer2 = thisComp.layer(\"" + endName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n";

			if (shapeLayer) endExpression += "zeroName = \"" + endZeroName + "\";\n" +
				"zero = thisComp.layer(zeroName);\n";
			else endExpression += "endPos = layer2.effect(\"" + endEffect.name + "\")(1);\n";

			endExpression += "ctrlEffect = controller.effect(\"" + effectName + "\")\n" +
				"FK = ctrlEffect(5);\n" +
				"IKFK = ctrlEffect(3) == 0;\n" +
				"cw = ctrlEffect(1) == 1;\n" +
				"function getWorldPos(L){\n" +
				"return L.toWorld(L.anchorPoint);\n" +
				"}\n" +
				"function ik() {\n" +
				"A = getWorldPos(layer1);\n" +
				"B = getWorldPos(layer2);\n";

			if (shapeLayer) endExpression += "C = getWorldPos(zero);\n";
			else endExpression += "C = layer2.toWorld(endPos);\n";

			endExpression += "E = getWorldPos(controller);\n" +
				"a = length(B,C);\n" +
				"b = length(E,A);\n" +
				"c = length(A,B);\n" +
				"x = (b*b + c*c - a*a )/(2*b);\n" +
				"alpha = Math.acos(clamp(x/c,-1,1));\n" +
				"y = b - x;\n" +
				"  gamma = Math.acos(clamp(y/a,-1,1));\n" +
				"result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);  V1 = B - A;\n" +
				"  adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n" +
				"  V2 = C - B;\n" +
				"  adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n" +
				"  IK = result +  adj1 - adj2 + value;\n" +
				"return IK;\n" +
				"}\n" +
				"IKFK ? ik() : FK;";
			//=========================================================

			if (threeD) {end.transform.zRotation.expression = endExpression; end.transform.zRotation.setValue(0);}
			else {end.transform.rotation.expression = endExpression; end.transform.rotation.setValue(0);}


			//=========================================================
			//EXPRESSION FOR THE ROOT
			var rootExpression = "//Duik.twoLayerIK\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"layer2 = thisComp.layer(\"" + endName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n";

			if (shapeLayer) rootExpression += "zeroName = \"" + endZeroName + "\";\n" +
				"zero = thisComp.layer(zeroName);\n";
			else rootExpression += "endPos = layer2.effect(\"" + endEffect.name + "\")(1);\n";

			rootExpression += "ctrlEffect = controller.effect(\"" + effectName + "\")\n" +
				"limit = effect(\"" + limit.name + "\")(1);\n" +
				"FK = ctrlEffect(4);\n" +
				"IKFK = ctrlEffect(3) == 0;\n" +
				"cw = ctrlEffect(1) == 1;\n" +
				"function getWorldPos(L){\n" +
				"return L.toWorld(L.anchorPoint);\n" +
				"}\n" +
				"function ik() {\n" +
				"A = getWorldPos(layer1);\n" +
				"B = getWorldPos(layer2);\n";

			if (shapeLayer) rootExpression += "C = getWorldPos(zero);\n";
			else rootExpression += "C = layer2.toWorld(endPos);\n";

			rootExpression += "E = getWorldPos(controller);\n" +
				"a = length(B,C);\n" +
				"b = length(E,A);\n" +
				"c = length(A,B);\n" +
				"x = (b*b + c*c - a*a )/(2*b);\n" +
				"alpha = Math.acos(clamp(x/c,-1,1));\n" +
				"D = E - A;\n" +
				"delta = Math.atan2(D[1],D[0]);\n" +
				"result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n" +
				"V = B - A;\n" +
				"adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n" +
				"IK = result - adj1 + value;\n" +
				"if (IK < limit) IK+=360;\n" +
				"return IK;\n" +
				"}\n" +
				"IKFK ? ik() : FK;";
			//=======================================================

			if (threeD) {root.transform.zRotation.expression = rootExpression; root.transform.zRotation.setValue(0);}
			else {root.transform.rotation.expression = rootExpression; root.transform.rotation.setValue(0);}

			if (threeD) {
				//si 3D : le zero de la jambe pour l'orientation
				//creer un zero
				var zero = app.project.activeItem.layers.addNull();
				zero.threeDLayer = true;
				var calqueparent = root.parent;
				root.parent = null;
				zero.position.setValue(root.position.value);
				zero.name = "Zero_" + rootName.slice(-24);
				//verrouiller et masquer le zero
				zero.moveToEnd();
				zero.guideLayer = true;
				zero.shy = true;

				if (frontFacing) {
					var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +
						"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" +
						"C = controleur.toWorld(controleur.anchorPoint);\n" +
						"Cx = C[0];\n" +
						"Cy = C[1];\n" +
						"Cz = C[2];\n" +
						"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
						"Lx = L[0];\n" +
						"Ly = L[1];\n" +
						"Lz = L[2];" +
						"angle = lookAt([Cz,Cy,Cx],[Lz,Ly,Lx]);\n" +
						"[-angle[1]+90,-angle[0],value[2]]\n"
				} else { //front
					var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +
						"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" +
						"C = controleur.toWorld(controleur.anchorPoint);\n" +
						"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
						"angle = lookAt(C,L);\n" +
						"[angle[0],angle[1],value[2]]\n"
				} //else front
				zero.transform.orientation.expression = zeroExpression;
				zero.transform.xRotation.expression = "//Duik.twoLayerIK.threeD\r\n" + "thisComp.layer(\"" + controllerName + "\").effect(\"IK Direction " +  rootName.slice(-15) + "\")(1)";

				root.parent = zero;
				//lier le zero au bone du bout
				zero.parent = calqueparent;
				zero.enabled = false;
				zero.locked = true;
			} //tridi

			//les expressions de stretch
			//les positions d'origine
			var posbout = end.transform.position.value.toSource();
			var poszero;
			if (shapeLayer) poszero = endZero.transform.position.value.toSource();
			else poszero = zeroValue.toSource();
			var apracine = root.transform.anchorPoint.value.toSource();
			var apbout = end.transform.anchorPoint.value.toSource();

			var expressionstretchbout = "//Duik.twoLayerIK.stretch\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n" +
				"ctrlEffect = controller.effect(\"" + effectName + "\");\n" +
				"stretch = ctrlEffect(9);\n" +
				"auto = ctrlEffect(8) == 1;\n" +
				"IK = ctrlEffect(3) == 0;\n" +
				"shrinkVal = ctrlEffect(10)/100;\n" +
				"function getWorldPos(L){\n" +
				"return L.toWorld(L.anchorPoint);\n" +
				"}\n" +
				"dist1 = length(" + apracine + "," + posbout + ");\n" +
				"dist2 = length(" + apbout + "," + poszero + ");\n" +
				"IKLength = dist1+dist2;\n" +
				"IKStretched = IKLength+stretch;\n" +
				"boneStretch = 0;\n" +
				"proportion = dist1/(IKLength);\n" +
				"posC = getWorldPos(controller);\n" +
				"posR = getWorldPos(layer1);\n" +
				"distC = length(posC,posR);\n" +
				"shrinkMax = IKLength*shrinkVal;\n" +
				"shrink = 0;\n" +
				"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
				"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
				"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
				"else boneStretch += stretch*proportion;\n" +
				"coef = 1;\n" +
				"dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n" +
				"(" + posbout + "-" + apracine + ")*coef+" + apracine + ";";

			end.transform.position.expression = expressionstretchbout;

			var expressionstretchgoal = "//Duik.twoLayerIK.stretch\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n" +
				"ctrlEffect = controller.effect(\"" + effectName + "\");\n" +
				"stretch = ctrlEffect(9);\n" +
				"auto = ctrlEffect(8) == 1;\n" +
				"IK = ctrlEffect(3) == 0;\n" +
				"shrinkVal = ctrlEffect(10)/100;\n" +
				"function getWorldPos(L){\n" +
				"return L.toWorld(L.anchorPoint);\n" +
				"}\n" +
				"dist1 = length(" + apracine + "," + posbout + ");\n" +
				"dist2 = length(" + apbout + "," + poszero + ");\n" +
				"IKLength = dist1+dist2;\n" +
				"IKStretched = IKLength+stretch;\n" +
				"boneStretch = 0;\n" +
				"proportion = dist2/(IKLength);\n" +
				"posC = getWorldPos(controller);\n" +
				"posR = getWorldPos(layer1);\n" +
				"distC = length(posC,posR);\n" +
				"shrinkMax = IKLength*shrinkVal;\n" +
				"shrink = 0;\n" +
				"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
				"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
				"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
				"else boneStretch += stretch*proportion;\n" +
				"coef = 1;\n" +
				"dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n" +
				"(" + poszero + "-" + apbout + ")*coef+" + apbout + ";";

			if (shapeLayer) endZero.transform.position.expression = expressionstretchgoal;
			else endEffect(1).expression = expressionstretchgoal;

			//select controller
			Utils.prototype.deselectLayers();
			controller.selected = true;

			//move the controller to avoid bugs (forces expressions evaluation)
			controller.transform.position.setValue(controller.transform.position.value);

			//add description in the comment of the controller
			controller.comment = controller.comment + " [Duik.twoLayerIK|layer1:" + root.name + "|layer2:" + end.name + "]";

			return endZero;
		}
		/**
		 * Creates a three-layer IK.
		 * @memberof Duik
		 * @param {Layer}	controller		- The controller layer.
		 * @param {Layer}	root 			- The first layer of the IK.
		 * @param {Layer}	middle 			- The second layer of the IK.
		 * @param {Layer}	end 			- The third layer of the IK.
		 * @param {bool}	clockWise 		- The orientation of the IK.
		 */
		LibDuik.prototype.threeLayerIK = function (controller,root,middle,end,clockWise)
		{
			//if there's not at least one controller and three layers, abort creation
			if (controller == undefined) throw "A controller is needed for the IK";
			if (root == undefined) throw "The first layer of the IK is missing";
			if (middle == undefined) throw "The second layer of the IK is missing";
			if (end == undefined) throw "The third layer of the IK is missing";

			//check names
			Utils.prototype.checkNames(controller.containingComp);

			//check if shape layers
			var shapeLayer = false;
			if (root instanceof ShapeLayer || middle instanceof ShapeLayer || end instanceof ShapeLayer) shapeLayer = true;

			//Names
			var endName = end.name;
			var middleName = middle.name;
			var rootName = root.name;
			var controllerName = controller.name;

			//pseudo effect
			var effect;
			effect = Utils.prototype.addEffect(controller,Duik.effects.Three_Layer_IK);
			effect.name = Duik.uiStrings.ik + " "  + endName;
			if (clockWise) effect(1).setValue(1);
			effect(11).setValue(0);

			//limit
			limit = root.Effects.addProperty("ADBE Angle Control");
			limit.name = Duik.uiStrings.ikLimit;

			//ZERO
			var endZero = null;
			if (shapeLayer)
			{
				//creer un zero
				endZero = controller.containingComp.layers.addNull();
				endZero.threeDLayer = true;
				var controllerParent = controller.parent;
				controller.parent = null;
				endZero.position.setValue(controller.position.value);
				endZero.name = "IK_zero " + endName.slice(-24);
				controller.parent = controllerParent;

				//lier le zero au bone du bout
				endZero.parent = end;

				//verrouiller et masquer le zero
				endZero.moveToEnd();
				endZero.guideLayer = true;
				endZero.locked = true;
				endZero.enabled = false;
				endZero.shy = true;

				endZeroName = endZero.name;
			}
			else
			{
				//add an effect to store the goal stretch
				var endEffect = end.Effects.addProperty("ADBE Point Control");
				endEffect.name = Duik.uiStrings.ikEnd;
				//set the value of the effect and store it
				if (end instanceof ShapeLayer)
				{
					endEffect(1).expression = "thisComp.layer(\"" + controllerName + "\").toWorld(thisComp.layer(\"" + controllerName + "\").anchorPoint)";
				}
				else
				{
					endEffect(1).expression = "bonePos = thisComp.layer(\"" + controllerName + "\").toWorld(thisComp.layer(\"" + controllerName + "\").anchorPoint);\nfromWorld(bonePos)";
				}
				var zeroValue = endEffect(1).value;
				endEffect(1).expression = "";
				endEffect(1).setValue(zeroValue);
			}

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE BOUT
			endExpression = "//Duik.threeLayerIK\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"layer2 = thisComp.layer(\"" + middleName + "\");\n" +
				"layer3 = thisComp.layer(\"" + endName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n";

			if (shapeLayer) endExpression += "zeroName = \"" + endZeroName + "\";\n" +
				"zero = thisComp.layer(zeroName);\n";
			else endExpression += "endPos = layer3.effect(\"" + endEffect.name + "\")(1);\n";

			endExpression += "ctrlEffect = controller.effect(\"" + effect.name + "\");\n" +
				"FK = ctrlEffect(6);\n" +
				"IKFK = ctrlEffect(3) == 0;\n" +
				"cw = ctrlEffect(1) == 1;\n" +
				"function getWorldPos(layer){\n" +
				"return layer.toWorld(layer.anchorPoint);\n" +
				"}\n" +
				"function sq(result){\n" +
				"return result*result;\n" +
				"}\n" +
				"function getAngle(p1,p2){\n" +
				"var dist = p2-p1;\n" +
				"var angle = Math.atan2(dist[1],dist[0]);\n" +
				"return radiansToDegrees(angle);\n" +
				"}\n" +
				"function ik() {\n" +
				"var uPos = getWorldPos(layer1);\n" +
				"var mPos = getWorldPos(layer2);\n" +
				"var lPos = getWorldPos(layer3);\n";

			if (shapeLayer) endExpression += "var zPos = getWorldPos(zero);\n";
			else endExpression += "var zPos = layer3.toWorld(endPos);\n";

			endExpression += "var cPos = getWorldPos(controller);\n" +
				"var uLength = length(uPos,mPos);\n" +
				"var mLength = length(mPos,lPos);\n" +
				"var lLength = length(lPos,zPos);\n" +
				"var ikLength = length(uPos,cPos);\n" +
				"if (ikLength == 0) ikLength = 1;\n" +
				"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" +
				"var d2 = sq(ikLength) * (uLength+lLength);\n" +
				"var d3 = -sq(ikLength) * uLength * lLength;\n" +
				"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" +
				"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" +
				"var d6 = Math.sqrt( sq(ikLength) + sq(uLength) - 2*ikLength*uLength*Math.cos(baseA));\n" +
				"var lowerA = Math.acos(clamp((sq(d6) - sq(lLength) - sq(mLength)) / (-2*lLength*mLength),-1,1));\n" +
				"lowerA = cw ? -lowerA : lowerA;\n" +
				"lowerA = radiansToDegrees(lowerA);\n" +
				"var mToL =getAngle(mPos,lPos);\n" +
				"var lToZ =getAngle(lPos,zPos);\n" +
				"var ikResult = lowerA + mToL - lToZ +180;\n" +
				"return ikResult;\n" +
				"}\n" +
				"var result = value;\n" +
				"IKFK ? result += ik() : result += FK;\n" +
				"result;\n";

			end.transform.rotation.expression = endExpression;
			end.transform.rotation.setValue(0);
			//=========================================================

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE MIDDLE
			middleExpression ="//Duik.threeLayerIK\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"layer2 = thisComp.layer(\"" + middleName + "\");\n" +
				"layer3 = thisComp.layer(\"" + endName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n";

			if (shapeLayer) middleExpression += "zeroName = \"" + endZeroName + "\";\n" +
				"zero = thisComp.layer(zeroName);\n";
			else middleExpression += "endPos = layer3.effect(\"" + endEffect.name + "\")(1);\n";

			middleExpression += "ctrlEffect = controller.effect(\"" + effect.name + "\");\n" +
				"FK = ctrlEffect(5);\n" +
				"IKFK = ctrlEffect(3) == 0;\n" +
				"cw = ctrlEffect(1) == 1;\n" +
				"function getWorldPos(layer){\n" +
				"return layer.toWorld(layer.anchorPoint);\n" +
				"}\n" +
				"function sq(result){\n" +
				"return result*result;\n" +
				"}\n" +
				"function getAngle(p1,p2){\n" +
				"var dist = p2-p1;\n" +
				"var angle = Math.atan2(dist[1],dist[0]);\n" +
				"return radiansToDegrees(angle);\n" +
				"}\n" +
				"function ik() {\n" +
				"var uPos = getWorldPos(layer1);\n" +
				"var mPos = getWorldPos(layer2);\n" +
				"var lPos = getWorldPos(layer3);\n";

			if (shapeLayer) middleExpression += "var zPos = getWorldPos(zero);\n";
			else middleExpression += "var zPos = layer3.toWorld(endPos);\n";

			middleExpression += "var cPos = getWorldPos(controller);\n" +
				"var uLength = length(uPos,mPos);\n" +
				"var mLength = length(mPos,lPos);\n" +
				"var lLength = length(lPos,zPos);\n" +
				"var ikLength = length(uPos,cPos);\n" +
				"if (ikLength == 0) ikLength = 1;\n" +
				"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" +
				"var d2 = sq(ikLength) * (uLength+lLength);\n" +
				"var d3 = -sq(ikLength) * uLength * lLength;\n" +
				"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" +
				"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" +
				"var d5 = Math.sqrt( sq(ikLength) + sq(lLength) - 2*ikLength*lLength*Math.cos(baseA));\n" +
				"var middleA = Math.acos(clamp((sq(d5)-sq(uLength)-sq(mLength)) / (-2*uLength*mLength),-1,1));\n" +
				"middleA = cw ? -middleA : middleA ;\n" +
				"middleA = radiansToDegrees(middleA);\n" +
				"var uToM =getAngle(uPos,mPos);\n" +
				"var mToL =getAngle(mPos,lPos);\n" +
				"var ikResult = middleA + uToM - mToL +180;\n" +
				"return ikResult;\n" +
				"}\n" +
				"var result = value;\n" +
				"IKFK ? result += ik() : result += FK;\n" +
				"result;\n";

			middle.transform.rotation.expression = middleExpression;
			middle.transform.rotation.setValue(0);
			//=========================================================

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE ROOT
			rootExpression = "//Duik.threeLayerIK\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"layer2 = thisComp.layer(\"" + middleName + "\");\n" +
				"layer3 = thisComp.layer(\"" + endName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n";

			if (shapeLayer) rootExpression += "zeroName = \"" + endZeroName + "\";\n" +
				"zero = thisComp.layer(zeroName);\n";
			else rootExpression += "endPos = layer3.effect(\"" + endEffect.name + "\")(1);\n";

			rootExpression += "limit = effect(\"" + limit.name + "\")(1);\n" +
				"ctrlEffect = controller.effect(\"" + effect.name + "\");\n" +
				"FK = ctrlEffect(4);\n" +
				"IKFK = ctrlEffect(3) == 0;\n" +
				"cw = ctrlEffect(1) == 1;\n" +
				"function getWorldPos(layer){\n" +
				"return layer.toWorld(layer.anchorPoint);\n" +
				"}\n" +
				"function sq(result){\n" +
				"return result*result;\n" +
				"}\n" +
				"function getAngle(p1,p2){\n" +
				"var dist = p2-p1;\n" +
				"var angle = Math.atan2(dist[1],dist[0]);\n" +
				"return radiansToDegrees(angle);\n" +
				"}\n" +
				"function ik() {\n" +
				"var uPos = getWorldPos(layer1);\n" +
				"var mPos = getWorldPos(layer2);\n" +
				"var lPos = getWorldPos(layer3);\n";

			if (shapeLayer) rootExpression += "var zPos = getWorldPos(zero);\n";
			else rootExpression += "var zPos = layer3.toWorld(endPos);\n";

			rootExpression += "var cPos = getWorldPos(controller);\n" +
				"var uLength = length(uPos,mPos);\n" +
				"var mLength = length(mPos,lPos);\n" +
				"var lLength = length(lPos,zPos);\n" +
				"var ikLength = length(uPos,cPos);\n" +
				"if (ikLength == 0) ikLength = 1;\n" +
				"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" +
				"var d2 = sq(ikLength) * (uLength+lLength);\n" +
				"var d3 = -sq(ikLength) * uLength * lLength;\n" +
				"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" +
				"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" +
				"var upperA = cw ? -baseA : baseA ;\n" +
				"upperA = radiansToDegrees(upperA);\n" +
				"var uToC =getAngle(uPos,cPos);\n" +
				"var uToM =getAngle(uPos,mPos);\n" +
				"var ikResult = upperA + uToC - uToM;\n" +
				"if (ikResult < limit) ikResult +=360;\n" +
				"return ikResult;\n" +
				"}\n" +
				"var result = value;\n" +
				"IKFK ? result += ik() : result += FK;\n" +
				"result;\n";

			root.transform.rotation.expression = rootExpression;
			root.transform.rotation.setValue(0);
			//=========================================================

			//move the controller to avoid bugs (forces expressions evaluation)
			controller.transform.position.setValue(controller.transform.position.value);

			//les expressions de stretch
			//les positions d'origine
			var posmiddle = middle.transform.position.value.toSource();
			var posend = end.transform.position.value.toSource();
			var poszero;
			if (shapeLayer) poszero = endZero.transform.position.value.toSource();
			else poszero = zeroValue.toSource();
			var aproot = root.transform.anchorPoint.value.toSource();
			var apmiddle = middle.transform.anchorPoint.value.toSource();
			var apend = end.transform.anchorPoint.value.toSource();

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE MIDDLE
			middle.transform.position.expression = "//Duik.threeLayerIK.stretch\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n" +
				"ctrlEffect = controller.effect(\"" + effect.name + "\");\n" +
				"stretch = ctrlEffect(10);\n" +
				"auto = ctrlEffect(9) == 1;\n" +
				"IK = ctrlEffect(3) == 0;\n" +
				"shrinkVal = ctrlEffect(11)/100;\n" +
				"function getWorldPos(L){\n" +
				"return L.toWorld(L.anchorPoint);\n" +
				"}\n" +
				"var upperAP = " + aproot + ";\n" +
				"var middlePos = " + posmiddle + ";\n" +
				"var middleAP = " + apmiddle + ";\n" +
				"var lowerPos = " + posend + ";\n" +
				"var lowerAP = " + apend + ";\n" +
				"var zeroPos = " + poszero + ";\n" +
				"dist1 = length(upperAP,middlePos);\n" +
				"dist2 = length(middleAP,lowerPos);\n" +
				"dist3 = length(lowerAP,zeroPos);\n" +
				"IKLength = dist1+dist2+dist3;\n" +
				"IKStretched = IKLength+stretch;\n" +
				"boneStretch = 0;\n" +
				"proportion = dist1/(IKLength);\n" +
				"posC = getWorldPos(controller);\n" +
				"posR = getWorldPos(layer1);\n" +
				"distC = length(posC,posR);\n" +
				"shrinkMax = IKLength*shrinkVal;\n" +
				"shrink = 0;\n" +
				"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
				"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
				"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
				"else boneStretch += stretch*proportion;\n" +
				"coef = 1;\n" +
				"dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n" +
				"(middlePos-upperAP)*coef+upperAP;\n";
			//=========================================================

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE BOUT
			end.transform.position.expression = "//Duik.threeLayerIK.stretch\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n" +
				"ctrlEffect = controller.effect(\"" + effect.name + "\");\n" +
				"stretch = ctrlEffect(10);\n" +
				"auto = ctrlEffect(9) == 1;\n" +
				"IK = ctrlEffect(3) == 0;\n" +
				"shrinkVal = ctrlEffect(11)/100;\n" +
				"function getWorldPos(L){\n" +
				"return L.toWorld(L.anchorPoint);\n" +
				"}\n" +
				"var upperAP = " + aproot + ";\n" +
				"var middlePos = " + posmiddle + ";\n" +
				"var middleAP = " + apmiddle + ";\n" +
				"var lowerPos = " + posend + ";\n" +
				"var lowerAP = " + apend + ";\n" +
				"var zeroPos = " + poszero + ";\n" +
				"dist1 = length(upperAP,middlePos);\n" +
				"dist2 = length(middleAP,lowerPos);\n" +
				"dist3 = length(lowerAP,zeroPos);\n" +
				"IKLength = dist1+dist2+dist3;\n" +
				"IKStretched = IKLength+stretch;\n" +
				"boneStretch = 0;\n" +
				"proportion = dist2/(IKLength);\n" +
				"posC = getWorldPos(controller);\n" +
				"posR = getWorldPos(layer1);\n" +
				"distC = length(posC,posR);\n" +
				"shrinkMax = IKLength*shrinkVal;\n" +
				"shrink = 0;\n" +
				"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
				"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
				"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
				"else boneStretch += stretch*proportion;\n" +
				"coef = 1;\n" +
				"dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n" +
				"(middlePos-upperAP)*coef+upperAP;\n";
			//=========================================================

			//=========================================================
			//EXPRESSION A INSERER SUR LE ZERO
			expressionstretchgoal = "//Duik.threeLayerIK.stretch\n" +
				"layer1 = thisComp.layer(\"" + rootName + "\");\n" +
				"controller = thisComp.layer(\"" + controllerName + "\");\n" +
				"ctrlEffect = controller.effect(\"" + effect.name + "\");\n" +
				"stretch = ctrlEffect(10);\n" +
				"auto = ctrlEffect(9) == 1;\n" +
				"IK = ctrlEffect(3) == 0;\n" +
				"shrinkVal = ctrlEffect(11)/100;\n" +
				"function getWorldPos(L){\n" +
				"return L.toWorld(L.anchorPoint);\n" +
				"}\n" +
				"var upperAP = " + aproot + ";\n" +
				"var middlePos = " + posmiddle + ";\n" +
				"var middleAP = " + apmiddle + ";\n" +
				"var lowerPos = " + posend + ";\n" +
				"var lowerAP = " + apend + ";\n" +
				"var zeroPos = " + poszero + ";\n" +
				"dist1 = length(upperAP,middlePos);\n" +
				"dist2 = length(middleAP,lowerPos);\n" +
				"dist3 = length(lowerAP,zeroPos);\n" +
				"IKLength = dist1+dist2+dist3;\n" +
				"IKStretched = IKLength+stretch;\n" +
				"boneStretch = 0;\n" +
				"proportion = dist3/(IKLength);\n" +
				"posC = getWorldPos(controller);\n" +
				"posR = getWorldPos(layer1);\n" +
				"distC = length(posC,posR);\n" +
				"shrinkMax = IKLength*shrinkVal;\n" +
				"shrink = 0;\n" +
				"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
				"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
				"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
				"else boneStretch += stretch*proportion;\n" +
				"coef = 1;\n" +
				"dist3 != 0 ? coef = (dist3+boneStretch)/dist3 : coef = 1;\n" +
				"(middlePos-upperAP)*coef+upperAP;\n";

			if (shapeLayer) endZero.transform.position.expression = expressionstretchgoal;
			else endEffect(1).expression = expressionstretchgoal;
			//=========================================================

			//select controller
			Utils.prototype.deselectLayers();
			controller.selected = true;

			//move the controller to avoid bugs (forces expressions evaluation)
			controller.transform.position.setValue(controller.transform.position.value);

			//add description in the comment of the controller
			controller.comment = controller.comment + " [Duik.threeLayerIK|layer1:" + root.name + "|layer2:" + middle.name + "|layer3:" + end.name + "]";

			return endZero;
		}
		/**
		 * Creates an IK Goal.
		 * @memberof Duik
		 * @param {Layer}	layer 			- The layer which will be 'goaled'.
		 * @param {Layer}	controller		- The controller layer (optionnal).
		 * @return {bool}	Wether the creation worked
		 */
		LibDuik.prototype.goal = function (layer,controller)
		{
			//pour ne pas bouger, il faut recuperer la rotation d'origine
			var ancienneRot = 0;

			var rotation = layer.transform.rotation;
			if (layer.threeDLayer) rotation = layer.transform.zRotation;
			rotation.expression = '';

			if (rotation.numKeys == 0) ancienneRot = rotation.value;
			else ancienneRot = rotation.keyValue(1);

			//check names
			Utils.prototype.checkNames(layer.containingComp);

			//si on a un controleur
			if (controller != undefined)
			{
				//ajouter la case sur le controleur
				var effetGoal = controller.Effects.addProperty("ADBE Checkbox Control");
				effetGoal.name = "Goal" + " " + layer.name;
				effetGoal(1).setValue(true);
				//ajouter l'expression dans le calque
				expr = "//Duik.goal\r\n" +
				"var C = thisComp.layer(\"" + controller.name + "\");\r\n" +
				"var goal = C.effect(\"" + effetGoal.name + "\")(1);\r\n" +
				"var result = value + C.rotation;\r\n" +
				"if (goal == 1)\r\n" +
				"{\r\n" +
				"var layer = thisLayer;\r\n" +
				"while (layer.hasParent)\r\n" +
				"{\r\n" +
				"layer = layer.parent;\r\n" +
				"result = result - layer.rotation;\r\n" +
				"}\r\n" +
				"}\r\n" +
				"result;";

				rotation.expression = expr;
			}
			else
			{
				//ajouter la case sur le calque
				var effetGoal = layer.Effects.addProperty("ADBE Checkbox Control");
				effetGoal.name = "Goal";
				effetGoal(1).setValue(true);
				//ajouter l'expression dans le calque
				rotation.expression = "//Duik.goal\r\n" +
				"var goal = thisLayer.effect(\"" + effetGoal.name + "\")(1);\r\n" +
				"var result = value;\r\n" +
				"if (goal == 1)\r\n" +
				"{\r\n" +
				"var layer = thisLayer;\r\n" +
				"while (layer.hasParent)\r\n" +
				"{\r\n" +
				"layer = layer.parent;\r\n" +
				"result = result - layer.rotation;\r\n" +
				"}\r\n" +
				"}\r\n" +
				"result;";
			}

			//et remettre la bonne rotation pour pas bouger
			var nouvelleRot = 0;

			if (rotation.numKeys > 0)
			{
				nouvelleRot = rotation.valueAtTime(rotation.keyTime(1),false);
				//offset all keyframes
				var firstKeyRot = 2*ancienneRot-nouvelleRot;
				var offset = firstKeyRot - rotation.keyValue(1);
				for (var i = 1; i <= rotation.numKeys ; i++)
				{
					rotation.setValueAtKey(i,rotation.keyValue(i)+offset);
				}
			}
			else
			{
				nouvelleRot = rotation.value;
				rotation.setValue(2*ancienneRot-nouvelleRot);
			}


			//select controller
			if (controller != undefined)
			{
				Utils.prototype.deselectLayers();
				controller.selected = true;
				//add description in the comment of the controller
				controller.comment = controller.comment + " [Duik.goal|layer:" + layer.name + "]";
			}

			return true;
		}
		/* ADD CONTROLLER - Duik.addController(layer,autoLock,rotation,xPosition,yPosition,scale,placement)

		parameters
		layer | AVLayer, default: null
		autoLock | boolean
		rotation | boolean
		position | boolean
		scale | boolean

		returns
		Controller Object
		*/
		LibDuik.prototype.addController = function (layer,autoLock,rotation,xPosition,yPosition,scale)
		{
			if (layer == undefined) layer = null;
			if (rotation == undefined) rotation = true;
			if (xPosition == undefined) xPosition = true;
			if (yPosition == undefined) yPosition = true;
			if (scale == undefined) scale = false;
			if (autoLock == undefined) autoLock = false;
			var type = Duik.settings.controllerType;
			var color = Duik.settings.controllerColor;
			var placement = Duik.settings.ctrlPlacement;

			if (layer != null)
			{
			var layerParent = layer.parent;
			layer.parent = null;
			var layerPosition = layer.transform.position.value;
			layer.parent = layerParent;
			}

			var controllerObj = new Controller();
			controllerObj.rotation = rotation;
			controllerObj.xPosition = xPosition;
			controllerObj.yPosition = yPosition;
			controllerObj.scale = scale;
			controllerObj.arc = false;
			controllerObj.eye = false;
			controllerObj.color = color;
			controllerObj.size = 0;

			//le controleur
			var controller;
			if (type == Duik.layerTypes.NULL)
			{
			if (layer != null) controller = layer.containingComp.layers.addNull();
			else controller = app.project.activeItem.layers.addNull();
			//controller size
			var controllerSize = Duik.settings.controllerSize;
			if (Duik.settings.controllerSizeAuto)
			{
			controllerSize = controller.containingComp.width/2 + controller.containingComp.height/2;
			if (Duik.settings.controllerSizeHint == Duik.sizes.SMALL) controllerSize = Math.floor(controllerSize/40);
			else if (Duik.settings.controllerSizeHint == Duik.sizes.MEDIUM) controllerSize = Math.floor(controllerSize/20);
			else if (Duik.settings.controllerSizeHint == Duik.sizes.BIG) controllerSize = Math.floor(controllerSize/10);
			}
			controller.source.width = controllerSize;
			controller.source.height = controllerSize;
			controller.anchorPoint.setValue([controller.source.width/2,controller.source.height/2]);
			controllerObj.layer = controller;
			controllerObj.type = Duik.layerTypes.NULL;
			controllerObj.size = controllerSize;
			}
			else
			{
			if (Duik.settings.controllerSizeAuto) controllerObj.size = 0;
			else controllerObj.size = Duik.settings.controllerSize/30*100;
			if (layer != null) controller = layer.containingComp.layers.addShape();
			else controller = app.project.activeItem.layers.addShape();
			controller.guideLayer = true;
			controllerObj.layer = controller;
			controllerObj.type = Duik.layerTypes.VECTOR;
			controllerObj.update();
			}
			if (layer != null)
			{
			controller.transform.position.setValue(layerPosition);
			var cname = "C_";
			if (layer.name.length > 29)
			{
			cname = cname + layer.name.slice(0,10) + " ... " + layer.name.slice(-13);
			}
			else
			{
			cname = cname + layer.name;
			}
			controller.name = cname;
			}
			else
			{
			controller.name = "C_";
			}

			//add to group
			Utils.prototype.addLayerToDuGroup(controller,Duik.uiStrings.controllers);

			if (autoLock) controllerObj.lock();

			if (layer != null)
			{
			if (placement == Duik.placement.OVER_LAYER) controller.moveBefore(layer);
			else if (placement == Duik.placement.UNDER_LAYER) controller.moveAfter(layer);
			}
			if (placement == Duik.placement.BOTTOM) controller.moveToEnd();

			//select controller
			Utils.prototype.deselectLayers();
			controller.selected = true;

			return controllerObj;
		}
		/* ADD CONTROLLERS - Duik.addControllers(layers,color,autoLock,rotation,xPosition,yPosition,scale,placement)

		parameters
		layers | Array of AVLayer or LayerCollection
		color | Array of 4 floats R,V,B,A
		autoLock | boolean
		rotation | boolean
		position | boolean
		scale | boolean
		placement | Duik.placement.OVER_LAYER or Duik.placement.UNDER_LAYER or Duik.placement.TOP or Duik.placement.BOTTOM, default: Duik.settings.ctrlPlacement

		returns
		Array of Controller Objects
		*/
		LibDuik.prototype.addControllers = function (layers,autoLock,rotation,xPosition,yPosition,scale)
		{
			var controllers = [];

			if (layers.length > 0)
			{
			for (var i = 0 ; i < layers.length ; i++)
			{
			controllers.push ( Duik.addController( Utils.prototype.getItem(layers,i),autoLock,rotation,xPosition,yPosition,scale) );
			}
			}
			else
			{
			controllers.push(Duik.addController(null,autoLock,rotation,xPosition,yPosition,scale));
			}

			//select controllers
			Utils.prototype.deselectLayers();
			for (var controllerI = 0; controllerI < controllers.length;controllerI++)
			{
			controllers[controllerI].layer.selected = true;
			}

			return controllers;
		}
		/**
		 * Adds a wiggle to a property
		 * @memberof Duik
		 * @param {Property}	prop 				- The property.
		 * @param {bool}		separateDimensions 	- Wether to separate the dimensions (to adjust amplitude and frequency) if the property is multi-dimensionnal, default: false
		 * @return {bool}		True if successfull, false otherwise
		 */
		LibDuik.prototype.wiggle = function (prop,separateDimensions)
		{
			if (!prop) throw "Missing Param 1: wiggle needs a Property";
			if (!prop.canSetExpression) throw "This property can not set expressions";

			if (separateDimensions == undefined) separateDimensions = false;

			//dimensions
			var dimensions = Utils.prototype.getPropertyDimensions(prop);
			if (!separateDimensions) dimensions = 1;

			var ok = false;

			if (dimensions == 3) ok = Duik.threeDWiggle(prop);
			else if (dimensions == 2) ok = Duik.twoDWiggle(prop);
			else ok = Duik.oneDWiggle(prop);

			return ok;
		}
		/**
		 * Adds a 3-dimensionnal wiggle to a property
		 * @memberof Duik
		 * @param {Property}	prop 	- The property.
		 * @return {bool}		True if successfull, false otherwise
		 */
		LibDuik.prototype.threeDWiggle = function (prop)
		{
			if (!prop) throw "Missing Param 1: wiggle needs a Property";
			if (!prop.canSetExpression) throw "This property can not set expressions";
			var layer = Utils.prototype.getPropertyLayer(prop);
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.ThreeD_Wiggle);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.wiggle);
			effect(11).setValue(layer.containingComp.duration);

			prop.expression = "//Duik.3DWiggle\r\n" +
			"Xfreq = effect(\"" + effect.name + "\")(7);\n" +
			"Yfreq = effect(\"" + effect.name + "\")(8);\n" +
			"Zfreq = effect(\"" + effect.name + "\")(9);\n" +
			"Xamp = effect(\"" + effect.name + "\")(2);\n" +
			"Yamp = effect(\"" + effect.name + "\")(3);\n" +
			"Zamp = effect(\"" + effect.name + "\")(4);\n" +
			"loop = effect(\"" + effect.name + "\")(11);\n" +
			"if (loop == 0) loop = thisComp.duration;\n" +
			"t = (time % loop)-loop;\n" +
			"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
			"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
			"Z1 = wiggle(Zfreq,Zamp, 1, 0.5, t);\n" +
			"w1 = [X1[0],Y1[1],Z1[2]];\n" +
			"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
			"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
			"Z2 = wiggle(Zfreq,Zamp, 1, 0.5, t - loop);\n" +
			"w2 = [X2[0],Y2[1],Z2[2]];\n" +
			"w = ease(t, -loop,  0, w1, w2);\n" +
			"w + value - valueAtTime(0)";

			return true;
		}
		/**
		 * Adds a 2-dimensionnal wiggle to a property
		 * @memberof Duik
		 * @param {Property}	prop 	- The property.
		 * @return {bool}		True if successfull, false otherwise
		 */
		LibDuik.prototype.twoDWiggle = function (prop)
		{
			if (!prop) throw "Missing Param 1: wiggle needs a Property";
			if (!prop.canSetExpression) throw "This property can not set expressions";
			var layer = Utils.prototype.getPropertyLayer(prop);
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.TwoD_Wiggle);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.wiggle);
			effect(9).setValue(layer.containingComp.duration);

			prop.expression = "//Duik.2DWiggle\n" +
			"Xfreq = effect(\"" + effect.name + "\")(6);\n" +
			"Yfreq = effect(\"" + effect.name + "\")(7);\n" +
			"Xamp = effect(\"" + effect.name + "\")(2);\n" +
			"Yamp = effect(\"" + effect.name + "\")(3);\n" +
			"loop = effect(\"" + effect.name + "\")(9);\n" +
			"if (loop == 0) loop = thisComp.duration;\n" +
			"t = (time % loop)-loop;\n" +
			"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
			"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
			"w1 = [X1[0],Y1[1]];\n" +
			"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
			"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
			"w2 = [X2[0],Y2[1]];\n" +
			"w = ease(t, -loop,  0, w1, w2);\n" +
			"w + value - valueAtTime(0)";
			return true;
		}
		/**
		 * Adds a 1-dimensionnal wiggle to a property
		 * @memberof Duik
		 * @param {Property}	prop 	- The property.
		 * @return {bool}		True if successfull, false otherwise
		 */
		LibDuik.prototype.oneDWiggle = function (prop)
		{
			if (!prop) throw "Missing Param 1: wiggle needs a Property";
			if (!prop.canSetExpression) throw "This property can not set expressions";
			var layer = Utils.prototype.getPropertyLayer(prop);
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.OneD_Wiggle);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.wiggle);
			effect(3).setValue(layer.containingComp.duration);

			prop.expression = "//Duik.1DWiggle\n" +
			"freq = effect(\"" + effect.name + "\")(2);\n" +
			"amp = effect(\"" + effect.name + "\")(1);\n" +
			"loop = effect(\"" + effect.name + "\")(3);\n" +
			"if (loop == 0) loop = thisComp.duration;\n" +
			"t = (time % loop)-loop;\n" +
			"w1 = wiggle(freq,amp, 1, 0.5, t);\n" +
			"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" +
			"w = ease(t, -loop,  0, w1, w2);\n" +
			"w + value - valueAtTime(0)";
			return true;
		}
		/* ADAPTATIVE EXPOSURE - Duik.adaptativeExposure(layers,precision,minExp,maxExp,sync,layerSync);

		Adds exposure controls to the animation of the property.
		The exposure adapts automatically to the speed, according to the given precision,
		of the properties between a minimum and a maximum exposure (in frames).

		parameters
		layers | Array of AVLayer or LayerCollection
		precision | integer, default: 100
		minExp | integer, default: 1
		maxExp | integer, default: 4

		returns
		void

		*/
		LibDuik.prototype.adaptativeExposure = function (layrs,limit,minExp,maxExp,sync,layerSync)
		{
			//functions
			function getSpeed(p,t)
			{
			if (p.propertyType != PropertyType.PROPERTY) return 0;
			if (p.numKeys == 0) return 0;

			//get the nearest key
			var nearKey = p.nearestKeyIndex(t);
			var nearKeyTime = p.keyTime(nearKey);

			//if we're still before the first key
			if (t <= nearKeyTime && nearKey == 1) return 0;

			//get the previous key
			var prevKey = 0;
			if (t < nearKeyTime) prevKey = nearKey -1;
			else prevKey = nearKey;

			//if the last key is in the past
			if (prevKey == p.numKeys) return 0;

			//get speed & num frames from prevKey
			var difference = Utils.prototype.getLength(p.valueAtTime(t,false),p.keyValue(prevKey));
			return difference;
			}

			//exposure
			if (layrs == undefined) return false;
			if (layrs.length == 0) return false;

			if (minExp == undefined) minExp = 1;
			if (maxExp == undefined) maxExp = 4;
			if (sync == undefined) sync = true;
			if (layerSync == undefined) layerSync = false;

			var layers = Utils.prototype.convertCollectionToArray(layrs);

			if (minExp <= 0) minExp = 1;
			if (maxExp <= 0) maxExp = 1;

			if (limit == undefined) limit = 100;
			if (limit == 0) limit = 1;

			limit = 1/limit*10000;

			//for each frame of the comp
			var comp = layers[0].containingComp;
			var frames = comp.duration / comp.frameDuration ;
			var exposure = 0;
			if (sync && !layerSync)
			{
			for (var frame = 0 ; frame < frames ; frame += minExp)
			{
			exposure++;
			var speed = 0;
			var time = frame*comp.frameDuration;
			//BOUCLE SUR LES CALQUES POUR VERIFIER SI LIMITE DEPASSEE
			for (var i = 0 ; i < layers.length ; i++)
			{
			var layer = layers[i];
			if (layer.selectedProperties.length == 0) continue;
			for (var j = 0 ; j < layer.selectedProperties.length ; j++)
			{
			var prop = layer.selectedProperties[j];
			var speedTest = getSpeed(prop,time);
			if (speedTest > speed) speed = speedTest;
			}
			}

			//BOUCLE SUR LES CALQUES POUR METTRE UNE CLEF SI LIMITE DEPASSEE
			if ((speed >= limit || exposure >= maxExp) && speed > 0)
			{
			exposure = 0;
			for (var i = 0 ; i < layers.length ; i++)
			{
			var layer = layers[i];
			if (layer.selectedProperties.length == 0) continue;
			for (var j = 0 ; j < layer.selectedProperties.length ; j++)
			{
			var prop = layer.selectedProperties[j];
			if (prop.propertyType != PropertyType.PROPERTY) continue;
			if (prop.numKeys == 0) continue;
			prop.addKey(time);
			}
			}
			}
			if (speed == 0) exposure = 0;
			}
			}
			else if (sync)
			{
			//POUR CHAQUE CALQUE
			for (var i = 0 ; i < layers.length ; i++)
			{
			var layer = layers[i];
			if (layer.selectedProperties.length == 0) continue;
			//pour chaque frame
			for (var frame = 0 ; frame < frames ; frame += minExp)
			{
			exposure++;
			var speed = 0;
			var time = frame*comp.frameDuration;
			//POUR CHAQUE PROP
			for (var j = 0 ; j < layer.selectedProperties.length ; j++)
			{
			var prop = layer.selectedProperties[j];
			var speedTest = getSpeed(prop,time);
			if (speedTest > speed) speed = speedTest;
			}
			if ((speed >= limit || exposure >= maxExp) && speed > 0)
			{
			exposure = 0;
			for (var j = 0 ; j < layer.selectedProperties.length ; j++)
			{
			var prop = layer.selectedProperties[j];
			if (prop.propertyType != PropertyType.PROPERTY) continue;
			if (prop.numKeys == 0) continue;
			prop.addKey(time);
			}
			}
			if (speed == 0) exposure = 0;
			}
			}
			}
			else
			{
			//POUR CHAQUE CALQUE
			for (var i = 0 ; i < layers.length ; i++)
			{
			var layer = layers[i];
			if (layer.selectedProperties.length == 0) continue;
			//POUR CHAQUE PROP
			for (var j = 0 ; j < layer.selectedProperties.length ; j++)
			{
			for (var frame = 0 ; frame < frames ; frame += minExp)
			{
			exposure++;
			var speed = 0;
			var time = frame*comp.frameDuration;
			var prop = layer.selectedProperties[j];
			var speed = getSpeed(prop,time);
			if ((speed >= limit || exposure >= maxExp) && speed > 0)
			{
			exposure = 0;
			prop.addKey(time);
			}
			if (speed == 0) exposure = 0;
			}
			}
			}
			}
			//all key interpolations to HOLD
			Utils.prototype.stepSelectedProperties(layers);
			return true;
		}
		/* SET EXPOSURE - Duik.setExposure(layers,exposure)

		Sets the animation exposure on the selected props on the layers.
		If the exposure is not provided, the function will use Duik.detectedExposure, the exposure detected using Utils.prototype.getFootageExposure

		parameters
		layers | Array of AVLayer or LayerCollection
		exposure | Array of float, the times where a keyframe must be added, default: Duik.detectedExposure

		returns
		void

		*/
		LibDuik.prototype.setExposure = function (layrs,exposure)
		{
			if (layrs == undefined) return;
			if (exposure == undefined) exposure = Duik.detectedExposure;
			if (!exposure.length) return;

			var layers = Utils.prototype.convertCollectionToArray(layrs);

			//for each time in exposure
			for (var e=0;e<exposure.length;e++)
			{
			var time = exposure[e];
			//POUR CHAQUE CALQUE
			for (var i = 0 ; i < layers.length ; i++)
			{
			var layer = layers[i];
			if (layer.selectedProperties.length == 0) continue;
			//POUR CHAQUE PROP
			for (var j = 0 ; j < layer.selectedProperties.length ; j++)
			{
			layer.selectedProperties[j].addKey(time);
			}
			}
			}

			//STEP
			Utils.prototype.stepSelectedProperties(layers);
		}
		/* FIXED EXPOSURE - Duik.fixedExposure(layer,prop);

		Adds exposure controls to the animation of the property.

		parameters
		layer | AVLayer
		prop | Property

		returns
		Array of AVLayers, the bones created

		*/
		LibDuik.prototype.fixedExposure = function (layer,prop)
		{
			if (layer == undefined) return false;
			if (prop == undefined) return false;

			//creer l'effet
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.Exposure);
			var effect = prep[0];
			var prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.exposure);
			effect(1).setValue(1);

			prop.expression = "expo = effect(\"" + effect.name + "\")(1);\n" +
			"expo == 0 ? expo = 1 : Math.abs(expo);\n" +
			"timef = timeToFrames(time);\n" +
			"valueAtTime(framesToTime( timef - timef%expo ))";
		}
		/**
		 * Adds a slider on a precomposition laye, and markers on the layer, with keyframes representing the exposure of the layers inside the precomposition
		 * @memberof Duik
		 * @param {LayerItem}	precomp		- The layer of the precomposition
		 */
		LibDuik.prototype.getPrecompExposure = function (precomp)
		{
			//get source comp
			var comp = precomp.source;

			//if not a precomp, skip
			if (!(comp instanceof CompItem)) throw "The layer must be a precomposition.";

			//add slider
			var slider = precompLayer.Effects.addProperty("ADBE Slider Control");
			slider.name = "Detected Exposure";

			//detect exposure
			for (var i = 1 ; i <= comp.numLayers ; i++)
			{
				var layer = comp.layer(i);
				slider(1).setValueAtTime(precompLayer.startTime + layer.inPoint,layer.inPoint);
				slider(1).setInterpolationTypeAtKey(slider(1).numKeys,KeyframeInterpolationType.HOLD,KeyframeInterpolationType.HOLD);
				precompLayer.marker.setValueAtTime(precompLayer.startTime + layer.inPoint,new MarkerValue(''));
			}
		}
		/**
		 * Adds Bones 1- if found, on the selected puppet pins of the layer(s), OR 2- on the selected spatial properties, OR 3- on all puppet pins found.
		 * @memberof Duik
		 * @param {Array or LayerCollection}	layers			- The layers used to create bones (Array of Layer object or LayerCollection).
		 * @param {int}							root 			- Where the bones are in the layer stack, one of Duik.placement.TOP, Duik.placement.BOTTOM, Duik.placement.OVER_LAYER, Duik.placement.UNDER_LAYER. Default: Duik.settings.bonePlacement
		 * @return {Array}						The bones created (Array of Layer object), may be an empty array if no layer was provided
		 */
		LibDuik.prototype.addBones = function (layers,placement)
		{
			if (placement == undefined) placement = Duik.settings.bonePlacement;
			var createdBones = [];
			if (layers.length == 0) { return createdBones; }

			//check names
			Utils.prototype.checkNames(layers[0].containingComp);

			for (var i=0;i<layers.length;i++)
			{
				var calque = Utils.prototype.getItem(layers,i);
				// les proprietes selectionnees
				var props = calque.selectedProperties;
				var coins = [];
				//lister les puppet pins
				if (props.length > 0)
				{
					for (var j=0;j<props.length;j++)
					{
						if (props[j].matchName == "ADBE FreePin3 PosPin Atom") coins.push(props[j]);
					}
				}
				//if no pins were found, use every selected spatial properties
				if (!coins.length && props.length > 0)
				{
					for (var j=0;j<props.length;j++)
					{
						if (props[j].propertyType == PropertyType.PROPERTY)
						{
							if (props[j].propertyValueType == PropertyValueType.TwoD_SPATIAL || props[j].propertyValueType == PropertyValueType.ThreeD_SPATIAL)
							{
								if (props[j].canSetExpression) coins.push(props[j]);
							}
						}
					}
				}
				//si il n'y a pas de coins selectionnes, on les prend tous
				if (!coins.length) coins = Utils.prototype.getPuppetPins(calque("Effects"));
				//si on a vraiment rien trouve, on laisse tomber
				if (!coins.length) throw "Please select a spatial property to link it to a bone.\nYou cannot link a non-spatial property to a bone\nIt must have two or three dimensions.";

				for (var j=0;j<coins.length;j++)
				{
					var coin = coins[j];

					var position;

					if (coin.matchName == "ADBE FreePin3 PosPin Atom")
					{
						position = coin.position;
					}
					else
					{
						position = coin;
					}

					//creer le bone
					var bone;
					//sa taille
					boneTaille = Duik.settings.boneSize;
					if (Duik.settings.boneSizeAuto)
					{
						if (calque instanceof ShapeLayer)
						{
							boneTaille = app.project.activeItem.height/2 + app.project.activeItem.height/2;
						}
						else
						{
							var calqueParent = calque.parent;
							calque.parent = null;
							var calqueEchelle = calque.transform.scale.value;
							calque.parent = calqueParent;
							boneTaille = calque.source.width*Math.abs(calqueEchelle[0])/130 + calque.source.height*Math.abs(calqueEchelle[1])/130;
						}

						if (Duik.settings.boneSizeHint == Duik.sizes.SMALL) boneTaille = Math.floor(boneTaille/60);
						else if (Duik.settings.boneSizeHint == Duik.sizes.MEDIUM) boneTaille = Math.floor(boneTaille/40);
						else if (Duik.settings.boneSizeHint == Duik.sizes.BIG) boneTaille = Math.floor(boneTaille/20);
					}
					//adjust size if too small
					if (boneTaille < 4) boneTaille = 4;

					if (Duik.settings.boneType == Duik.layerTypes.NULL)
					{
						bone = app.project.activeItem.layers.addNull();
						bone.name = "B_" + coin.name;
						bone.source.width = boneTaille;
						bone.source.height = boneTaille;
						bone.transform.anchorPoint.setValue([bone.source.width/2,bone.source.height/2]);
					}
					else
					{
						var colorString = Duik.settings.boneColor;
						bone = app.project.activeItem.layers.addSolid(Utils.prototype.hexColorToRVB(colorString),"B_" + coin.name,boneTaille,boneTaille,app.project.activeItem.pixelAspect);
					}
					if (placement == Duik.placement.OVER_LAYER) bone.moveBefore(calque);
					else if (placement == Duik.placement.UNDER_LAYER) bone.moveAfter(calque);
					else if (placement == Duik.placement.BOTTOM) bone.moveToEnd();

					//group
					Utils.prototype.addLayerToDuGroup(bone,Duik.uiStrings.bones);

					createdBones.push(bone);

					//mettre le bone a la position du coin : utiliser une expression pour avoir la position en mode world du coin
					posLink = Duik.utils.getExpressionLink(position,true);

					if (!(calque instanceof ShapeLayer))
					{
						bone.position.expression = "thisComp.layer(\"" + calque.name + "\").toWorld(" + posLink + ")";
						bone.position.setValue(bone.position.value);
						bone.position.expression = "";
					}
					else
					{
						bone.position.setValue(position.value);
					}

					//nom du bone
					if (coin.matchName == "ADBE FreePin3 PosPin Atom")
					{
						bone.name = "B_" + coin.name;
					}
					else
					{
						var name = "B_" + coin.name + "_" + coin.parentProperty.name;
						if (name.length > 32) name = name.substr(0,32);
						bone.name = name;
					}

					bone.guideLayer = true;
					//mettre l'expression dans le coin
					if (calque instanceof ShapeLayer)
					{
						position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint)";
					}
					else
					{
						position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint);\nfromWorld(bonePos)";
					}
				}//for coins
			}//for layers
			return createdBones;
		}
		// ADD ZERO - Duik.addZero(layer);
		LibDuik.prototype.addZero = function (layer)
		{
			//create null object
			var zero = layer.containingComp.layers.addNull();
			Utils.prototype.addLayerToDuGroup(zero,Duik.uiStrings.zeroes);
			var calqueparent = layer.parent;
			layer.parent = null;
			zero.position.setValue(layer.position.value);
			zero.rotation.setValue(layer.rotation.value);
			zero.name = "Zero_" + layer.name.slice(-24);
			layer.parent = zero;
			zero.scale.setValue(layer.scale.value);
			layer.scale.setValue([100,100,100]);

			//parent
			zero.parent = calqueparent;

			//lock and hide
			zero.moveToEnd();
			zero.guideLayer = true;
			zero.locked = true;
			zero.shy = true;
			zero.enabled = false;

			return zero;
		}
		/* ADD ZEROS - Duik.addZeros(layers);

		Adds a null object for each layer, at the same place and orientation,
		and then parents the layer to it, parenting the null object (the zero) to the former
		parent of the layer.

		parameters
		layers | Array of AVLayer

		returns
		Array of AVLayers, the zeros created

		*/
		LibDuik.prototype.addZeros = function (layers)
		{
			var zeros = [];
			for (var i = 0 ; i < layers.length ; i++)
			{
			var calque = Utils.prototype.getItem(layers,i);
			var zero = Duik.addZero(calque);
			zeros.push(zeros);
			}
			return zeros;
		}
		/* ROTATION MORPH - Duik.rotationMorph(layer,prop);

		Creates a rotation morph on the given property

		parameters
		layer | AVLayer
		prop | Property

		returns
		true if successful, false if anything went wrong

		*/
		LibDuik.prototype.rotationMorph = function (layer,prop)
		{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.RotMorph);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.rotMorph);

			prop.expression = "//Duik.rotationMorph\r\n" +
			"if (numKeys > 1)\r\n" +
			"{\r\n" +
			"r = thisLayer.effect(\"" + effect.name + "\")(1).transform.rotation;\r\n" +
			"n = timeToFrames(key(numKeys).time);\r\n" +
			"Min =  thisLayer.effect(\"" + effect.name + "\")(2);\r\n" +
			"Max = thisLayer.effect(\"" + effect.name + "\")(3);\r\n" +
			"div =  (Max - Min) / n;\r\n" +
			"val = 0;\r\n" +
			"if (div != 0) val = r/div - (Min/div);\r\n" +
			"valueAtTime(framesToTime(val));\r\n" +
			"} else value;";

			return true;
		}
		/* SWING - Duik.swing(layer,prop);

		Creates a swing on the given property

		parameters
		layer | AVLayer
		prop | Property

		returns
		true if successful, false if anything went wrong

		*/
		LibDuik.prototype.swing = function (layer,prop)
		{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.Swing);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.swing);
			effect(1).setValue(10);
			effect(2).setValue(1);

			prop.expression = "//Duik.swing\r\n" +
			"amp = effect(\"" + effect.name + "\")(1);\n" +
			"freq = effect(\"" + effect.name + "\")(2)*2*Math.PI;\n" +
			"decalage = framesToTime(effect(\"" + effect.name + "\")(3));\n" +
			"amorti = Math.abs(effect(\"" + effect.name + "\")(4));\n\n" +
			"sin = Math.sin(time*freq+decalage);\n\n" +
			"for(i=0;i<amorti;i++) {\n" +
			"sin = Math.sin(sin);\n" +
			"}\n" +
			"sin*amp+value;";

			return true;
		}
		/* WHEEL - Duik.wheel(layer,radius,curved);

		Automates the rotation of the given layer using its position.
		If curved, works even if the trajectory is not horizontal, but is heavier to compute.

		parameters
		layer | AVLayer
		radius | float, default 100.0
		curved | boolean, default false

		returns
		true if successful, false if anything went wrong

		*/
		LibDuik.prototype.wheel = function (layer,radius,curved)
		{
				if (!layer) throw "Missing Param 1: Wheel needs a Layer";
				if (radius == undefined) radius = 100;
				else if (! (radius > 0)) radius = 100;
				if (curved == undefined) curved = false;
				var rotation = layer.transform.rotation;
				if (layer.threeDLayer) rotation = layer.transform.zRotation;
				var prep = Utils.prototype.rigProperty(layer,rotation,Duik.effects.Wheel);
				var effect = prep[0];
				if (effect == null) return false;
				Utils.prototype.renameEffect(effect,Duik.uiStrings.wheel);
				effect(1).setValue(radius);

				if (!curved) rotation.expression = "//Duik.Wheel\r\n" +
				"O = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
				"R = thisLayer.effect(\"" + effect.name + "\")(1);\n" +
				"Rev = thisLayer.effect(\"" + effect.name + "\")(2);\n" +
				"result = 0;\n" +
				"R > 0 ? result = radiansToDegrees(O[0]/R) : result = 0 ;" +
				"Rev == 1 ? value - result : value + result;";
				else rotation.expression = "//Duik.Wheel\r\n" +
				"R = thisLayer.effect(\"" + effect.name + "\")(1);\n" +
				"Rev = thisLayer.effect(\"" + effect.name + "\")(2);\n" +
				"var precision = 1;\n" +
				"function pos(frame)\n" +
				"{\n" +
				"return thisLayer.toWorld(thisLayer.anchorPoint,framesToTime(frame));\n" +
				"}\n" +
				"function roue()\n" +
				"{\n" +
				"if (R<=0) return value;\n" +
				"var distance = 0;\n" +
				"var start = thisLayer.inPoint > thisComp.displayStartTime ? timeToFrames(thisLayer.inPoint) : timeToFrames(thisComp.displayStartTime) ;\n" +
				"var end = time < thisLayer.outPoint ? timeToFrames(time) : timeToFrames(thisLayer.outPoint);\n" +
				"for(i=start;i<end;i+=precision)\n" +
				"{\n" +
				"if (pos(i+precision)[0] - pos(i)[0] > 0) distance += length(pos(i+precision),pos(i));\n" +
				"else distance -= length(pos(i+precision),pos(i));\n" +
				"}\n" +
				"return radiansToDegrees(distance/R) ;\n" +
				"}\n" +
				"Rev == 1 ? value - roue() : value + roue();";

				return true;
			}
		/* MORPHER - Duik.morpher(layers);

		Adds a "morpher", a slider to easily control interpolations of selected properties of the given layers.

		parameters
		layers | Array of AVLayer

		returns
		true if successful, false if anything went wrong

		*/
		LibDuik.prototype.morpher = function (layers)
		{
			//recuperer la selection d'effets du premier calque, puisqu'elle sera perdue a la creation de la glissiere..... (voir avec adobe si vous trouvez ca pas pratique)
			var selection = [];
			var effets = Utils.prototype.getItem(layers,0).selectedProperties;

			for (var j=0;j<effets.length;j++) {
			if (effets[j].canSetExpression && effets[j].parentProperty.isEffect) {
			var layerIndex = app.project.activeItem.selectedLayers[0].index;
			var effetIndex =  effets[j].propertyIndex;
			var effetParentName = effets[j].parentProperty.name;
			selection.push([layerIndex,effetParentName,effetIndex]);
			delete effetIndex;
			delete effetParentName;
			}
			}

			//creer le curseur
			var morpher = layers[0].Effects.addProperty("ADBE Slider Control");
			Utils.prototype.renameEffect(morpher,Duik.uiStrings.morpher);

			//boucle pour appliquer le morpher sur la selection perdue
			for (var i=0;i<selection.length;i++)
			{
			var effet = layers[0].effect(selection[i][1])(selection[i][2]);
			effet.expression = "//Duik.Morpher\r\nvalueAtTime((thisComp.layer(\"" +  layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
			//la boucle pour creer automatiquement des clefs sur le morpher :
			if (Duik.settings.morpherCreatesKeyframes)
			{
			//nombre de clefs
			var nbreClefs = effet.numKeys;
			//duree d'image de la compo
			var ips = app.project.activeItem.frameDuration;
			var temps = 0;
			var prop = effet;
			for (var k=1;k<=nbreClefs;k++)
			{
			//recupere l'instant de la clef
			temps = prop.keyTime(k);
			//cree une image clef sur le morpher
			morpher(1).setValueAtTime(temps,temps/ips);
			}
			delete temps;
			delete prop;
			delete ips;
			delete nbreClefs;
			}
			}

			//boucle pour appliquer le morpher partout
			for (var i=0;i<layers.length;i++)
			{
			for (var j=0;j<layers[i].selectedProperties.length;j++)
			{
			var effet = Utils.prototype.getItem(layers,i).selectedProperties[j];
			if (effet.canSetExpression && effet.parentProperty.name != "Morpher")
			{
			effet.expression = "valueAtTime((thisComp.layer(\"" + layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
			//la boucle pour creer automatiquement des clefs sur le morpher :
			if (Duik.settings.morpherCreatesKeyframes)
			{
			//nombre de clefs
			var nbreClefs = effet.numKeys;
			//duree d'image de la compo
			var ips = app.project.activeItem.frameDuration;
			var temps = 0;
			var prop = effet;
			for (var k=1;k<=nbreClefs;k++)
			{
			//recupere l'instant de la clef
			temps = prop.keyTime(k);
			//cree une image clef sur le morpher
			morpher(1).setValueAtTime(temps,temps/ips);
			}
			delete temps;
			delete prop;
			delete ips;
			delete nbreClefs;
			}
			}
			}
			}

			return true;
		}
		/* LENS FLARE - Duik.lensFlare(layers);

		Rigs the layers to move like a lens flare.

		parameters
		layers | Array of AVLayer

		returns
		true if successful, false if anything went wrong

		*/
		LibDuik.prototype.lensFlare = function (layers)
		{
			//sortir le premier calque, le centre, et ajouter les controleurs
			var centre = layers.shift();

			//check names
			Utils.prototype.checkNames(centre.containingComp);

			var nomcentre = centre.name;
			var centerEffect;
			centerEffect = Utils.prototype.addEffect(centre,Duik.effects.LensFlare);
			centerEffect.name = Duik.uiStrings.lensFlare;
			centerEffect(1).setValue(100);
			centerEffect(2).setValue(100);

			//l'expression de position
			var positionexpression = "//Duik.LensFlare\r\n" +
			"calqueCentre = thisComp.layer(\"" + nomcentre + "\");\n\n" +
			"function positionAbs(calque) {\n" +
			"return calque.toWorld(calque.anchorPoint)\n" +
			"}\n\n" +
			"n=effect(\"" + centerEffect.name + "\")(1);\n\n" +
			"X = thisComp.width - positionAbs(calqueCentre)[0];\n" +
			"Y = thisComp.height - positionAbs(calqueCentre)[1];\n\n" +
			"i=n/100;\n" +
			"j=1-i;\n\n" +
			"if (n!=100) value + ( (  [X,Y]*(i/j) + positionAbs(calqueCentre) )*j)\n" +
			"else value + [X,Y];";

			//l'expression d'opacite
			var opaciteexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + centre.name  + "\").effect(\"" + centerEffect.name + "\")(1);\n" + "value*n/100";

			//l'expression d'echelle
			var tailleexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + nomcentre  + "\").effect(\"" + centerEffect.name + "\")(2);\n" + "value*n/100";

			//appliquer les expressions sur le centre
			centre.transform.opacity.expression = opaciteexpression;
			centre.transform.scale.expression = tailleexpression;

			//la boucle d'application des expressions et controleurs
			var nombrecalques = layers.length;
			for (var layerI = 0; layerI < nombrecalques; layerI++)
			{
			calque = layers[layerI];
			calque.position.setValue([0,0]);
			//le controleur de la distance
			var distanceEffect;
			distanceEffect = Utils.prototype.addEffect(calque,Duik.effects.LensFlareDistance);
			distanceEffect.name = Duik.uiStrings.lensFlare;
			distanceEffect(1).setValue(100/nombrecalques*(layerI+1));

			//appliquer les expressions
			calque.transform.position.expression = positionexpression;
			calque.transform.opacity.expression = opaciteexpression;
			calque.transform.scale.expression = tailleexpression;

			//fin de la boucle
			}

			//selectionner le centre (controleur)
			Utils.prototype.deselectLayers();
			centre.selected = true;
		}
		/* DISTANCE LINK - Duik.distanceLink(layer,property,parentLayer);

		Links the property to the distance of parentLayer

		parameters
		layer | AVLayer containing the property
		property | Property to rig
		parentLayer | AVLayer which distance from layer is used to rig

		returns
		true if successful, false if anything went wrong

		*/
		LibDuik.prototype.distanceLink = function (layer,prop,parentLayer)
		{
			//add effect
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.DistanceLink);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.distanceLink);
			//get the distance between the two layers
			var distance = Utils.prototype.getDistance(layer,parentLayer);
			effect(2).setValue(distance - distance/4.0);
			effect(3).setValue(distance + distance/4.0);

			//check names
			Utils.prototype.checkNames(layer.containingComp);

			if (parentLayer instanceof CameraLayer)
			{
			prop.expression = "//Duik.DistanceLink\r\n" +
			"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" +
			"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" +
			"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" +
			"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" +
			"falloff=effect(\"" + effect.name + "\")(6);\n" +
			"function positionAbs(calque) {\n" +
			"return calque.toWorld(calque.anchorPoint);\n" +
			"}\n\n" +
			"distance = length(calqueRef.position,positionAbs(thisLayer));\n" +
			"if (distMax>=distMin && falloff!=0){\n" +
			"if (distance <= distMax && distance >=distMin) {value}\n" +
			"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" +
			"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" +
			"if (distMax==0){value + distance/falloff}\n" +
			"}else {value}";
			}
			else
			{
			prop.expression = "//Duik.DistanceLink\r\n" +
			"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" +
			"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" +
			"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" +
			"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" +
			"falloff=effect(\"" + effect.name + "\")(6);\n" +
			"function positionAbs(calque) {\n" +
			"return calque.toWorld(calque.anchorPoint);\n" +
			"}\n\n" +
			"distance = length(positionAbs(calqueRef),positionAbs(thisLayer));\n" +
			"if (distMax>=distMin && falloff!=0){\n" +
			"if (distance <= distMax && distance >=distMin) {value}\n" +
			"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" +
			"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" +
			"if (distMax==0){value + distance/falloff}\n" +
			"}else {value}";
			}

			return true;
		}
		/* SPRING - Duik.spring(property, layer, simulated);

		Adds a spring effect on the property

		parameters
		property | Array of property
		simulated | if true, applies the simulated version of the spring, default: false

		returns
		true if successful, false if anything went wrong

		*/
		LibDuik.prototype.spring = function (prop, simulated)
		{
			if (prop == undefined) return;

			//search for one dimension effects, to know if we need a "bounce" checkbox
			var bounce = false;
			if (prop.propertyValueType == PropertyValueType.OneD) bounce = true;

			//if it's not a position, light version
			if (prop.matchName != "ADBE Position") simulated = false;
			if (simulated == undefined) simulated = false;

			var layer = Utils.prototype.getPropertyLayer(prop);

			var effect;
			if (bounce)
			{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.Spring_Bounce);
			var effect = prep[0];
			prop = prep[1];
			}
			else
			{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.Spring);
			var effect = prep[0];
			prop = prep[1];
			}
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.spring);

			if (bounce)
			{
			prop.expression = "//Duik.Spring\r\n" +
			"amorti = effect(\"" + effect.name + "\")(2);\n" +
			"freq = effect(\"" + effect.name + "\")(1);\n" +
			"speedLimit = effect(\"" + effect.name + "\")(4);\n" +
			"rebond = effect(\"" + effect.name + "\")(3);\n\n" +
			"if (numKeys > 1 && freq != 0 ){\n" +
			"if (nearestKey(time).index == 1) { value }\n" +
			"else {\n\n" +
			"if (length(velocity) <= speedLimit ) {\n\n" +
			"tempsClefProx = nearestKey(time).time;\n\n" +
			"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
			"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
			"temps = time - tempsDebut;\n\n" +
			"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n" +
			"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
			"if (rebond == 0) valueAtTime(tempsDebut) + spring;\n\n" +
			"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" +
			"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" +
			"}\n" +
			"else { value }\n" +
			"}\n" +
			"}\n" +
			"else { value }";
			}
			else if (!simulated)
			{
			prop.expression = "//Duik.Spring\r\n" +
			"amorti = effect(\"" + effect.name + "\")(2);\n" +
			"freq = effect(\"" + effect.name + "\")(1);\n" +
			"speedLimit = effect(\"" + effect.name + "\")(3);\n" +
			"rebond = 0;\n\n" +
			"if (numKeys > 1 && freq != 0 ){\n" +
			"if (nearestKey(time).index == 1) { value }\n" +
			"else {\n\n" +
			"if (length(velocity) <= speedLimit ) {\n\n" +
			"tempsClefProx = nearestKey(time).time;\n\n" +
			"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
			"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
			"temps = time - tempsDebut;\n\n" +
			"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n" +
			"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
			"if (rebond == 0) valueAtTime(tempsDebut) + spring;\n\n" +
			"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" +
			"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" +
			"}\n" +
			"else { value }\n" +
			"}\n" +
			"}\n" +
			"else { value }";
			}
			else
			{
			prop.expression = "//Duik.spring\r\n" +
			"amorti = effect(\"" + effect.name + "\")(2);\n" +
			"freq = effect(\"" + effect.name + "\")(1);\n" +
			"if (amorti == 0) amorti = 0.1;\n" +
			"if (freq == 0) freq = 0.1;\n" +
			"retard = freq/amorti;\n" +
			"poids = 1/amorti/10;\n" +
			"precision = thisComp.frameDuration;\n" +
			"function worldVelocity(temps) {\n" +
			"worldVelocityX = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[0]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[0])*100;\n" +
			"worldVelocityY = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[1]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[1])*100;\n" +
			"return [worldVelocityX,worldVelocityY];\n" +
			"}\n" +
			"function worldSpeed(temps) {\n" +
			"return length(worldVelocity(temps));\n" +
			"}\n" +
			"tempsDebut = 0;\n" +
			"tempsRedemarrage = 0;\n" +
			"stop = false;\n" +
			"arrete = false;\n" +
			"for (i=timeToFrames(time);i>=0;i--) {\n" +
			"var instant = framesToTime(i);\n" +
			"var instantSuivant = instant-precision;\n" +
			"if (worldSpeed(instant) == 0 ) {\n" +
			"if (tempsRedemarrage == 0) tempsRedemarrage = instant;\n" +
			"if (worldSpeed(instantSuivant) !=0 ) {\n" +
			"tempsDebut = instantSuivant;\n" +
			"break;\n" +
			"}\n" +
			"}\n" +
			"}\n" +
			"temps = time-tempsDebut;\n" +
			"frameRedemarre = timeToFrames( time-tempsRedemarrage);\n" +
			"valeur = value\n" +
			"if ( frameRedemarre <= retard)\n" +
			"valeur = value - worldVelocity(time)*poids*(frameRedemarre/retard);\n" +
			"else\n" +
			"valeur = value - worldVelocity(time)*poids;\n" +
			"if (worldSpeed(time) == 0) {\n" +
			"spring = worldVelocity(tempsDebut) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n" +
			"valeur + spring;\n" +
			"}else{ valeur; }\n";
			}

			return true;
		}
		/* PATH FOLLOW - Duik.pathFollow(layer);

		Automates the rotation of the layer so it follows its path.

		parameters
		layer | AVLayer

		returns
		void

		*/
		LibDuik.prototype.pathFollow = function (layer)
		{
			//expression a inserer
			layer.transform.rotation.expression  = "//Duik.PathFollow\n" +
			"ff = framesToTime(1);\r\n" +
			"pos = thisLayer.position;\r\n" +
			"if (pos.numKeys > 1){\n" +
			"A = pos.valueAtTime(time-ff);\r\n" +
			"B =  pos.valueAtTime(time+ff);\r\n\r\n" +
			"if (pos.key(1).time > time){\r\n" +
			"A = pos.key(1).value;\r\n" +
			"B =pos.valueAtTime(pos.key(1).time+ff);\r\n" +
			"}\r\n\r\n" +
			"if (thisLayer.position.key(thisLayer.position.numKeys).time < time){\r\n" +
			"A = pos.valueAtTime(pos.key(pos.numKeys).time-ff);\r\n" +
			"B = pos.key(pos.numKeys).value;\r\n" +
			"}\r\n\r\n" +
			"angle = lookAt(A,B);\r\n" +
			"angle[0] > 0 ? angle[0]+angle[1]+value : angle[0]-angle[1]+value;\r\n" +
			"} else value;";
		}
		/**
			 * MULTIPLANE - Duik.multiplane(numLayers);
			 * Creates null objects rigged to easily animate a 2D multiplane camera.
			 *
			 * @param {CompItem}	comp		The containing comp. Ignored if layers are provided. Default: app.project.activeItem
			 * @param {number}		numLayers	The number of layers to create. Ignored if layers are provided. Default: 3
			 * @param {int}			camIndex	The index of the camera controller. Default: numLayers/2
			 * @param {Array}		layers		The layers to automatically link to the controllers. Optional
			 */
		LibDuik.prototype.multiplane = function (comp,numLayers,camIndex,layers)
		{
				if (!comp) comp = app.project.activeItem;
				if (!comp) throw "Param 1 missing. A comp is needed to create the controllers.";
				if (!(comp instanceof CompItem)) throw "Param 1 is not a composition.";
				if (numLayers == undefined) numLayers = 3;
				if (layers == undefined) layers = [];
				if (layers.length)
				{
					numLayers = layers.length;
					layers = Utils.prototype.sortLayersByIndex(layers);
				}
				if (camIndex == undefined) camIndex = Math.ceil(numLayers/2);
				if (camIndex < 0) camIndex = Math.ceil(numLayers/2);
				if (camIndex > numLayers) camIndex = Math.ceil(numLayers/2);

				var calqueCam;

				for (var i=1;i<=numLayers;i++)
				{
					var name = '';
					i < 10 ? name = "L0" + i : name = "L" + i ;
					if (layers.length) name = name + '_' + layers[i-1].name;

					//creer les nuls et leurs zeros
					if (i == camIndex)
					{
						if (Duik.settings.controllerType == Duik.layerTypes.VECTOR)
						{
							var cam = Duik.addController();
							cam.camera = true;
							cam.update();
							calqueCam = cam.layer;
						}
						else
						{
							var calqueCam = app.project.activeItem.layers.addNull();
						}

						//Creer un ctrl cam
						calqueCam.name = name + ' CAMERA';


						//ajouter un zero
						Duik.addZero(calqueCam);
					}
					else
					{
						var calque = app.project.activeItem.layers.addNull() ;
						calque.name = name;
						//ajouter un zero
						Duik.addZero(calque);
					}
				}

				//cam effect
				var effect = Utils.prototype.addEffect(calqueCam,Duik.effects.Multiplane);
				effect.name = Duik.uiStrings.multiplane;

				//cam rig
				var camZero = calqueCam.parent;
				//tilt
				camZero.transform.rotation.expression = "//Duik.multiplane\n" +
				"thisComp.layer(\"" + calqueCam.name + "\").effect(\"" + Duik.uiStrings.multiplane + "\")(4);";
				//zoom & truck in/out
				camZero.transform.scale.expression = "//Duik.multiplane\n" +
				"var zoom = thisComp.layer(\"" + calqueCam.name + "\").effect(\"" + Duik.uiStrings.multiplane + "\")(2);\n" +
				"var truck = thisComp.layer(\"" + calqueCam.name + "\").effect(\"" + Duik.uiStrings.multiplane + "\")(3);\n" +
				"value + [zoom,zoom] + [truck,truck];";
				//pan
				camZero.transform.position.expression = "//Duik.multiplane\n" +
				"thisComp.layer(\"" + calqueCam.name + "\").effect(\"" + Duik.uiStrings.multiplane + "\")(1);";

				//ajouter les expressions et curseurs
				var numLayersAbove = calqueCam.index-1;
				var numLayersUnder = numLayers - calqueCam.index;
				for (var i=1;i<=numLayers;i++)
				{
					//si on n'est pas sur le calque cam
					if (i != calqueCam.index)
					{
						var calque = comp.layer(i);
						var zero = calque.parent;

						//add position expression
						var curseur = calque.Effects.addProperty("ADBE Slider Control");
						curseur.name = Duik.uiStrings.camInfluence;
						(i<calqueCam.index+1) ? curseur(1).setValue(1+(numLayersAbove-i+1)*.2) : curseur(1).setValue((1/(camIndex+1))*Math.abs(i-numLayers-2)) ;
						delete curseur;
						calque.transform.position.expression = "//Duik.multiplane\nthisComp.layer(\"" + calqueCam.name + "\").position * effect(\"" + curseur.name + "\")(1)";

						//rig the zero
						//tilt
						zero.transform.rotation.expression = "//Duik.multiplane\n" +
						"thisComp.layer(\"" + calqueCam.name + "\").effect(\"" + Duik.uiStrings.multiplane + "\")(4);";

						//zoom & truck in/out
						zero.transform.scale.expression = "//Duik.multiplane\n" +
						"var zoom = thisComp.layer(\"" + calqueCam.name + "\").effect(\"" + Duik.uiStrings.multiplane + "\")(2);\n" +
						"var truck = thisComp.layer(\"" + calqueCam.name + "\").effect(\"" + Duik.uiStrings.multiplane + "\")(3);\n" +
						"var infl = thisComp.layer(\"" + calque.name + "\").effect(\"" + curseur.name + "\")(1);\n" +
						"value + [zoom,zoom] + [truck,truck]*infl;";

						//pan
						zero.transform.position.expression = "//Duik.multiplane\n" +
						"thisComp.layer(\"" + calqueCam.name + "\").effect(\"" + Duik.uiStrings.multiplane + "\")(1);";
					}
				}

				// Parent layers
				if (layers.length)
				{
					for (var i = 0 ; i<layers.length;i++)
					{
						layers[i].parent = comp.layer(i+1);
					}
				}

				Utils.prototype.deselectLayers();
				calqueCam.selected = true;
			}
		/**
			 * Copies all the animations (except expressions) on selected layers, and store them in Duik.copiedAnim.
			 * @memberof Duik
			 * @param {Array}	layers 				An array of Layers or LayerCollection with the animation
			 * @param {boolean}	selectedKeysOnly	Wether to copy only selected keys or not
			 * @param {float}	startTime			The start time of the anim to copy. Default: Composition start time
			 * @param {float}	endTime				The end time of the anim to copy. Default: Composition end time
			 * @return {Array}	An array of LayerAnim
			 */
		LibDuik.prototype.copyAnim = function (layers,selectedKeysOnly,startTime,endTime)
		{
				if (layers.length == 0)
				{
					return null;
				}

				var comp = Utils.prototype.getItem(layers,0).containingComp;

				if (selectedKeysOnly == undefined) selectedKeysOnly = false;
				if (startTime == undefined) startTime = comp.workAreaStart;
				if (endTime == undefined) endTime = comp.workAreaDuration + comp.workAreaStart;

				Duik.copiedAnim = [];

				//for each layer
				for (var layerIndex = 0; layerIndex < layers.length ; layerIndex++)
				{
					var layerAnim = new LayerAnim();
					var l = Utils.prototype.getItem(layers,layerIndex);
					layerAnim._name = l.name;
					layerAnim._index = l.index;

					// transforms
					layerAnim.transformAnims = Utils.prototype.getPropertyAnims(l.transform,selectedKeysOnly,false,startTime,endTime);

					// masks
					for (var maskIndex=1;maskIndex<=l("Masks").numProperties;maskIndex++)
					{
						var maskAnim = new MaskAnim();
						maskAnim._name = l("Masks")(maskIndex).name;
						maskAnim._matchName = l("Masks")(maskIndex).matchName;
						maskAnim.anims = Utils.prototype.getPropertyAnims(l("Masks")(maskIndex),selectedKeysOnly,false,startTime,endTime);
						if (maskAnim.anims.length >=1) layerAnim.masksAnims.push(maskAnim);
					}

					// effects
					for (var effectIndex=1;effectIndex<=l("Effects").numProperties;effectIndex++)
					{
						var effectAnim = new EffectAnim();
						effectAnim._name = l("Effects")(effectIndex).name;
						effectAnim._matchName = l("Effects")(effectIndex).matchName;
						effectAnim.anims = Utils.prototype.getPropertyAnims(l("Effects")(effectIndex),selectedKeysOnly,false,startTime,endTime);
						if (effectAnim.anims.length >=1) layerAnim.effectsAnims.push(effectAnim);
					}
					Duik.copiedAnim.push(layerAnim);
				}
				return Duik.copiedAnim;
			}
		/* PASTE ANIM - Duik.pasteAnim(layers,layerAnims,startTime,getLayerMethod);

		Paste all the animations in the Array of LayerAnim on layers, using layer names or layer indexes, beginning at startTime

		parameters
		layers | Layers where to paste the animation
		layerAnims | Array of LayerAnim, default: Duik.copiedAnim
		startTime | float, default: comp.time
		getLayerMethod | one of Duik.getLayers.NAME, Duik.getLayers.INDEX, Duik.getLayers.SELECTION_INDEX, default: Duik.settings.getLayersMethod

		returns
		integer, number of layers where animations were pasted

		*/
		LibDuik.prototype.pasteAnim = function (layers,layerAnims,startTime,getLayerMethod)
		{
				if (layers == undefined) return 0;
				if (layers.length == 0) return 0;
				if (layerAnims == undefined) layerAnims = Duik.copiedAnim;
				if (getLayerMethod == undefined) getLayerMethod = Duik.settings.getLayersMethod;
				var comp = Utils.prototype.getItem(layers,0).containingComp;
				if (startTime == undefined) startTime = comp.time;

				var totalPasted = 0;

				for (var li = 0;li < layers.length;li++)
				{
					var l = Utils.prototype.getItem(layers,li);
					var layerAnim = null;
					//parcourir les animations sauvees pour trouver celle qui matche le calque
					if (getLayerMethod == Duik.getLayers.INDEX)
					{
						for (var ai = 0;ai < layerAnims.length;ai++)
						{
							if (layerAnims[ai]._index == l.index)
							{
								layerAnim = layerAnims[ai];
								break;
							}
						}
					}
					else if (getLayerMethod == Duik.getLayers.NAME)
					{
						for (var ai = 0; ai < layerAnims.length ; ai++)
						{
							if (layerAnims[ai]._name == l.name)
							{
								layerAnim = layerAnims[ai];
								break;
							}
						}
					}
					else if (getLayerMethod == Duik.getLayers.SELECTION_INDEX)
					{
						if (li < layerAnims.length) layerAnim = layerAnims[li];
					}

					if (layerAnim == null) continue;

					totalPasted++;

					//transform
					if (layerAnim.transformAnims.length > 0)
					{
						for (var j = 0;j< layerAnim.transformAnims.length; j++)
						{
							Utils.prototype.setPropertyAnim(l.transform,layerAnim.transformAnims[j],startTime);
						}
					}

					//masks
					if (layerAnim.masksAnims.length > 0)
					{
						for (var j = 0;j< layerAnim.masksAnims.length; j++)
						{
							for (var k = 1;k<=l("Masks").numProperties;k++)
							{
								if (l("Masks")(k).name == layerAnim.masksAnims[j]._name)
								{
									for (var mi = 0;mi < layerAnim.masksAnims[j].anims.length;mi++)
									{
										Utils.prototype.setPropertyAnim(l("Masks")(layerAnim.masksAnims[j]._name),layerAnim.masksAnims[j].anims[mi],startTime);
									}
									break;
								}
							}
						}
					}

					//effects
					if (layerAnim.effectsAnims.length > 0)
					{
						for (var j = 0;j< layerAnim.effectsAnims.length; j++)
						{
							for (var k = 1;k<=l("Effects").numProperties;k++)
							{
								if (l("Effects")(k).name == layerAnim.effectsAnims[j]._name && l("Effects")(k).matchName == layerAnim.effectsAnims[j]._matchName)
								{
									for (var ei = 0;ei < layerAnim.effectsAnims[j].anims.length;ei++)
									{
										Utils.prototype.setPropertyAnim(l("Effects")(layerAnim.effectsAnims[j]._name),layerAnim.effectsAnims[j].anims[ei],startTime);
									}
									break;
								}
							}
						}
					}
				}
				return totalPasted;
			}
		/* RIG PAINT - Duik.rigPaint(layers);

		Rigs the paint effects to be able to animate all strokes as if there was only one.

		parameters
		layers | Array of Layers or LayerCollection which have a paint effect

		returns
		void

		*/
		LibDuik.prototype.rigPaint = function (layrs)
		{
			var layers = Utils.prototype.convertCollectionToArray(layrs);
			for (var i = 0 ; i < layers.length ; i++)
			{
			var layer = layers[i];

			//if there's no paint effect
			var paintEffect = layer("Effects")("ADBE Paint");
			if (paintEffect == null) continue;

			//add effect
			var effect;
			effect = Utils.prototype.addEffect(layer,Duik.effects.Paint_Rig);

			effectName = Duik.uiStrings.paintRig;
			effect.name = effectName;

			//need to get the paint effect again after addProperty, After Effects bug.......
			var paintEffect = layer("Effects")("ADBE Paint");

			//for each stroke
			var nbre = paintEffect.property(2).numProperties;
			for (var j=1;j<=nbre;j++)
			{
			var stroke = paintEffect.property(2).property(j);
			var propStart = stroke.property(4).property(1);
			var propEnd = stroke.property(4).property(2);
			var propDiam = stroke.property(4).property(4);

			propStart.expression = "//Duik.PaintRig\n" +
			"var ctrl = effect(\"" + effectName + "\")(1);\n" +
			"var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n" +
			"var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n" +
			"result = ctrl - ((100/total)*(ind-1));\n" +
			"result = result * total;\n" +
			"result;";

			propEnd.expression = "//Duik.PaintRig\n" +
			"var ctrl = effect(\"" + effectName + "\")(2);\n" +
			"var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n" +
			"var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n" +
			"result = ctrl - ((100/total)*(ind-1));\n" +
			"result = result * total;\n" +
			"result;";

			propDiam.expression = "//Duik.PaintRig\n" +
			"value+effect(\"" + effectName + "\")(3);";
			}
			}
		}
		/* BLINK - Duik.blink(layer,prop);

		Adds a blink effect to the property.

		parameters
		layer | AVLayer
		prop | Property

		returns
		true if successful, false if anything went wrong

		*/
		LibDuik.prototype.blink = function (layer,prop)
		{
			var dim = Utils.prototype.getPropertyDimensions(prop);
			if (dim == 1)
			{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.Blink_1D);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.blink);

			prop.expression = "//Duik.blink\r\n" +
			"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
			"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
			"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
			"var offValue = effect(\"" + effect.name + "\")(4);\r\n" +
			"freq= timeToFrames(1)/freq;\r\n" +
			"var currentFrame = timeToFrames(time)+offset;\r\n" +
			"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
			"else value;";
			}
			else if (dim == 2)
			{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.Blink_2D);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.blink);

			prop.expression = "//Duik.blink\r\n" +
			"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
			"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
			"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
			"var offValue = [effect(\"" + effect.name + "\")(4),effect(\"" + effect.name + "\")(5)];\r\n" +
			"freq= timeToFrames(1)/freq;\r\n" +
			"var currentFrame = timeToFrames(time)+offset;\r\n" +
			"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
			"else value;";
			}
			else if (dim == 3)
			{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.Blink_3D);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.blink);

			prop.expression = "//Duik.blink\r\n" +
			"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
			"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
			"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
			"var offValue = [effect(\"" + effect.name + "\")(4),effect(\"" + effect.name + "\")(5),effect(\"" + effect.name + "\")(6)];\r\n" +
			"freq= timeToFrames(1)/freq;\r\n" +
			"var currentFrame = timeToFrames(time)+offset;\r\n" +
			"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
			"else value;";
			}

			return true;
		}
		/* LOCK PROPERTY - Duik.lockProperty(layer,prop);

		Locks the property with a simple expression.

		parameters
		prop | Property

		returns
		void

		*/
		LibDuik.prototype.lockProperty = function (prop)
		{
			if (prop.canSetExpression)
			{
			prop.expression = uneval(prop.value);
			}
		}
		/**
			 * Links the distance of the layer from the camera to its scale so its apparent size won't change.
			 * If multiple cameras, include the camera used in the array
			 *
			 * If the layer is already linked, then the link is removed, it acts as a toggle.
			 *
			 * SCALE Z-LINK - Duik.scaleZLink(layers);
			 *
			 * @param {LayerCollection} layrs		- The layers to scale-link
			*/
		LibDuik.prototype.scaleZLink = function (layrs)
		{
				if (layrs == undefined) return;
				if (layrs.length == 0) return;

				var camera = null;
				//find camera
				var layers = Utils.prototype.convertCollectionToArray(layrs);

				for (i = 0 ; i <layers.length;i++)
				{
					var l = layers[i];
					if (l instanceof CameraLayer)
					{
						camera = l;
						break;
					}
				}

				if (camera == null)
				{
					var comp = layers[0].containingComp;

					for (var i = 1;i<=comp.layers.length;i++)
					{
						var l = comp.layers[i];
						if (l instanceof CameraLayer)
						{
							camera = l;
							break;
						}
					}
				}

				if (camera == null) return;

				//go!

				for (i = 0 ; i <layers.length;i++)
				{
					var layer = layers[i];

					var currentDistance = Utils.prototype.getDistance(layer,camera);
					if (currentDistance == 0) currentDistance = 1;
					var currentScale = layer.transform.scale.value;

					var alreadyLinked = false;

					{
						var expr = layer.transform.scale.expression;
						if(expr.lastIndexOf("//Duik.scaleZLink\n", 0) === 0) alreadyLinked = true;
					}

					if(alreadyLinked)
					{
						var scale = layer.transform.scale.value;
						layer.transform.scale.expression = "";

						var prop = layer.Effects.property(Duik.uiStrings.scale);
						if (prop != null) prop.remove();
						layer.transform.scale.setValue(scale);
					}
					else
					{
						if (!layer.threeDLayer) layer.threeDLayer = true;
						if (!layer.threeDLayer) continue;

						var effect = layer.Effects.addProperty("ADBE Slider Control");
						effect.name = Duik.uiStrings.scale;


						effect(1).setValue(currentScale[0]);

						layer.transform.scale.expression = "//Duik.scaleZLink\n" +
							"var sca = effect(\"" + effect.name + "\")(1);\n" +
							"var C = thisComp.layer(\"" + camera.name + "\").position;\n" +
							"var O = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
							"var oDist = " + currentDistance + ";\n" +
							"if (sca != 0) {\n" +
							"var factor = oDist / sca;\n" +
							"var dist = length(C,O);\n" +
							"var result = dist/factor;\n" +
							"result = [result,result,result];\n" +
							"result = result ;\n" +
							"result;\n" +
							"} else [0,0,0];";
					}

				}
			}
		/* SMART TIME REMAP - Duik.timeRemap(layers);

		Activates the time remapping of the layers, extending them to the length of the comp and
		adjusting the last keyframe.

		parameters
		layers | Array of Layer or LayerCollection
		loopType | String, "in" or "out" or "none", default: "none"

		returns
		void

		*/
		LibDuik.prototype.timeRemap = function (layrs,loopType)
		{
			if (layrs == undefined) return;
			if (layrs.length == 0 ) return;
			var layers = Utils.prototype.convertCollectionToArray(layrs);
			for (var i = 0 ; i < layers.length ; i++)
			{
			var layer = layers[i];
			if (!layer.canSetTimeRemapEnabled) continue;

			var comp = layer.containingComp;
			var lastValueTime = layer.outPoint - comp.frameDuration;

			if (!layer.timeRemapEnabled) layer.timeRemapEnabled = true;

			layer.timeRemap.setValueAtTime(lastValueTime,layer.timeRemap.valueAtTime(lastValueTime,true));
			layer.timeRemap.removeKey(3);
			if (loopType == "out")
			{
			layer.timeRemap.setValueAtTime(lastValueTime+comp.frameDuration,0);
			layer.timeRemap.expression = "loopOut();";
			}
			if (loopType == "in")
			{
			layer.timeRemap.setValueAtTime(lastValueTime+comp.frameDuration,0);
			layer.timeRemap.expression = "loopIn();";
			layer.inPoint = 0;
			}
			}
		}
		/**
			 * Activates or deactivates an onion skin on paint effects on the layer.
			 * @param {AVLayer}		layer		The layer where the paint effect will be applied
			 * @param {OnionSkin}	onionSkin	The onionSkin object. Default: new OnionSkin()
			 */
		LibDuik.prototype.onionSkin = function (layer,onionSkin)
		{
				if (layer == undefined) throw "Duik.onionSin needs a layer to work";
				if (onionSkin == undefined)
				{
					onionSkin = new OnionSkin();
					onionSkin.activated = true;
				}
				activate = onionSkin.activated;
				onionDuration = onionSkin.duration;
				exposure = onionSkin.exposure;
				inOpacity = onionSkin.inOpacity;
				outOpacity = onionSkin.outOpacity;

				var comp = layer.containingComp;
				for (var i = 1 ; i <= layer.Effects.numProperties ; i++)
				{
					var paint = layer.effect(i);
					if (paint.matchName != "ADBE Paint") continue;
					for (var j = 1 ; j <= paint.property("ADBE Paint Group").numProperties ; j++)
					{
						var stroke = paint.property("ADBE Paint Group")(j);
						if (stroke.matchName != "ADBE Paint Atom") continue;

						var inPoint = stroke.property("ADBE Paint Duration").value[0];
						var duration = stroke.property("ADBE Paint Duration").value[1];

						//adjust expo
						if (stroke.name.indexOf("#Duik") < 0)
						{
							duration = exposure*comp.frameDuration;
							stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
							stroke.name = stroke.name + " #Duik";
						}

						if (activate)
						{
							//stroke.property("ADBE Paint Transfer Mode") : blending mode
							var outPoint = duration + inPoint;
							var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
							//if keyframes (already activated)
							if (opacity.numKeys > 0)
							{
								if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0)
								{
									outPoint = opacity.keyTime(2) - layer.startTime;
								}
								else if (stroke.name.indexOf("#Out") < 0 && stroke.name.indexOf("#In") >= 0)
								{
									inPoint = opacity.keyTime(3) - layer.startTime;
								}
								else if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") >= 0)
								{
									inPoint = opacity.keyTime(3) - layer.startTime;
									outPoint = opacity.keyTime(5) - layer.startTime;
								}

								//remove keys
								while (opacity.numKeys>0)
								{
									opacity.removeKey(1);
								}
								opacity.setValue(100);
								stroke.name = stroke.name.replace(/ #Out/g,"");
								stroke.name = stroke.name.replace(/ #In/g,"");
							}

							//set duration
							if (outOpacity > 0 && inOpacity <= 0)
							{
								duration = outPoint - inPoint + onionDuration*comp.frameDuration;
								stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
							}
							else if (outOpacity <= 0 && inOpacity > 0)
							{
								duration = outPoint - inPoint + onionDuration*comp.frameDuration;
								stroke.property("ADBE Paint Duration").setValue([inPoint-onionDuration*comp.frameDuration,duration]);
							}
							else
							{
								duration = outPoint - inPoint + 2*onionDuration*comp.frameDuration;
								stroke.property("ADBE Paint Duration").setValue([inPoint-onionDuration*comp.frameDuration,duration]);
							}


							//add keyframes
							if (outOpacity > 0)
							{
							opacity.setValueAtTime(outPoint-comp.frameDuration+layer.startTime,100);
							opacity.setValueAtTime(outPoint+layer.startTime,outOpacity);
							opacity.setValueAtTime(outPoint + onionDuration*comp.frameDuration+layer.startTime,0);
							stroke.name = stroke.name + " #Out";
							}
							if (inOpacity > 0)
							{
							opacity.setValueAtTime(inPoint+layer.startTime,100);
							opacity.setValueAtTime(inPoint-onionDuration*comp.frameDuration+layer.startTime,0);
							opacity.setValueAtTime(inPoint-comp.frameDuration+layer.startTime,inOpacity);
							stroke.name = stroke.name + " #In";
							}

						}
						else
						{
							var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
							if (opacity.numKeys > 0)
							{
							inPoint = 0;
							outPoint = 1;
							if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0)
							{
							inPoint = stroke.property("ADBE Paint Duration").value[0];
							outPoint = opacity.keyTime(2);
							}
							else if (stroke.name.indexOf("#Out") < 0 && stroke.name.indexOf("#In") >= 0)
							{
							outPoint = stroke.property("ADBE Paint Duration").value[0] + stroke.property("ADBE Paint Duration").value[1];
							inPoint = opacity.keyTime(3);
							}
							else if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") >= 0)
							{
							inPoint = opacity.keyTime(3);
							outPoint = opacity.keyTime(5);
							}


							while (opacity.numKeys>0)
							{
							opacity.removeKey(1);
							}
							opacity.setValue(100);
							//set duration
							var o = outPoint-inPoint;
							var i = inPoint;
							if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0) o = o-layer.startTime;
							else if (stroke.name.indexOf("#Out") < 0) o = o + layer.startTime;
							if (stroke.name.indexOf("#In") >= 0) i = i-layer.startTime;

							stroke.property("ADBE Paint Duration").setValue([i,o]);

							stroke.name = stroke.name.replace(/ #In/g,"");
							stroke.name = stroke.name.replace(/ #Out/g,"");
							}
						}
					}
				}
				//deselect
				while(layer.selectedProperties.length > 0)
				{
					layer.selectedProperties[0].selected = false;
				}
			}
		/* ONION SKIN - Duik.getOnionSkin(layer);

		Gets current onion skin parameters from the layer.

		parameters
		layer | AVLayer

		returns
		OnionSkin object

		*/
		LibDuik.prototype.getOnionSkin = function (layer)
		{
			var onionSkin = new OnionSkin();
			if (layer == undefined) return onionSkin;


			var comp = layer.containingComp;
			for (var i = 1 ; i <= layer.Effects.numProperties ; i++)
			{
			var paint = layer.effect(i);
			if (paint.matchName != "ADBE Paint") continue;
			for (var j = 1 ; j <= paint.property("ADBE Paint Group").numProperties ; j++)
			{
			var stroke = paint.property("ADBE Paint Group")(j);
			if (stroke.matchName != "ADBE Paint Atom") continue;

			var inPoint = stroke.property("ADBE Paint Duration").value[0];
			var duration = stroke.property("ADBE Paint Duration").value[1];
			var outPoint = inPoint + duration;

			var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");

			if (stroke.name.indexOf("#In") >=0 && stroke.name.indexOf("#Out") >=0)
			{
			onionSkin.activated = true;
			onionSkin.duration = (opacity.keyTime(3) - inPoint)/comp.frameDuration;
			onionSkin.inOpacity = opacity.keyValue(2);
			onionSkin.outOpacity = opacity.keyValue(5);
			onionSkin.exposure = (opacity.keyTime(4) - opacity.keyTime(3))/comp.frameDuration;
			}
			else if (stroke.name.indexOf("#In") >=0 && stroke.name.indexOf("#Out") < 0)
			{
			onionSkin.activated = true;
			onionSkin.duration = (opacity.keyTime(3) - inPoint)/comp.frameDuration;
			onionSkin.inOpacity = opacity.keyValue(2);
			onionSkin.outOpacity = 0;
			onionSkin.exposure = (outPoint - opacity.keyTime(3))/comp.frameDuration;
			}
			else if (stroke.name.indexOf("#In") < 0 && stroke.name.indexOf("#Out") >= 0)
			{
			onionSkin.activated = true;
			onionSkin.duration = (opacity.keyTime(3) - opacity.keyTime(2))/comp.frameDuration;
			onionSkin.inOpacity = 0;
			onionSkin.outOpacity = opacity.keyValue(2);
			onionSkin.exposure = (opacity.keyTime(2) - inPoint)/comp.frameDuration;
			}
			else
			{
			onionSkin.activated = false;
			}
			break;
			}
			}

			return onionSkin;
		}
		/* IMPORT RIG IN COMP - Duik.importRigInComp(comp,rigComp,rigName);

		Imports a rig in the comp, transferring and linking the controllers in the new comp, while keeping the rig precomposed.
		The rig comp is duplicated, including precomps, renamed, and expressions are updated, so that one can import the same rig seeveral times.

		parameters
		comp | CompItem, the comp where to import the rig
		rigComp | CompItem, the comp containing the rig
		rigName | the name of this instance of the rig, must be unique in the project

		returns
		void

		*/
		LibDuik.prototype.importRigInComp = function (comp, characterComp, characterName)
		{
			app.beginSuppressDialogs();

			//duplicate character comp
			var characterComp = Utils.prototype.duplicateComp(characterComp,characterName + "_");

			//add character comp in the comp
			var characterLayer = comp.layers.add(characterComp);

			//Create a null object to get world coordinates of the zeros in the character comp
			var tempNull = characterComp.layers.addNull();
			//check if all controllers have a zero, create it if needed
			//get world pos of the zeros
			var zerosPos = [];
			var characterZeros = [];
			var characterControllers = Utils.prototype.getControllers(characterComp.layers);

			if (Duik.settings.displayProgressPanel) Duik.ui.showProgressPanel(characterControllers.length*4,"Preparing controllers and zeros");
			var progressValue = 0;

			for (var i = 0;i<characterControllers.length;i++)
			{
			progressValue++;
			if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue);

			var zero = characterControllers[i].layer.parent;
			if (zero == null || zero.name.indexOf("Zero") != 0)
			{
			zero = Duik.addZero(characterControllers[i].layer);
			}
			//get the coordinates of the zero
			tempNull.transform.position.expression = "thisComp.layer(" + characterControllers[i].layer.parent.index + ").toWorld(thisComp.layer(" + characterControllers[i].layer.parent.index + ").anchorPoint)";
			zerosPos.push(tempNull.transform.position.value);
			characterZeros.push(zero);
			}
			tempNull.remove();

			progressValue++;
			if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Creating new controllers");

			//create the new zeros and controllers in the comp
			var newZeros = [];
			var newControllerLayers = [];
			for (var i = characterControllers.length -1; i>=0 ; i--)
			{
			progressValue++;
			if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue);

			var oldZero = characterZeros[i];
			var newZero = comp.layers.addNull();
			newZero.parent = characterLayer;
			newZero.transform.position.setValue(zerosPos[i]);
			newZero.name = "Zero_" + characterName + "_" + characterControllers[i].layer.name;
			newZero.guideLayer = true;
			newZero.shy = true;
			newZero.moveToEnd();
			newZero.enabled = false;
			newZeros.unshift(newZero);

			var oldController = characterControllers[i];
			var newController = Duik.addController(newZero,false,oldController.rotation,oldController.xPosition,oldController.yPosition,oldController.scale);
			newController.color = oldController.color;
			newController.type = oldController.type;
			newController.size = oldController.size;
			newController.arc = oldController.arc;
			newController.eye = oldController.eye;
			newController.update();
			newController.layer.name = characterName + "_" + oldController.layer.name;
			newController.layer.parent = newZero;
			newControllerLayers.unshift(newController.layer);

			//Get the effects
			for (var j = 1; j <= oldController.layer.effect.numProperties ; j++)
			{
			var oldEffect = oldController.layer.effect(j);
			var newEffect = newController.layer.effect.addProperty(oldEffect.matchName);
			newEffect.name = oldEffect.name;
			//set the properties
			Utils.prototype.linkProperties(oldEffect,newEffect);
			}

			Utils.prototype.linkProperties(oldController.layer.transform,newController.layer.transform);
			}


			progressValue++;
			if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Updating expressions");

			//update expressions (controller and zeros names have changed)

			for (var i in characterControllers)
			{
			progressValue++;
			if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,);

			//controllers
			try {
			//check names
			var oldName = characterControllers[i].layer.name;
			var newName = newControllerLayers[i].name;
			//update
			//double quotes
			var old = "layer(\"" + oldName + "\"";
			var newExpr = "layer(\"" + newName + "\"";
			Utils.prototype.replaceInLayersExpressions(newControllerLayers,old,newExpr);
			//single quotes
			var old = "layer('" + oldName + "'";
			var newExpr = "layer('" + newName + "'";
			Utils.prototype.replaceInLayersExpressions(newControllerLayers,old,newExpr);
			}
			catch (err2) {}
			//zeros
			try {
			//check names
			var oldName = characterZeros[i].name;
			var newName = newZeros[i].name;
			//update
			//double quotes
			var old = "layer(\"" + oldName + "\"";
			var newExpr = "layer(\"" + newName + "\"";
			Utils.prototype.replaceInLayersExpressions(newControllerLayers,old,newExpr);
			//single quotes
			var old = "layer('" + oldName + "'";
			var newExpr = "layer('" + newName + "'";
			Utils.prototype.replaceInLayersExpressions(newControllerLayers,old,newExpr);
			}
			catch (err2) {}
			}


			progressValue++;
			if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Linking and locking zeros");

			//link and lock the zeros in the comp
			for  (var i in characterZeros)
			{
			progressValue++;
			if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue);

			var newZero = newZeros[i];
			//Link zero
			if (characterZeros[i].parent != null)
			{
			for (var j = 1 ; j <= comp.numLayers ; j++)
			{
			if (comp.layer(j).name == characterName + "_" + characterZeros[i].parent.name)
			{
			newZero.parent = comp.layer(j);
			break;
			}
			}
			}
			newZero.locked = true;
			}


			progressValue++;
			if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Setting up master controller");

			//And finally, a master ctrl to control them all!
			var masterC = Duik.addController(characterLayer,false,true,true,true,true,false);
			masterC.layer.transform.position.setValue([masterC.layer.transform.position.value[0],comp.height-20]);
			masterC.layer.name = "MASTER_" + characterName;
			var flip = masterC.layer.effect.addProperty("ADBE Checkbox Control");
			flip.name = Duik.uiStrings.flip;
			masterC.layer.transform.scale.expression = "//Duik.importRig\n" +
			"var flip = thisLayer.effect(\"" + flip.name + "\")(1).value\n" +
			"if (flip) [-value[0],value[1]]\n" +
			"else value";
			characterLayer.parent = masterC.layer;
			characterLayer.locked = true;

			if (Duik.settings.displayProgressPanel) Duik.ui.hideProgressPanel();

			app.endSuppressDialogs(false);
		}
		/* DUPLICATE RIG - Duik.duplicateRig(rigComp,rigName);

		Duplicates a rig, including precomps, renamed, and expressions are updated, so that one can duplicate the same rig several times.

		parameters
		rigComp | CompItem, the comp containing the rig
		rigName | the name of this instance of the rig, must be unique in the project

		returns
		void

		*/
		LibDuik.prototype.duplicateRig = function (characterComp, characterName)
		{
			app.beginSuppressDialogs();

			//duplicate character comp
			var characterComp = Utils.prototype.duplicateComp(characterComp,characterName + "_");


			app.endSuppressDialogs(false);
		}
		/* MOVE AWAY - Duik.moveAway(layer);

		Rigs the position of the layer to be able to move it away from its parent with a simple slider.

		parameters
		layer | AVLayer

		returns
		void

		*/
		LibDuik.prototype.moveAway = function (layer)
		{
			if (layer == undefined) return;
			var effect = layer.Effects.addProperty("ADBE Slider Control");
			effect.name = Duik.uiStrings.moveAway;

			layer.transform.position.expression = "//Duik.moveAway\n" +
			"if (thisLayer.hasParent)\n" +
			"{\n" +
			"thisWorldPos = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
			"parentWorldPos = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
			"depl = effect(\"" + effect.name  + "\")(1)\n" +
			"dist = length(parentWorldPos ,thisWorldPos )\n" +
			"coef = (dist+depl)/dist\n" +
			"newWorldPos = (thisWorldPos-parentWorldPos)*coef+parentWorldPos\n" +
			"thisLayer.parent.fromWorld(newWorldPos)\n" +
			"}\n" +
			"else\n" +
			"{\n" +
			"value\n" +
			"}\n";
		}
		/* RANDOMIZE - Duik.randomizeProperties(props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax);

		Randomizes the values of the properties.
		Min and max values for each axis can be undefined: in this case, the axis won't be randomized.

		parameters
		props | Array of PropertyBase
		fromCurrentVal | boolean, if true, min and max values are added to current property value

		returns
		void

		*/
		LibDuik.prototype.randomizeProperties = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax)
		{
			if (props == undefined) throw "You must select the properties you want to randomize";
			if (props.length == 0) throw "You must select the properties you want to randomize";
			var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
			var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
			var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));

			for (var i = 0;i<props.length;i++)
			{
			var prop = props[i];
			if (prop.propertyType == PropertyType.PROPERTY)
			{
			//Get containing comp
			var comp = Utils.prototype.getPropertyComp(prop);
			var dim = Utils.prototype.getPropertyDimensions(prop);
			var xval = 0;
			var yval = 0;
			var zval = 0;
			//X
			if (x) xval = Duik.js.random(xMin,xMax);
			else if (dim == 1) xval = prop.value;
			else xval = prop.value[0];
			//Y
			if (dim == 2 || dim == 3 && y) yval = Duik.js.random(yMin,yMax);
			else if (dim == 3 || dim == 2) yval = 0;
			//Z
			if (dim == 3 && z) zval = Duik.js.random(zMin,zMax);
			else if (dim == 3) zval = 0;
			//SET VALUE
			var val;
			if (dim == 1) val = xval;
			if (dim == 2) val = [xval,yval];
			if (dim == 3) val = [xval,yval,zval];
			if (fromCurrentVal) val = val + prop.value;
			prop.numKeys ? prop.setValueAtTime(comp.time,val) : prop.setValue(val);
			}
			}
		}
		/* RANDOMIZE - Duik.randomizeSelectedKeys(props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax);

		Randomizes the values of the selected keyframes of the properties.
		Min and max values for each axis can be undefined: in this case, the axis won't be randomized.

		parameters
		props | Array of PropertyBase
		fromCurrentVal | boolean, if true, min and max values are added to current property value

		returns
		void

		*/
		LibDuik.prototype.randomizeSelectedKeys = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax)
		{
			if (props == undefined) throw "You must select the keyframes you want to randomize";
			if (props.length == 0) throw "You must select the keyframes you want to randomize";
			var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
			var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
			var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));
			for (var i = 0;i<props.length;i++)
			{
			var prop = props[i];
			if (prop.propertyType == PropertyType.PROPERTY)
			{
			//Get containing comp and dimensions
			var comp = Utils.prototype.getPropertyComp(prop);
			var dim = Utils.prototype.getPropertyDimensions(prop);
			//loop through selected keyframes
			for (var j = 0 ; j < prop.selectedKeys.length; j++)
			{
			var key = prop.selectedKeys[j];
			var xval = 0;
			var yval = 0;
			var zval = 0;
			//X
			if (x) xval = Duik.js.random(xMin,xMax);
			else if (dim == 1) xval = prop.value;
			else xval = prop.value[0];
			//Y
			if (dim == 2 || dim == 3 && y) yval = Duik.js.random(yMin,yMax);
			else if (dim == 3 || dim == 2) yval = 0;
			//Z
			if (dim == 3 && z) zval = Duik.js.random(zMin,zMax);
			else if (dim == 3) zval = 0;
			//SET VALUE
			var val;
			if (dim == 1) val = xval;
			if (dim == 2) val = [xval,yval];
			if (dim == 3) val = [xval,yval,zval];
			if (fromCurrentVal) val = val + prop.keyValue(key);
			prop.setValueAtKey(key,val);
			}
			}
			}
		}
		/* RANDOMIZE - Duik.randomizeSelectedKeys(layrs,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax);

		Randomizes the values of the selected keyframes of the properties.
		Min and max values for each axis can be undefined: in this case, the axis won't be randomized.

		parameters
		layrs | Array or Collection of Layers
		fromCurrentVal | boolean, if true, min and max values are added to current property value

		returns
		void

		*/
		LibDuik.prototype.randomizeSelectedKeyTimes = function (layrs,fromCurrentVal,min,max)
		{
			if (layrs == undefined) throw "You must select the keyframes you want to randomize";
			if (layrs.length == 0) throw "You must select the keyframes you want to randomize";
			var x = (min != undefined && max != undefined && !isNaN(min) && !isNaN(max));
			if (!x) throw "You must define a randomizing range";

			var layers = Utils.prototype.convertCollectionToArray(layrs);

			//array to list keys to be removed
			var krProps = [];
			var krKeys = [];

			for (var l = 0 ; l < layers.length; l++)
			{
			var layer = layers[l];
			var props = layer.selectedProperties;
			for (var i = 0;i<props.length;i++)
			{
			var prop = props[i];
			krProps.push(prop);
			var krK = [];
			if (prop.propertyType == PropertyType.PROPERTY)
			{
			//Get containing comp and dimensions
			var comp = Utils.prototype.getPropertyComp(prop);
			var dim = Utils.prototype.getPropertyDimensions(prop);
			//loop through selected keyframes
			for (var j = 0 ; j < prop.selectedKeys.length; j++)
			{
			var key = prop.selectedKeys[j];
			var t = Duik.js.random(min,max)*comp.frameDuration;
			//SET VALUE
			if (fromCurrentVal) r += prop.keyTime(key);
			var oldKey = Utils.prototype.getKey(prop,key);
			krK.push(prop.keyTime(key));
			Utils.prototype.addKey(prop,oldKey,t);
			}
			}
			krKeys.push(krK);
			}
			}

			for (var i = 0 ; i < krProps.length ; i++)
			{
			var prop = krProps[i];
			for (var j = 0 ; j < krKeys[i].length ; j++)
			{
			prop.removeKey(prop.nearestKeyIndex(krKeys[i][j]));
			}
			}
		}
		/* RANDOMIZE - Duik.randomizeStartTimes(layers,fromCurrentVal,min,max);

		Randomizes start times of the given layers.
		Min and Max in seconds (comp time).

		parameters
		layers | Array of Layers or LayerCollection
		fromCurrentVal | boolean, if true, min and max values are added to current property value

		returns
		void

		*/
		LibDuik.prototype.randomizeStartTimes = function (layrs,fromCurrentVal,min,max)
		{
				if (layrs == undefined) return;
				if (layrs.length == 0 ) return;

				var layers = Utils.prototype.convertCollectionToArray(layrs);
				for (var i = 0; i< layers.length;i++)
				{
					var l = layers[i];
					var comp = l.containingComp;
					var startTime = Duik.js.random(min,max)*comp.frameDuration;
					if (fromCurrentVal) l.startTime = l.startTime + startTime;
					else l.startTime = startTime;
				}
			}
		/* RANDOMIZE - Duik.randomizeInPoints(layers,fromCurrentVal,min,max);

		Randomizes start times of the given layers.
		Min and Max in seconds (comp time).

		parameters
		layers | Array of Layers or LayerCollection
		fromCurrentVal | boolean, if true, min and max values are added to current property value

		returns
		void

		*/
		LibDuik.prototype.randomizeInPoints = function (layrs,fromCurrentVal,min,max)
		{
			if (layrs == undefined) return;
			if (layrs.length == 0 ) return;

			var layers = Utils.prototype.convertCollectionToArray(layrs);

			for (var i = 0; i< layers.length;i++)
			{
			var l = layers[i];
			var comp = l.containingComp;
			var inPoint = Duik.js.random(min,max)*comp.frameDuration;
			if (fromCurrentVal) l.inPoint = l.inPoint + inPoint;
			else l.inPoint = inPoint;
			}
		}
		/* RANDOMIZE - Duik.randomizeOutPoints(layers,fromCurrentVal,min,max);

		Randomizes start times of the given layers.
		Min and Max in seconds (comp time).

		parameters
		layers | Array of Layers or LayerCollection
		fromCurrentVal | boolean, if true, min and max values are added to current property value

		returns
		void

		*/
		LibDuik.prototype.randomizeOutPoints = function (layrs,fromCurrentVal,min,max)
		{
			if (layrs == undefined) return;
			if (layrs.length == 0 ) return;

			var layers = Utils.prototype.convertCollectionToArray(layrs);

			for (var i = 0; i< layers.length;i++)
			{
			var l = layers[i];
			var comp = l.containingComp;
			var outPoint = Duik.js.random(min,max)*comp.frameDuration;
			if (fromCurrentVal) l.outPoint = l.outPoint + outPoint;
			else l.outPoint = outPoint;
			}
		}
		/* GROUP PAINT - Duik.groupPaint(props);

		Rigs the paint effects to be able to animate all strokes as if there was only one.

		parameters
		props | Array of Properties

		returns
		void

		*/
		LibDuik.prototype.groupPaint = function (props)
		{
			if (props == undefined) return;
			if (props.length == 0) return;
			//get selection
			var selection = [];
			for (var i = 0 ; i < props.length ; i++)
			{
			var stroke = props[i];
			if (stroke.matchName != "ADBE Paint Atom") continue;
			if (stroke.selected) selection.push(stroke.propertyIndex);
			}
			if (selection.length == 0) return;

			//add effect
			var effect;
			var layer = Utils.prototype.getPropertyLayer(props[0]);
			effect = Utils.prototype.addEffect(layer,Duik.effects.Paint_Group);

			var paintEffect = layer("Effects")("ADBE Paint");
			var firstStroke = paintEffect.property(2).property(selection[0]);

			Utils.prototype.renameEffect(effect,firstStroke.name + " " + Duik.uiStrings.paintGroup);

			//anchorPoint
			effect(8).setValue(firstStroke.property(5).property(1).value);
			firstStroke.property(5).property(1).expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(8);";
			//position
			effect(9).setValue(firstStroke.property(5).property(2).value);
			firstStroke.property(5).property(2).expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(9);";
			//scale
			effect(10).setValue(firstStroke.property(5).property(3).value[0]);
			firstStroke.property(5).property(3).expression = "//Duik.groupPaint\n" +
			"var sca = effect(\"" + effect.name + "\")(10);\n" +
			"[sca,sca]";
			//rotation
			effect(11).setValue(firstStroke.property(5).property(4).value);
			firstStroke.property(5).property(4).expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(11);";

			//start
			firstStroke.property(4).property(1).expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(2);\n";
			//end
			firstStroke.property(4).property(2).expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(3);\n";
			//color
			firstStroke.property(4).property(3).expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(4);\n";
			//diameter
			firstStroke.property(4).property(4).expression = "//Duik.groupPaint\n" +
			"value+effect(\"" + effect.name + "\")(5);\n";


			//for each stroke
			for (var j=1;j<selection.length;j++)
			{
			var stroke = paintEffect.property(2).property(selection[j]);
			var propStart = stroke.property(4).property(1);
			var propEnd = stroke.property(4).property(2);
			var propColor = stroke.property(4).property(3);
			var propDiam = stroke.property(4).property(4);

			propStart.expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(2);\n";

			propEnd.expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(3);";

			propColor.expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(4);";

			propDiam.expression = "//Duik.groupPaint\n" +
			"value+effect(\"" + effect.name + "\")(5);";

			stroke.property(5).property(1).expression = "//Duik.groupPaint\n" +
			"-" + stroke.property(5).property(2).value.toSource() + " + " + effect(9).value.toSource() + " + effect(\"" + effect.name + "\")(8);\n";
			stroke.property(5).property(2).expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(9);";
			stroke.property(5).property(3).expression = "//Duik.groupPaint\n" +
			"var sca = effect(\"" + effect.name + "\")(10);\n" +
			"[sca,sca]";
			stroke.property(5).property(4).expression = "//Duik.groupPaint\n" +
			"effect(\"" + effect.name + "\")(11);";
			}
		}
		/* LIST - Duik.list(prop);

		Creates a list on the prop.

		parameters
		prop | Property

		returns
		void

		*/
		LibDuik.prototype.list = function (prop)
		{
			if (prop == undefined) return;

			var dim = Utils.prototype.getPropertyDimensions(prop);
			var layer = Utils.prototype.getPropertyLayer(prop);
			var comp = layer.containingComp;

			if (dim == 1)
			{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.OneD_List);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.list);

			//set value
			effect(2).setValue(prop.value);

			//copy expression
			effect(2).expression = prop.expression;

			prop.expression = "//Duik.list\r\n" +
			"var v1 = effect(\"" + effect.name + "\")(2);\n" +
			"var w1 = effect(\"" + effect.name + "\")(3);\n" +
			"var v2 = effect(\"" + effect.name + "\")(6);\n" +
			"var w2 = effect(\"" + effect.name + "\")(7);\n" +
			"var v3 = effect(\"" + effect.name + "\")(10);\n" +
			"var w3 = effect(\"" + effect.name + "\")(11);\n" +
			"var v4 = effect(\"" + effect.name + "\")(14);\n" +
			"var w4 = effect(\"" + effect.name + "\")(15);\n" +
			"var v5 = effect(\"" + effect.name + "\")(18);\n" +
			"var w5 = effect(\"" + effect.name + "\")(19);\n" +
			"v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;";
			}
			else if (dim == 2)
			{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.TwoD_List);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.list);

			effect(2).setValue([prop.value[0],prop.value[1]]);

			if (prop.expression != "") effect(2).expression = prop.expression;

			prop.expression = "//Duik.list\r\n" +
			"var v1 = effect(\"" + effect.name + "\")(2);\n" +
			"var w1 = effect(\"" + effect.name + "\")(3);\n" +
			"var v2 = effect(\"" + effect.name + "\")(6);\n" +
			"var w2 = effect(\"" + effect.name + "\")(7);\n" +
			"var v3 = effect(\"" + effect.name + "\")(10);\n" +
			"var w3 = effect(\"" + effect.name + "\")(11);\n" +
			"var v4 = effect(\"" + effect.name + "\")(14);\n" +
			"var w4 = effect(\"" + effect.name + "\")(15);\n" +
			"var v5 = effect(\"" + effect.name + "\")(18);\n" +
			"var w5 = effect(\"" + effect.name + "\")(19);\n" +
			"v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;";
			}
			else if (dim == 3)
			{
			var prep = Utils.prototype.rigProperty(layer,prop,Duik.effects.ThreeD_List);
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			Utils.prototype.renameEffect(effect,prop.name + " " + Duik.uiStrings.list);

			effect(2).setValue([prop.value[0],prop.value[1]]);
			effect(3).setValue(prop.value[2]);

			if (prop.expression != "") effect(2).expression = prop.expression;


			prop.expression = "//Duik.list\r\n" +
			"var v1 = effect(\"" + effect.name + "\")(2);\n" +
			"var z1 = effect(\"" + effect.name + "\")(3);\n" +
			"var w1 = effect(\"" + effect.name + "\")(4);\n" +
			"var v2 = effect(\"" + effect.name + "\")(7);\n" +
			"var z2 = effect(\"" + effect.name + "\")(8);\n" +
			"var w2 = effect(\"" + effect.name + "\")(9);\n" +
			"var v3 = effect(\"" + effect.name + "\")(12);\n" +
			"var z3 = effect(\"" + effect.name + "\")(13);\n" +
			"var w3 = effect(\"" + effect.name + "\")(14);\n" +
			"var v4 = effect(\"" + effect.name + "\")(17);\n" +
			"var z4 = effect(\"" + effect.name + "\")(18);\n" +
			"var w4 = effect(\"" + effect.name + "\")(19);\n" +
			"var v5 = effect(\"" + effect.name + "\")(22);\n" +
			"var z5 = effect(\"" + effect.name + "\")(23);\n" +
			"var w5 = effect(\"" + effect.name + "\")(24);\n" +
			"[v1[0],v1[1],z1]*w1/100+[v2[0],v2[1],z2]*w2/100+[v3[0],v3[1],z3]*w3/100+[v4[0],v4[1],z4]*w4/100+[v5[0],v5[1],z5]*w5/100;";
			}

			return true;
		}
	}

	// Create the new global instance of LibDuik
	var Duik = new LibDuik();
}

delete duikUpdate;
