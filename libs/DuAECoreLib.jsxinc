/*
DuAECoreLib
Library with core After Effects tools. Contains the main class of Duduf AE Framework
Copyright (c) 2017 Nicolas Dufresne, Rainbox Productions
https://rainboxprod.coop

_Contributors:_
Nicolas Dufresne - Lead developer

This file is part of DuAEF.

DuAEF is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

DuAEF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with DuAEF. If not, see <http://www.gnu.org/licenses/>.
*/

/**
* An iterator object as returned by DuAEF.DuAE.getListIterator
* @typedef {Object} Iterator
* @property {int} min - The minimum value (inclusive)
* @property {int} max - The maximum (inclusive)
* @property {int} length - The number of items
*/

/**
* Constructs a new KeySpatialProperty
* @class KeySpatialProperties
* @classdesc Spatial properties of a {@linkcode KeyFrame}.
* @property {float[]|null}	  [inTangent=null]     - The incoming spatial tangent
* @property {float[]|null}    [outTangent=null]            -  The outgoing spatial tangent
* @property {boolean}      [_continuous=true]         - true if the specified keyframe has spatial continuity
* @property {boolean}	[_autoBezier=false]			- true if the specified keyframe has temporal auto-Bezier interpolation
* @property {boolean}	[_roving=false]	- true if the specified keyframe is roving
*/
function KeySpatialProperties (){
	this.inTangent = null;
	this.outTangent = null;
	this._continuous = true;
	this._autoBezier = false;
	this._roving = false;
}

/**
* Constructs a new KeyFrame
* @class KeyFrame
* @classdesc Properties of an After Effects Keyframe, as returned by {@linkcode DuAEF.DuAE.Property.getKeyFrames} or {@linkcode DuAEF.DuAE.Property.getKeyFrameAtIndex} or {@linkcode DuAEF.DuAE.Property.getKeyFrameAtTime}.
* @property {float}	  [_time=0]     - The keyframe time
* @property {null|folat[]|float|MarkerValue|int|Shape|TextDocument}    [value=null]  -  The keyframe value
* @property {KeyframeInterpolationType}   [_inInterpolationType=KeyframeInterpolationType.LINEAR]  - The incoming temporal interpolation type
* @property {KeyframeInterpolationType}	[_outInterpolationType=KeyframeInterpolationType.LINEAR]		- The outgoing temporal interpolation type
* @property {boolean}	[_spatial=false]	- true if this keyframe has a spatial value
* @property {KeySpatialProperties}	[spatialProperties=new KeySpatialProperties()]	- the spatial properties {@linkcode KeySpatialProperties} of this keyframe
* @property {KeyframeEase[]}	[inEase=null]	- The incoming temporal ease. The number of objects in the Array depends on the value type
* @property {KeyframeEase[]}	[outEase=null]	- The outgoing temporal ease. The number of objects in the Array depends on the value type
* @property {boolean}	[_continuous=false]	- true if the keyframe has temporal continuity
* @property {boolean}	[_autoBezier=false]	- true if the keyframe has temporal auto-Bezier interpolation
* @property {int}		[_index=0]	- The index of the keyFrame. Warning: not updated when another key frame is added on the property some time before this key._time!
*/
function KeyFrame(){
	this._time = 0;
	this.value = null;
	this._inInterpolationType = KeyframeInterpolationType.LINEAR;
	this._outInterpolationType = KeyframeInterpolationType.LINEAR;
	this._spatial = false;
	this.spatialProperties = new KeySpatialProperties();
	this.inEase = null;
	this.outEase = null;
	this._continuous = false;
	this._autoBezier = false;
	this._index = 0;
}

/**
* Constructs a new animation
* @class PropertyAnim
* @classdesc Describes the animation of an After Effects property
* @property {string}	  [_name=""]     - The property name
* @property {string}    [_matchName=""]  - The property matchName
* @property {KeyFrame[]}   [keys=[]]  - The keyframes of the animation
* @property {null|folat[]|float|MarkerValue|int|Shape|TextDocument}	[startValue=null]		- The value at the beginning of the animation
* @property {string}	[expression=""]		- The expression on the property, if any.
* @property {string}   [type="anim"]  - Read Only.
*/
function PropertyAnim()
{
	this._name = "";
	this._matchName = "";
	this.keys = [];
	this.startValue = null;
	this.type = "anim";
	this.expression = "";
	this.dimensions = 0;
}

/**
* Constructs a new group animation
* @class PropertyGroupAnim
* @classdesc Contains all PropertyAnim from an After Effects PropertyGroup
* @property {string}	  [_name=""]     - The property name
* @property {string}    [_matchName=""]  - The property matchName
* @property {PropertyAnim[]|PropertyGroupAnim[]}   [anims=[]]  - The animations in the group
* @property {string}   [type="group"]  - Read Only.
*/
function PropertyGroupAnim()
{
	this._name = "";
	this._matchName = "";
	this.anims = [];
	this.type = "group";
}

/**
* Constructs a new layer animation
* @class LayerAnim
* @classdesc Contains all PropertyGroupAnim from an After Effects Layer
* @property {string}	  [_name=""]     - The property name
* @property {int}    [_index=""]  - The index of the layer
* @property {PropertyGroupAnim[]} [anims=[]] - All the animations of the layer
* @property {float} [firstKeyFrameTime=0] - The time of the first keyframe
* @property {string}   [type="layer"]  - Read Only.
*/
function LayerAnim()
{
	this._name = "";
	this._index = 0;
	this.anims = [];
	this.type = 'layer';
}

/**
* Constructs a new PropertyInfo
* @example
* var propInfo = new PropertyInfo(property);
* layer("ADBE effect parade").addProperty("ADBE layer control"); //now the property object is broken
* property = propInfo.getProperty(); // You can retrieve the property like this, fixed if it's an effect
* @class PropertyInfo
* @classdesc Get some handy informations about a property<br />
* This class is able to "fix" effects properties which have been broken by
* the addition of another effect on the same layer, as long as the class has been
* instanciated before the effect has been broken.
* @param {PropertyBase} property - The property
* @property {int} index - The propertyIndex
* @property {boolean} isEffect - true if this is an effect (sub)property
* @property {boolean} riggable  - true if this prop can be rigged (it's a value which can set expressions)
* @property {Layer} layer - The layer containing the property
* @property {int} dimensions - The number of dimensions, 0 if this is not a dimensionnal value (ie color, text, shape...)
*/
function PropertyInfo(property)
{
	this.property = property;
	this.index = property.propertyIndex;
	this.parentIndices  = [this.index];
	this.isEffect = property.isEffect;
	var parentProp = property;
	while (parentProp.parentProperty)
	{
		// Traverse up the property tree
		parentProp = parentProp.parentProperty;
		this.isEffect = parentProp.isEffect;
		this.parentIndices.unshift(parentProp.propertyIndex);
		if (this.isEffect) break;
	}

	var riggable = true;
	if (property.propertyType != PropertyType.PROPERTY) riggable = false;
	if (!property.canVaryOverTime) riggable = false;
	if (!property.canSetExpression) riggable = false;
	if (property.elided) riggable = false;
	this.riggable = riggable;
	this.layer = DuAEF.DuAE.Property.getLayer(property);
	this.dimensions = DuAEF.DuAE.Property.getDimensions(property);
}

/**
* Gets the original Property<br />
* Always works even if this PropertyInfo represents an effect which has been broken<br />
* ---AE Hack---
* @memberof PropertyInfo
* @return {PropertyBase} The property
* @todo When returning an effect, check if the matchName corresponds too.
*/
PropertyInfo.prototype.getProperty = function()
{
	if (this.isEffect)
	{
		var parentProp = this.layer("ADBE Effect Parade");
		for (var i = 0 ; i < this.parentIndices.length ; i++)
		{
			parentProp = parentProp(this.parentIndices[i]);
		}
		this.property = parentProp;
	}
	return this.property;
}

/**
* After Effects tools
* @namespace
* @memberof DuAEF
*/
DuAEF.DuAE = {};

//init
(function ()
{
	/**
	* Associative array that converts property match names to their compact English expression statements.
	* @example
	* DuAEF.DuAE.compactExpressions["ADBE Transform Group"]
	* //returns "'transform'"
	*/
	DuAEF.DuAE.compactExpressions = {
				"ADBE Transform Group":"'transform'",
				// Handle camera/light vs. AV layers
				"ADBE Anchor Point":"((prop.propertyGroup(prop.propertyDepth).property('intensity')!=null) || (prop.propertyGroup(prop.propertyDepth).property('zoom')!=null)) ? '.pointOfInterest' : '.anchorPoint'",
				"ADBE Position":"'.position'",
				"ADBE Scale":"'.scale'",
				"ADBE Orientation":"'.orientation'",
				"ADBE Rotate X":"'.xRotation'",
				"ADBE Rotate Y":"'.yRotation'",
				// Handle 3D vs. 2D layers
				"ADBE Rotate Z":"(prop.propertyGroup(prop.propertyDepth).threeDLayer || (prop.propertyGroup(prop.propertyDepth).property('intensity')!=null) || (prop.propertyGroup(prop.propertyDepth).property('zoom')!=null)) ? '.zRotation' : '.rotation'",
				"ADBE Opacity":"'.opacity'",
				"ADBE Material Options Group":"'materialOption'",
				"ADBE Casts Shadows":"'.castsShadows'",
				"ADBE Light Transmission":"'.lightTransmission'",
				"ADBE Accepts Shadows":"'.acceptsShadows'",
				"ADBE Accepts Lights":"'.acceptsLights'",
				"ADBE Ambient Coefficient":"'.ambient'",
				"ADBE Diffuse Coefficient":"'.diffuse'",
				"ADBE Specular Coefficient":"'.specular'",
				"ADBE Shininess Coefficient":"'.shininess'",
				"ADBE Metal Coefficient":"'.metal'",
				"ADBE Light Options Group":"'lightOption'",
				"ADBE Light Intensity":"'.intensity'",
				"ADBE Light Color":"'.color'",
				"ADBE Light Cone Angle":"'.coneAngle'",
				"ADBE Light Cone Feather 2":"'.coneFeather'",
				"ADBE Light Shadow Darkness":"'.shadowDarkness'",
				"ADBE Light Shadow Diffusion":"'.shadowDiffusion'",
				"ADBE Camera Options Group":"'cameraOption'",
				"ADBE Camera Zoom":"'.zoom'",
				"ADBE Camera Depth of Field":"'.depthOfField'",
				"ADBE Camera Focus Distance":"'.focusDistance'",
				"ADBE Camera Aperture":"'.aperture'",
				"ADBE Camera Blur Level":"'.blurLevel'",
				"ADBE Text Properties":"'text'",
				"ADBE Text Document":"'.sourceText'",
				"ADBE Text Path Options":"'.pathOption'",
				"ADBE Text Path":"'.path'",
				"ADBE Text Reverse Path":"'.reversePath'",
				"ADBE Text Perpendicular To Path":"'.perpendicularToPath'",
				"ADBE Text Force Align Path":"'.forceAlignment'",
				"ADBE Text First Margin":"'.firstMargin'",
				"ADBE Text Last Margin":"'.lastMargin'",
				"ADBE Text More Options":"'.moreOption'",
				"ADBE Text Anchor Point Option":"'.anchorPointGrouping'",
				"ADBE Text Anchor Point Align":"'.groupingAlignment'",
				"ADBE Text Render Order":"'.fillANdStroke'",
				"ADBE Text Character Blend Mode":"'.interCharacterBlending'",
				"ADBE Text Animators":"'.animator'",
				"ADBE Text Selectors":"'.selector'",
				"ADBE Text Percent Start":"'.start'",
				"ADBE Text Percent End":"'.end'",
				"ADBE Text Percent Offset":"'.offset'",
				"ADBE Text Index Start":"'.start'",
				"ADBE Text Index End":"'.end'",
				"ADBE Text Index Offset":"'.offset'",
				"ADBE Text Range Advanced":"'.advanced'",
				"ADBE Text Range Units":"'.units'",
				"ADBE Text Range Type2":"'.basedOn'",
				"ADBE Text Selector Mode":"'.mode'",
				"ADBE Text Selector Max Amount":"'.amount'",
				"ADBE Text Range Shape":"'.shape'",
				"ADBE Text Selector Smoothness":"'.smoothness'",
				"ADBE Text Levels Max Ease":"'.easeHigh'",
				"ADBE Text Levels Min Ease":"'.easeLow'",
				"ADBE Text Randomize Order":"'.randomizeOrder'",
				"ADBE Text Random Seed":"'.randomSeed'",
				"ADBE Text Selector Mode":"'.mode'",
				"ADBE Text Wiggly Max Amount":"'.maxAmount'",
				"ADBE Text Wiggly Min Amount":"'.minAmount'",
				"ADBE Text Range Type2":"'.basedOn'",
				"ADBE Text Temporal Freq":"'.wigglesSecond'",
				"ADBE Text Character Correlation":"'.correlation'",
				"ADBE Text Temporal Phase":"'.temporalPhase'",
				"ADBE Text Spatial Phase":"'.spatialPhase'",
				"ADBE Text Wiggly Lock Dim":"'.lockDimensions'",
				"ADBE Text Wiggly Random Seed":"'.randomSeed'",
				"ADBE Text Range Type2":"'.basedOn'",
				"ADBE Text Expressible Amount":"'.amount'",
				"ADBE Text Animator Properties":"'.property'",
				"ADBE Text Anchor Point 3D":"'.anchorPoint'",
				"ADBE Text Position 3D":"'.position'",
				"ADBE Text Scale 3D":"'.scale'",
				"ADBE Text Skew":"'.skew'",
				"ADBE Text Skew Axis":"'.skewAxis'",
				"ADBE Text Rotation X":"'.xRotation'",
				"ADBE Text Rotation Y":"'.yRotation'",
				"ADBE Text Rotation":"'.zRotation'",
				"ADBE Text Opacity":"'.opacity'",
				"ADBE Text Fill Opacity":"'.fillOpacity'",
				"ADBE Text Fill Color":"'.fillColor'",
				"ADBE Text Fill Hue":"'.fillHue'",
				"ADBE Text Fill Saturation":"'.fillSaturation'",
				"ADBE Text Fill Brightness":"'.fillBrightness'",
				"ADBE Text Stroke Opacity":"'.strokeOpacity'",
				"ADBE Text Stroke Color":"'.strokeColor'",
				"ADBE Text Stroke Hue":"'.strokeHue'",
				"ADBE Text Stroke Saturation":"'.strokeSaturation'",
				"ADBE Text Stroke Brightness":"'.strokeBrightness'",
				"ADBE Text Stroke Width":"'.strokeWidth'",
				"ADBE Text Line Anchor":"'.lineAnchor'",
				"ADBE Text Line Spacing":"'.lineSpacing'",
				"ADBE Text Track Type":"'.trackingType'",
				"ADBE Text Tracking Amount":"'.trackingAmount'",
				"ADBE Text Character Change Type":"'.characterAlignment'",
				"ADBE Text Character Range":"'.characterRange'",
				"ADBE Text Character Replace":"'.characterValue'",
				"ADBE Text Character Offset":"'.characterOffset'",
				"ADBE Text Blur":"'.blur'",
				"ADBE Mask Parade":"'mask'",
				"ADBE Mask Shape":"'.maskPath'",
				"ADBE Mask Feather":"'.maskFeather'",
				"ADBE Mask Opacity":"'.maskOpacity'",
				"ADBE Mask Offset":"'.maskExpansion'",
				"ADBE Effect Parade":"'effect'",
				"ADBE Paint Group":"'.stroke'",
				"ADBE Paint Shape":"'.path'",
				"ADBE Paint Properties":"'.strokeOption'",
				"ADBE Paint Begin":"'.start'",
				"ADBE Paint End":"'.end'",
				"ADBE Paint Color":"'.color'",
				"ADBE Paint Diameter":"'.diameter'",
				"ADBE Paint Angle":"'.angle'",
				"ADBE Paint Hardness":"'.hardness'",
				"ADBE Paint Roundness":"'.roundness'",
				"ADBE Paint Tip Spacing":"'.spacing'",
				"ADBE Paint Target Channels":"'.channels'",
				"ADBE Paint Opacity":"'.opacity'",
				"ADBE Paint Flow":"'.flow'",
				"ADBE Paint Clone Layer":"'.cloneSource'",
				"ADBE Paint Clone Position":"'.clonePosition'",
				"ADBE Paint Clone Time":"'.cloneTime'",
				"ADBE Paint Clone Time Shift":"'.cloneTimeShift'",
				"ADBE Paint Transform":"'.transform'",
				"ADBE Paint Anchor Point":"'.anchorPoint'",
				"ADBE Paint Position":"'.position'",
				"ADBE Paint Scale":"'.scale'",
				"ADBE Paint Rotation":"'.rotation'",
				"ADBE MTrackers":"'motionTracker'",
				"ADBE MTracker Pt Feature Center":"'.featureCenter'",
				"ADBE MTracker Pt Feature Size":"'.featureSize'",
				"ADBE MTracker Pt Search Ofst":"'.searchOffset'",
				"ADBE MTracker Pt Search Size":"'.searchSize'",
				"ADBE MTracker Pt Confidence":"'.confidence'",
				"ADBE MTracker Pt Attach Pt":"'.attachPoint'",
				"ADBE MTracker Pt Attach Pt Ofst":"'.attachPointOffset'",
				"ADBE Audio Group":"'audio'",
				"ADBE Audio Levels":"'.audioLevels'",
				"ADBE Time Remapping":"'timeRemap'",
				"ADBE Layer Styles":"'layerStyle'",
				"ADBE Blend Options Group":"'.blendingOption'",
					"ADBE Global Angle2":"'.globalLightAngle'",
					"ADBE Global Altitude2":"'.globalLightAltitude'",
					"ADBE Adv Blend Group":"'.advancedBlending'",
					"ADBE Layer Fill Opacity2":"'.fillOpacity'",
					"ADBE R Channel Blend":"'.red'",
					"ADBE G Channel Blend":"'.green'",
					"ADBE B Channel Blend":"'.blue'",
					"ADBE Blend Interior":"'.blendInteriorStylesAsGroup'",
					"ADBE Blend Ranges":"'.useBlendRangesFromSource'",
				"dropShadow/enabled":"'.dropShadow'",
					"dropShadow/mode2":"'.blendMode'",
					"dropShadow/color":"'.color'",
					"dropShadow/opacity":"'.opacity'",
					"dropShadow/useGlobalAngle":"'.useGlobalLight'",
					"dropShadow/localLightingAngle":"'.angle'",
					"dropShadow/distance":"'.distance'",
					"dropShadow/chokeMatte":"'.spread'",
					"dropShadow/blur":"'.size'",
					"dropShadow/noise":"'.noise'",
					"dropShadow/layerConceals":"'.layerKnocksOutDropShadow'",
				"innerShadow/enabled":"'.innerShadow'",
					"innerShadow/mode2":"'.blendMode'",
					"innerShadow/color":"'.color'",
					"innerShadow/opacity":"'.opacity'",
					"innerShadow/useGlobalAngle":"'.useGlobalLight'",
					"innerShadow/localLightingAngle":"'.angle'",
					"innerShadow/distance":"'.distance'",
					"innerShadow/chokeMatte":"'.choke'",
					"innerShadow/blur":"'.size'",
					"innerShadow/noise":"'.noise'",
				"outerGlow/enabled":"'.outerGlow'",
					"outerGlow/mode2":"'.blendMode'",
					"outerGlow/opacity":"'.opacity'",
					"outerGlow/noise":"'.noise'",
					"outerGlow/AEColorChoice":"'.colorType'",
					"outerGlow/color":"'.color'",
					"outerGlow/gradientSmoothness":"'.gradientSmoothness'",
					"outerGlow/glowTechnique":"'.technique'",
					"outerGlow/chokeMatte":"'.spread'",
					"outerGlow/blur":"'.size'",
					"outerGlow/inputRange":"'.range'",
					"outerGlow/shadingNoise":"'.jitter'",
				"innerGlow/enabled":"'.innerGlow'",
					"innerGlow/mode2":"'.blendMode'",
					"innerGlow/opacity":"'.opacity'",
					"innerGlow/noise":"'.noise'",
					"innerGlow/AEColorChoice":"'.colorType'",
					"innerGlow/color":"'.color'",
					"innerGlow/gradientSmoothness":"'.gradientSmoothness'",
					"innerGlow/glowTechnique":"'.technique'",
					"innerGlow/innerGlowSource":"'.source'",
					"innerGlow/chokeMatte":"'.choke'",
					"innerGlow/blur":"'.size'",
					"innerGlow/inputRange":"'.range'",
					"innerGlow/shadingNoise":"'.jitter'",
				"bevelEmboss/enabled":"'.bevelAndEmboss'",
					"bevelEmboss/bevelStyle":"'.style'",
					"bevelEmboss/bevelTechnique":"'.technique'",
					"bevelEmboss/strengthRatio":"'.depth'",
					"bevelEmboss/bevelDirection":"'.direction'",
					"bevelEmboss/blur":"'.size'",
					"bevelEmboss/softness":"'.soften'",
					"bevelEmboss/useGlobalAngle":"'.useGlobalLight'",
					"bevelEmboss/localLightingAngle":"'.angle'",
					"bevelEmboss/localLightingAltitude":"'.altitude'",
					"bevelEmboss/highlightMode":"'.highlightMode'",
					"bevelEmboss/highlightColor":"'.highlightColor'",
					"bevelEmboss/highlightOpacity":"'.highlightOpacity'",
					"bevelEmboss/shadowMode":"'.shadowMode'",
					"bevelEmboss/shadowColor":"'.shadowColor'",
					"bevelEmboss/shadowOpacity":"'.shadowOpacity'",
				"chromeFX/enabled":"'.satin'",
					"chromeFX/mode2":"'.blendMode'",
					"chromeFX/color":"'.color'",
					"chromeFX/opacity":"'.opacity'",
					"chromeFX/localLightingAngle":"'.angle'",
					"chromeFX/distance":"'.distance'",
					"chromeFX/blur":"'.size'",
					"chromeFX/invert":"'.invert'",
				"solidFill/enabled":"'.colorOverlay'",
					"solidFill/mode2":"'.blendMode'",
					"solidFill/color":"'.color'",
					"solidFill/opacity":"'.opacity'",
				"gradientFill/enabled":"'.gradientOverlay'",
					"gradientFill/mode2":"'.blendMode'",
					"gradientFill/opacity":"'.opacity'",
					"gradientFill/gradientSmoothness":"'.gradientSmoothness'",
					"gradientFill/angle":"'.angle'",
					"gradientFill/type":"'.style'",
					"gradientFill/reverse":"'.reverse'",
					"gradientFill/align":"'.alignWithLayer'",
					"gradientFill/scale":"'.scale'",
					"gradientFill/offset":"'.offset'",
				"patternFill/enabled":"'.patternOverlay'",
					"patternFill/mode2":"'.blendMode'",
					"patternFill/opacity":"'.opacity'",
					"patternFill/align":"'.linkWithLayer'",
					"patternFill/scale":"'.scale'",
					"patternFill/phase":"'.offset'",
				"frameFX/enabled":"'.stroke'",
					"frameFX/mode2":"'.blendMode'",
					"frameFX/color":"'.color'",
					"frameFX/size":"'.size'",
					"frameFX/opacity":"'.opacity'",
					"frameFX/style":"'.position'",
			};
})();

/**
* Checks if the param is an AE collection or an Array
* @param {Array|Collection} collection - The list to check
* @return {boolean} true if collection is a collection, false if it's an array
*/
DuAEF.DuAE.isCollection = function (collection)
{
	return collection instanceof ItemCollection || collection instanceof LayerCollection || collection instanceof OMCollection || collection instanceof RQItemCollection;
}
/**
* Returns an iterator to loop through the list, wether it's an array or a Collection
* @param {Array|Collection} collection - The list to check
* @return {Iterator} The iterator
*/
DuAEF.DuAE.getListIterator = function (collection)
{
	var iterator = {};
	iterator.min = 0;
	iterator.max = collection.length -1;
	iterator.length = collection.length;
	if (DuAEF.DuAE.isCollection(collection))
	{
		iterator.min = 1;
		iterator.max = collection.length;
	}
	return iterator;
}

/**
* Gets the PropertyInfo for the properties
* @param {PropertyBase[]} props - The Properties
* @return {PropertyInfo[]} The info
*/
DuAEF.DuAE.getPropertyInfos = function (props)
{
	//convert to propinfo
	var propInfos = [];
	for (var i = 0 ; i < props.length ; i++)
	{
		propInfos.push(new PropertyInfo(props[i]));
	}
	return propInfos;
}

/**
* Application related methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.App = {};

//App Properties
(function ()
{
	//detect AE Version
	var reV = /^(\d+\.?\d*)/i;
	var v = app.version.match(reV);

	/**
	* The After Effects version
	* @memberof DuAEF.DuAE.App
	* @type {float}
	*/
	DuAEF.DuAE.App.version = parseFloat(v[1]);

	/**
	 * Has scripting file and network authorization
	 * @type {boolean}
	 */
	DuAEF.DuAE.App.hasFilesAndNetworkAccess = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
})();

/**
* Asks the user to check the file and network security pref if not already set.
* Opens the general prefrences of After Effects.
* @memberof DuAEF.DuAE.App
* @param {boolean}	[showAlert=true]	- Wether to display an alert before opening the preferences
* @param {string}	[message=The Duduf After Effects scripting framework needs to be allowed to write files\nPlease, check the box called 'Allow Scripts to write files...' in the general preferences of After Effects.]	- The message to display in the alert.
* @return {boolean}	Wether the preference has been set
*/
DuAEF.DuAE.App.askFilesAndNetworkAccess = function(showAlert,message)
{
	if (showAlert == undefined) alert = true;
	if (message == undefined ) message = "The Duduf After Effects scripting framework needs to be allowed to write files\nPlease, check the box called 'Allow Scripts to write files...' in the general preferences of After Effects.";
	if (!DuAEF.DuAE.App.hasFilesAndNetworkAccess)
	{

		if (showAlert) alert(message);
		app.executeCommand(2359);

		DuAEF.DuAE.App.hasFilesAndNetworkAccess = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
	}
	return DuAEF.DuAE.App.hasFilesAndNetworkAccess;
}

/**
* Gets the public name of a version of After Effects (like CC2015.3 for version 13.8)
* @param {float}	[versionAsFloat]	- The version as a float. If not provided, will default to the current version of the running instance of After Effects.
* @return {string}	The version name.
*/
DuAEF.DuAE.App.getAEVersionName = function(versionAsFloat)
{
	if (versionAsFloat == undefined) versionAsFloat = DuAEF.DuAE.App.version;
	if (versionAsFloat < 8) return "" + versionAsFloat;
	if (versionAsFloat >= 8 && versionAsFloat < 9) return "CS3";
	if (versionAsFloat >= 9 && versionAsFloat < 10) return "CS4";
	if (versionAsFloat >= 10 && versionAsFloat < 10.5) return "CS5";
	if (versionAsFloat >= 10.5 && versionAsFloat < 11) return "CS5.5";
	if (versionAsFloat >= 11 && versionAsFloat < 12) return "CS6";
	if (versionAsFloat >= 12 && versionAsFloat < 13) return "CC";
	if (versionAsFloat >= 13 && versionAsFloat < 13.1) return "CC2014";
	if (versionAsFloat >= 13.1 && versionAsFloat < 13.2) return "CC2014.1";
	if (versionAsFloat >= 13.2 && versionAsFloat < 13.5) return "CC2014.2";
	if (versionAsFloat >= 13.5 && versionAsFloat < 13.6) return "CC2015";
	if (versionAsFloat >= 13.6 && versionAsFloat < 13.7) return "CC2015.1";
	if (versionAsFloat >= 13.7 && versionAsFloat < 13.8) return "CC2015.2";
	if (versionAsFloat >= 13.8 && versionAsFloat < 14) return "CC2015.3";
	if (versionAsFloat >= 14 && versionAsFloat < 15) return "CC2017";
	if (versionAsFloat >= 15 && versionAsFloat < 16) return "CC2018";
	else return "Unknown";
}

/**
* After Effects project methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Project = {};

/**
* Gets the After Effects current composition
* @return {CompItem|null} The current composition or null if there's no current comp
*/
DuAEF.DuAE.Project.getActiveComp = function()
{
	var comp = app.project.activeItem;
	if (!comp) return null;
	if (!(comp instanceof CompItem)) return null;
	return comp;
}

/**
* After Effects composition methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Comp = {};

/**
* Gets the After Effects selected properties in the current comp
* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
* @return {PropertyInfo[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Comp.getSelectedProps = function(filter,strict,caseSensitive)
{
	var props = [];
	var comp = DuAEF.DuAE.Project.getActiveComp();
	if (!comp) return props;

	//if no filter, get all using AE native API
	if (filter == undefined)
	{
		props = comp.selectedProperties;
	}

	var layers = comp.selectedLayers;
	if (layers.length === 0) return props;

	for (var i = 0 ; i < layers.length ; i++)
	{
		props = props.concat(DuAEF.DuAE.Layer.getSelectedProps(layers[i],filter,strict,caseSensitive));
	}

	return DuAEF.DuAE.getPropertyInfos(props);
}

/**
* Deselects all properties in the current composition
*/
DuAEF.DuAE.Comp.unselectProperties = function()
{
	var props = DuAEF.DuAE.Comp.getSelectedProps();
	for (var i = 0; i < props.length ; i++)
	{
		props[i].selected = false;
	}
}

/**
* Deselects all layers in the current composition
* @return {Layer[]} The previously selected layers.<br />
* A custom attribute, Layer.props is added on each layer object which is an array of all previously selected properties as PropertyInfo objects
*/
DuAEF.DuAE.Comp.unselectLayers = function()
{
	var comp = app.project.activeItem;

	var layers = [];

	if (!comp) return layers;
	if (!(comp instanceof CompItem)) return layers;

	layers = [];

	while (comp.selectedLayers.length > 0)
	{
		var layer = comp.selectedLayers[0];
		layer.props = DuAEF.DuAE.getPropertyInfos(layer.selectedProperties);
		layer.selected = false;
		layers.push(layer);
	}

	return layers;
}

/**
* Selects the layers
* @param {Layer[]} layers - The layers
*/
DuAEF.DuAE.Comp.selectLayers = function (layers)
{
	for (var i = 0 ; i < layers.length ; i++)
	{
		layers[i].selected = true;
	}
}

/**
* Generates a new unique name for a layer
* @param {string} newName	- The wanted new name
* @param {CompItem} comp 	- The comp
* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Comp.newUniqueLayerName = function(newName, comp)
{
	var layerNames = [];
	for (var i = 1 ; i <= comp.layers.length ; i++)
	{
		layerNames.push(comp.layer(i).name);
	}
	return DuAEF.DuJS.String.generateUnique(newName,layerNames);
}

/**
* Creates a new Adjustment layer
* @param {CompItem} comp 	- The comp
* @return {AVLayer}	The layer.
*/
DuAEF.DuAE.Comp.addAdjustmentLayer = function(comp)
{
	if (comp == undefined) return null;
	var layer = comp.layers.addSolid([1,1,1], DuAEF.DuAE.Comp.newUniqueLayerName("Adjustment Layer",comp) , comp.width, comp.height, comp.pixelAspect, comp.duration);
	layer.adjustmentLayer = true;
	return layer;
}

/**
* After Effects layer methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Layer = {};

/**
* Generates a new unique name for an effect
* @param {string} newName	- The wanted new name
* @param {Layer} layer 	- The layer
* @return {string}	The unique name, with a new number at the end if needed.
*/
DuAEF.DuAE.Layer.newUniqueEffectName = function(newName, layer)
{
	if (!layer) throw new Error("Needs a layer to generate a new unique effect name","DuAECOreLib",645);
	var effectNames = [];
	for (var i = 1 ; i <= layer.effect.numProperties ; i++)
	{
		effectNames.push(layer.effect(i).name);
	}
	return DuAEF.DuJS.String.generateUnique(newName,effectNames);
}

/**
* Gets the After Effects selected properties in the layer
* @param {Layer}	layer	- The layer
* @param {PropertyType|PropertyValueType|string|function}	 [filter]	- A filter to get only a certain type, or value type, or property name or matchName.<br />
* A function which take one PropertyBase as argument can be used to filter the properties: the Property will be returned if the function returns true.
* @param {boolean}	[strict=false]	- If a string filter is provided, wether to search for the exact name/matchName or if it contains the filter.
* @param {boolean}	[caseSensitive=true]	- If a string filter is provided, and not strict is false, does the search have to be case sensitive?
* @return {PropertyBase[]} The selected properties, an empty Array if nothing active or selected
*/
DuAEF.DuAE.Layer.getSelectedProps = function(layer,filter,strict,caseSensitive)
{
	if (strict == undefined) strict = false;
	if (caseSensitive == undefined) caseSensitive = true;

	var props = [];

	if (!caseSensitive && typeof filter === "string") filter = filter.toLowerCase();

	var selectedProps = layer.selectedProperties;
	if (filter == undefined)
	{
		props = props.concat(selectedProps);
	}
	else
	{
		for (var j = 0 ; j < selectedProps.length ; j++)
		{
			var prop = selectedProps[j];

			var name = prop.name;
			var matchName = prop.matchName;
			if (!caseSensitive)
			{
				name = name.toLowerCase();
				matchName = matchName.toLowerCase();
			}

			if (strict && name === filter) props.push(prop);
			else if (strict && matchName === filter) props.push(prop);
			else if (typeof filter === "string")
			{
				if (name.indexOf(filter) >= 0) props.push(prop);
				else if (matchName.indexOf(filter) >= 0) props.push(prop);
			}
			else if (prop.propertyType == PropertyType.PROPERTY) if (prop.propertyValueType == filter) props.push(prop);
			else if (prop.propertyType == filter) props.push(prop);
			else if (typeof filter === "function") if (filter(prop)) props.push(prop);
		}
	}

	return DuAEF.DuAE.getPropertyInfos(props);
}

/**
* Gets all animations on the layer in the whole timeline or in the time range<br />
* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {Layer}	layer	- The layer.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds.
* @return {LayerAnim}	The animation.
*/
DuAEF.DuAE.Layer.getAnim = function (layer,selected,timeRange)
{
	var anim = new LayerAnim();
	anim._name = layer.name;
	anim._index = layer.index;
	anim.anims = [];
	for (var propIndex = 1;propIndex <= layer.numProperties;propIndex++)
	{
		var prop = layer.property(propIndex);
		if (prop.matchName == 'ADBE Marker') continue;

		var subAnim = DuAEF.DuAE.Property.getAnim(prop,selected,timeRange);
		if (subAnim != null) anim.anims.push(subAnim);

	}
	return anim;
}

/**
* Sets the property animation on the property
* @param {Layer}	layer	- The layer.
* @param {PropertyAnim} anims	- The animation
* @param {float}	[time=comp.time]	- The time where to begin the animation
* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the animation.
* @param {boolean}	[setExpression=false]	- Set the expression on the property
* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Layer.setAnim = function(layer,anim,time,ignoreName,setExpression)
{
	if (time == undefined) time = layer.containingComp.time;
	if (ignoreName == undefined) ignoreName = false;
	if (setExpression == undefined) setExpression = false;

	for (var i = 0 ; i < anim.anims.length ; i++)
	{
		var subAnim = anim.anims[i];
		for (var propIndex = 1;propIndex <= layer.numProperties;propIndex++)
		{
			var subProp = layer.property(propIndex);
			if (subProp == null) continue;
			if (subProp.matchName == subAnim._matchName && subProp.matchName != 'ADBE Marker')
			{
				var ok = DuAEF.DuAE.Property.setGroupAnim(subProp,subAnim,time,ignoreName,setExpression);
				if (ok) break;
			}
		}
	}
}

/**
* Gets the children of a layer
* @param {Layer}	layer	- The layer.
* @return {Layer[]} All the children of the layer
*/
DuAEF.DuAE.Layer.getChildren = function(layer)
{
	var comp = layer.containingComp;
	var children = [];
	for (var i = 1 ; i <= comp.layers.length ; i++)
	{
		var l = comp.layer(i);
		if (l.index == layer.index) continue;
		if (l.parent == null) continue;
		if (l.parent.index == layer.index) children.push(l);
	}
	return children;
}

/**
* Measures the distance between two layers
* @param {Layer} layer1 - The first layer
* @param {Layer} layer2 - The second layer
* @return {int} The distance (in pixels)
*/
DuAEF.DuAE.Layer.getDistance = function (layer1,layer2)
{
	//parents
	var layer1Parent = layer1.parent;
	var layer2Parent = layer2.parent;
	//unlink
	layer1.parent = null;
	layer2.parent = null;
	var O = layer1.transform.position.value;
	var A = layer2.transform.position.value;
	var OA = DuAEF.DuJS.Math.getLength(O,A);
	//re-link
	layer1.parent = layer1Parent;
	layer2.parent = layer2Parent;
	return Math.round(OA);
}

/**
* This method is a workaround to AE API method layer.applyPreset to work like addProperty when adding pseudoEffects
* @param {Layer} layer - The layer
* @param {File} preset - The preset file
* @param {string} matchName - The pseudo Effect matchName.
* @param {string} [name] - The name to set on the effect
* @return {PropertyGroup|null} The effect or null if anything went wrong
*/
DuAEF.DuAE.Layer.addPseudoEffect = function (layer,preset,matchName,name)
{
	if (layer == undefined) return null;
	if (preset == undefined) return null;
	if (matchName == undefined) return null;

	var effects = layer("ADBE Effect Parade");
	//add the preset to a temp comp if not available as an effect
	if (!effects.canAddProperty(matchName))
	{
		//create comp
		var comp = app.project.items.addComp("DuAEF Temp", 10, 10, 1, 1, 24);
		//add null
		var n = comp.layers.addNull();
		//apply preset
		n.applyPreset(preset);
		//remove all
		var nullSource = n.source;
		n.remove();
		nullSource.remove();
		comp.remove();
	}

	//add the pseudoEffect as a property
	var newEffectName = '';
	newEffectName = DuAEF.DuAE.Layer.newUniqueEffectName(name,layer);
	var effect = effects.addProperty(matchName);
	effect.name = newEffectName;
	return effect;
}

/**
* Checks if the layers have some selected keyframes
* @param {Layer[]|LayerCollection} layers - The layers
* @return {boolean} true if the layers have at least one selected keyframe
*/
DuAEF.DuAE.Layer.haveSelectedKeys = function (layers)
{
	var it = DuAEF.DuAE.getListIterator(layers);
	if (it.length == 0) return;
	for (var i = it.min ; i <= it.max ; i++)
	{
		if (DuAEF.DuAE.Property.hasSelectedKeys(layers[i]))
		{
			return true;
		}
	}
	return false;
}

/**
* Gets the time of the first keyFrame
* @param {Layer[]|LayerCollection} layer - The layer
* @param {boolean} selected - true to check selected keyframes only
* @return {float|null} The keyframe time or null if there are no keyframe
*/
DuAEF.DuAE.Layer.firstKeyFrameTime = function (layers,selected)
{
	var it = DuAEF.DuAE.getListIterator(layers);
	var time = null;
	for (var i = it.min ; i <= it.max ; i++)
	{
		var test = DuAEF.DuAE.Property.firstKeyFrameTime(layers[i],selected);
		if (time == null) time = test;
		else if (test != null) { if (time > test) time = test; }
	}
	return time;
}

/**
* After Effects properties methods
* @namespace
* @memberof DuAEF.DuAE
*/
DuAEF.DuAE.Property = {};

/**
* Gets the layer containing the property
* @param {PropertyBase|PropertyInfo}	prop	- The After Effects Property
* @return {Layer}	The layer
*/
DuAEF.DuAE.Property.getLayer = function (prop)
{
	if (prop == undefined) throw "You must provide a property.";
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	var parentProp = prop;
	while (parentProp.parentProperty !== null)
	{
		// Traverse up the property tree
		parentProp = parentProp.parentProperty;
	}
	return parentProp;
}

/**
* Gets the composition containing the property
* @param {PropertyBase|PropertyInfo}	prop	- The After Effects Property
* @return {CompItem}	The composition
*/
DuAEF.DuAE.Property.getComp = function (prop)
{
	var layer = DuAEF.DuAE.Property.getLayer(prop);
	return layer.containingComp;
}

/**
* Gets the number of dimensions of a property
* @param {Property|PropertyInfo}	prop	- The After Effects Property
* @return {int}	The number of dimensions, 0 if this is not a dimensionnal value (ie color, text, shape...)
*/
DuAEF.DuAE.Property.getDimensions = function (prop)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	var dimensions = 0;
	if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
	{
		//if this is a position or scale and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......
		if ((prop.matchName == "ADBE Scale" || prop.matchName == "ADBE Position") && !DuAEF.DuAE.Property.getLayer(prop).threeDLayer)
		{
			dimensions = 2;
		}
		else
		{
			dimensions = 3;
		}
	}
	else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
	{
		dimensions = 2;
	}
	else if (prop.propertyValueType == PropertyValueType.OneD)
	{
		dimensions = 1;
	}
	else if (prop.propertyValueType == PropertyValueType.COLOR)
	{
		dimensions = 4;
	}
	return dimensions;
}

/**
* Gets the key at a given index on a property
* @param {Property|PropertyInfo}	prop	- The property.
* @param {int}	keyIndex	- The index of the key to retrieve. If the index is negative, it is counted from the end i.e. to retrieve the keyframe before the last one, use -2 (-1 is the last)
* @return {KeyFrame}	The keyframe, or null if incorrect index
*/
DuAEF.DuAE.Property.getKeyFrameAtIndex = function (prop,keyIndex)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (Math.abs(keyIndex) > prop.numKeys || keyIndex == 0)
	{
		return null;
	}
	if (keyIndex < 0)
	{
		keyIndex = prop.numKeys - keyIndex + 1;
	}

	var key = new KeyFrame();
	key._time = prop.keyTime(keyIndex);
	key.value = prop.keyValue(keyIndex);
	key._inInterpolationType = prop.keyInInterpolationType(keyIndex);
	key._outInterpolationType = prop.keyOutInterpolationType(keyIndex);
	if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL )
	{
		key._spatial = true;
		key.spatialProperties.inTangent = prop.keyInSpatialTangent(keyIndex);
		key.spatialProperties.outTangent  = prop.keyOutSpatialTangent(keyIndex);
		key.spatialProperties._continuous = prop.keySpatialContinuous(keyIndex);
		key.spatialProperties._autoBezier = prop.keySpatialAutoBezier(keyIndex);
		key.spatialProperties._roving = prop.keyRoving(keyIndex);
	}
	key.inEase = prop.keyInTemporalEase(keyIndex);
	key.outEase = prop.keyOutTemporalEase(keyIndex);
	key._continuous = prop.keyTemporalContinuous(keyIndex);
	key._autoBezier = prop.keyTemporalAutoBezier(keyIndex);
	key._index = keyIndex;

	return key;
}

/**
* Gets the nearest key at a given time on a property
* @param {Property|PropertyInfo}	prop	- The property.
* @param {float}	time	- The time of the key to retrieve.
* @return {KeyFrame}	The keyframe, or null if incorrect time or not found
*/
DuAEF.DuAE.Property.getNearestKeyFrameAtTime = function (prop,time)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	return DuAEF.DuAE.Property.getKeyFrameAtIndex(prop.nearestKeyIndex(time));
}

/**
* Gets the key at an exactly given time on a property
* @param {Property|PropertyInfo}	prop	- The property.
* @param {float}	time	- The time of the key to retrieve.
* @return {KeyFrame}	The keyframe, or null if incorrect time
*/
DuAEF.DuAE.Property.getKeyFrameAtTime = function (prop,time)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (!prop.canVaryOverTime) return null;
	if (prop.numKeys == 0) return null;
	var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.nearestKeyIndex(time));
	if (key === null) return key;
	if (key._time == time) return key;
	else return null;
}

/**
* Gets the property keyframes in the whole timeline or in the time range<br />
* The KeyFrame._time will be adjusted relatively to the start of the time range instead of the startTime of the composition.
* @param {Property|PropertyInfo}	prop	- The property.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds. If not provided, will use the comp time range.<br />
* Ignored if selected is true;
* @return {KeyFrame[]}	The keyframes, or null of this property is of type PropertyValueType.NO_VALUE or PropertyValueType.CUSTOM_VALUE
*/
DuAEF.DuAE.Property.getKeyFrames = function(prop,selected,timeRange)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
	if (prop.propertyValueType == PropertyValueType.CUSTOM_VALUE) return null;

	var comp = DuAEF.DuAE.Property.getComp(prop);
	if (timeRange == undefined) timeRange = [0,comp.duration];
	if (selected == undefined) selected = false;

	var keyFrames = [];

	if (prop.elided) return keyFrames;

	if (prop.isTimeVarying)
	{
		if (selected)
		{
			for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.selectedKeys[keyIndex]);
				if (key._time >= timeRange[0] && key._time <= timeRange[1])
				{
					key._time = key._time - timeRange[0];
					keyFrames.push(key);
				}
			}
		}
		else if (prop.numKeys > 0)
		{
			for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,keyIndex);
				if (key._time >= timeRange[0] && key._time <= timeRange[1])
				{
					key._time = key._time - timeRange[0];
					keyFrames.push(key);
				}
			}
		}
	}
	return keyFrames;
}

/**
* Gets all animations in the group in the whole timeline or in the time range<br />
* The first KeyFrame._time will be adjusted relatively to the start of the time range (if provided) instead of the startTime of the composition.
* @param {PropertyGroup|PropertyInfo}	prop	- The property.
* @param {boolean}	[selected=false]	- true to get only selected keyframes.
* @param {float[]}	[timeRange]	- The time range, an array of two time values, in seconds. If not provided, will use the comp time range.
* @return {PropertyGroupAnim|PropertyAnim}	The animations. A PropertyAnim if prop is a Property, a PopertyGroupAnim if it is a PropertyGroup
*/
DuAEF.DuAE.Property.getAnim = function (prop,selected,timeRange)
{
	var comp = DuAEF.DuAE.Property.getComp(prop);
	if (timeRange == undefined) timeRange = [0,comp.duration];
	if (selected == undefined) selected = false;

	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.propertyType === PropertyType.PROPERTY)
	{
		if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
		if (prop.elided) return null;
		if (!prop.canVaryOverTime) return null;
		if (prop.selectedKeys.length == 0 && selected) return null;
		var anim = new PropertyAnim();
		anim._name = prop.name;
		anim._matchName = prop.matchName;
		anim.startValue = prop.valueAtTime(timeRange[0],true);
		anim.keys = DuAEF.DuAE.Property.getKeyFrames(prop,selected,timeRange);
		anim.dimensions = DuAEF.DuAE.Property.getDimensions(prop);
		if (prop.canSetExpression) anim.expression = prop.expression;
		return anim;
	}
	else if (prop.numProperties > 0)
	{
		var groupAnim = new PropertyGroupAnim();
		groupAnim._name = prop.name;
		groupAnim._matchName = prop.matchName;

		for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
		{
			var anim = DuAEF.DuAE.Property.getAnim(prop.property(propIndex),selected,timeRange);
			if (anim != null) groupAnim.anims.push(anim);
		}
		return groupAnim;
	}
	return null;
}

/**
* Gets the time of the first keyFrame
* @param {PropertyBase[]|PropertyInfo[]} props - The properties
* @param {boolean} selected - true to check selected keyframes only
* @return {float<|null} The keyframe time or null if there are no keyframe
*/
DuAEF.DuAE.Property.firstKeyFrameTime = function (prop,selected)
{
	var time = null;

	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.propertyType == PropertyType.PROPERTY)
	{
		if (!prop.canVaryOverTime) return null;
		if (selected)
		{
			if (prop.selectedKeys.length == 0) return null;
			for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,prop.selectedKeys[keyIndex]);
				if (time == null) time = key._time;
				else if (time > key._time) time = key._time;
			}
		}
		else
		{
			if (prop.numKeys == 0) return null;
			for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
			{
				var key = DuAEF.DuAE.Property.getKeyFrameAtIndex(prop,keyIndex);
				if (time == null) time = key._time;
				else if (time > key._time) time = key._time;
			}
		}
	}
	else if (prop.numProperties > 0)
	{
		for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
		{
			var test = DuAEF.DuAE.Property.firstKeyFrameTime(prop.property(propIndex),selected);
			if (time == null) time = test;
			else if (test != null) { if (time > test) time = test; }
		}
	}

	return time;
}

/**
* Sets a {@linkcode KeyFrame} on a property
* @param {Property|PropertyInfo}	prop	- The property.
* @param {KeyFrame}	key	- The KeyFrame.
* @param {float}	[timeOffset=comp.time]	- The time offset (added to KeyFrame._time) where to add the key frame.
*/
DuAEF.DuAE.Property.setKey = function (prop,key,timeOffset)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.elided) return;
	if (!prop.propertyType === PropertyType.PROPERTY) throw "Can not set a key on a group property";
	if (!prop.canVaryOverTime) return;

	if (timeOffset == undefined) timeOffset = DuAEF.DuAE.Property.getPropertyComp(prop).time;
	var time = key._time + timeOffset;
	var propDimensions = DuAEF.DuAE.Property.getDimensions(prop);
	var val = key.value;

	if (propDimensions > 1 && !(val instanceof Array))
	{
		val = [val];
	}

	//adjust dimensions
	if (val instanceof Array)
	{
		while (val.length < propDimensions)
		{
			val.push(0);
		}
		while (val.length > propDimensions)
		{
			val.pop();
		}
	}

	try
	{
		prop.setValueAtTime(time,val);

		//get the index of the created key
		var index = prop.nearestKeyIndex(time);

		//set interpolations
		if (key._spatial && (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL))
		{
			try{
				prop.setSpatialContinuousAtKey(index,key.spatialProperties._continuous);
				prop.setSpatialAutoBezierAtKey(index,key.spatialProperties._autoBezier);
				prop.setRovingAtKey(index,key.spatialProperties._roving);
				prop.setSpatialTangentsAtKey(index,key.spatialProperties.inTangent,key.spatialProperties.outTangent);
			}
			catch(err)
			{
				alert(err.description);
			};
		}

		try
		{
			prop.setTemporalContinuousAtKey(index,key._continuous);
			prop.setTemporalAutoBezierAtKey(index,key._autoBezier);
			prop.setTemporalEaseAtKey(index,key.inEase,key.outEase);
			prop.setInterpolationTypeAtKey(index,key._inInterpolationType,key._outInterpolationType);
		}
		catch(err)
		{
			alert(err.description);
		}

	}
	catch (err)
	{
		alert(err.description);
	}
}

/**
* Sets the property animation on the property.<br />
* Use this method only to force the animation onto the property without checks.<br />
* Must be used on a Property (not a group) with a PropertyAnim (not a PropertyGroupAnim).<br />
* To easily set an animation on a property with automatic compatibility checks, you should use setGroupAnim().
* @param {Property|PropertyInfo}	prop	- The property.
* @param {PropertyAnim} anims	- The animation
* @param {float}	[time=comp.time]	- The time where to begin the animation
* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the animation.
* @param {boolean}	[setExpression=false]	- Sets the expression too
* @param {boolean}	[ignoreMatchName=false]	- true to set the anim even if matchName of the property do not match the animation.
* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Property.setAnim = function(prop,anim,time,setExpression)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (time == undefined) time = DuAEF.DuAE.Property.getPropertyComp(prop).time;
	if (setExpression == undefined) setExpression = false;

	var dimensions = anim.dimensions;

	var ok = false;

	if (anim == null) return true;
	if (anim.type == 'group') return false;

	//find the property with the same name and matchname
	if (prop.propertyType === PropertyType.PROPERTY && !prop.elided && prop.canVaryOverTime)
	{
		//if there are keys, set them
		if (anim.keys.length > 0)
		{
			for (var iclef = 0; iclef < anim.keys.length;iclef++)
			{
				DuAEF.DuAE.Property.setKey(prop,anim.keys[iclef],time);
				ok = true;
			}
		}
		else //set the start value
		{
			try
			{
				var value = anim.startValue;
				if (value instanceof Array)
				{
					while (value.length < dimensions)
					{
						value.push(0);
					}
					while (value.length > dimensions)
					{
						value.pop();
					}
				}
				if (anim.startValue != null) prop.setValue(anim.startValue);
				ok = true;
			} catch (err) {};
		}
		//set the expression
		if (prop.canSetExpression && setExpression)
		{
			prop.expression = anim.expression;
		}
	}

	return ok;
}

/**
* Sets all animations on a Property or a PropertyGroup.
* @param {PropertyGroup|PropertyInfo}	prop	- The property group.
* @param {PropertyAnim} anims	- The animation
* @param {float}	[time=comp.time]	- The time where to begin the animation
* @param {boolean}	[ignoreName=false]	- true to set the anim even if name of the property do not match the animation.
* @param {boolean}	[setExpression=false]	- Sets the expression too
* @return {boolean} true if the anim was actually set.
*/
DuAEF.DuAE.Property.setGroupAnim = function(prop,anim,time,ignoreName,setExpression)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (time == undefined) time = DuAEF.DuAE.Property.getPropertyComp(prop).time;
	if (ignoreName == undefined) ignoreName = false;
	if (setExpression == undefined) setExpression = false;

	var ok = false;

	if (anim == null) return true;

	if (anim.type == 'anim')
	{
		if (prop.matchName == anim._matchName && (!ignoreName && prop.name == anim._name || ignoreName))
		{
			return DuAEF.DuAE.Property.setAnim(prop,anim,time,setExpression);
		}
	}
	else
	{
		for (var i = 0 ; i < anim.anims.length ; i++)
		{
			var propAnim = anim.anims[i];
			//find the property with the same name and matchname
			for (var j = 1 ; j <= prop.numProperties ; j++)
			{
				var subProp = prop.property(j);
				if (subProp.matchName == propAnim._matchName && (!ignoreName && subProp.name == propAnim._name || ignoreName))
				{
					ok = DuAEF.DuAE.Property.setGroupAnim(subProp,propAnim,time,ignoreName,setExpression);
					break;
				}
			}
		}
	}

	return ok;
}

/**
* Removes the animation from the property
* @param {Property|PropertyInfo} prop -The property
* @param {boolean} [removeExpression=false] - Set to true to remove the expression too
*/
DuAEF.DuAE.Property.removeAnim = function(prop,removeExpression)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	while (prop.numKeys > 0)
	{
		prop.removeKey(1);
	}
	if (removeExpression && prop.canSetExpression)
	{
		prop.expression = '';
	}
}

/**
 * Gets an expression link to the property
 * @memberof DuAEF.DuAE.Property
 * @param {Property|PropertyInfo}	prop			- The property
 * @param {bool}		[useThisComp]		- Wether to begin the expression by 'thisComp' or 'comp("name")'
 * @return {str}		The expression link to the property
 */
DuAEF.DuAE.Property.getExpressionLink = function (prop,useThisComp)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (useThisComp == undefined) useThisComp = false;

	//get compact expression from matchName, if available
	function getCompactExpression(matchName, name)
	{
		var translatedName = DuAEF.DuAE.compactExpressions[matchName];

		if (translatedName !== undefined)
			return eval(translatedName);
		else
			return ("(" + name + ")");
	}

	var exprCode = "";
	var name;
	while (prop.parentProperty !== null)
	{
		if (prop.propertyType == PropertyType.PROPERTY ) name = prop.propertyIndex;
		else name = "\"" + prop.name + "\"";
		compactName = getCompactExpression(prop.matchName, name);
		exprCode = compactName + exprCode;

		// Traverse up the property tree
		prop = prop.parentProperty;
	}

	var comp = prop.containingComp;
	// Prefix the layer reference
	name = "\"" + prop.name + "\"";
	exprCode = "layer(" + name + ")." + exprCode;
	// Prefix the comp reference
	if (useThisComp) exprCode = "thisComp." + exprCode;
	else exprCode = "comp(\"" + comp.name + "\")." + exprCode;

	return exprCode;
}

/**
* Sets a value on a property, adjusting the dimensions if needed
* @param {Property|PropertyInfo} prop - The property
* @param {any} value - The value to set
*/
DuAEF.DuAE.Property.setValue = function(prop,value)
{
	var dimensions = 0;
	if (prop instanceof PropertyInfo)
	{
		dimensions = prop.dimensions;
		prop = prop.getProperty();
	}
	else
	{
		dimensions = DuAEF.DuAE.Property.getDimensions(prop);
	}
	if (dimensions == 0 || dimensions == 1)
	{
		if (value instanceof Array) value = value[0];
		prop.setValue(value);
	}

	else
	{
		if (!(value instanceof Array)) value = [value];
		while (value.length < dimensions)
		{
			value.push(0);
		}
		while (value.length > dimensions)
		{
			value.pop();
		}
		prop.setValue(value);
	}
}

/**
* Changes the interpolation type on selected keyframes, or sets a new key at current time if there are no keyframes selected.
* @param {Layer[]|LayerCollection} layers - The layers containing the properties
* @param {PropertyBase[]|PropertyInfo[]} props - The properties
* @param {KeyframeInterpolationType|string} typeIn - The in interpolation type (see AE API) or the string "roving" or "continuous"
* @param {KeyframeInterpolationType|string} [typeOut=typeIn] - The out interpolation type (see AE API)
* @param {int[]|int} [easeInValue=33] - The in interpolation ease value (used if typeIn is KeyframeInterpolationType.BEZIER)
* @param {int[]|int} [easeOutValue=easeInValue] - The out interpolation ease value (used if typeOut is KeyframeInterpolationType.BEZIER)
*/
DuAEF.DuAE.Property.setInterpolationType = function(layers,props,typeIn,typeOut,easeInValue,easeOutValue)
{
	if (typeOut == undefined) typeOut = typeIn;
	if (easeInValue == undefined) easeInValue = 33;
	if (isNaN(easeInValue)) easeInValue = 33;
	if (easeOutValue == undefined) easeOutValue = easeInValue;
	if (isNaN(easeOutValue)) easeOutValue = 33;

	easeInValue = new KeyframeEase(0,easeInValue);
	easeOutValue = new KeyframeEase(0,easeOutValue);

	if (!DuAEF.DuAE.Layer.haveSelectedKeys(layers))
	{
		for (var i=0;i<props.length;i++)
		{
			var propInfo = props[i];
			var prop = props[i];
			if (!(propInfo instanceof PropertyInfo)) propInfo = new PropertyInfo(prop);
			prop = props[i].getProperty();

			if (prop.canVaryOverTime)
			{
				var key = prop.addKey(comp.time);
				if (typeIn == "roving") prop.setRovingAtKey(key,true);
				else if (typeIn == "continuous")
				{
					prop.setInterpolationTypeAtKey(key,KeyframeInterpolationType.BEZIER);
					prop.setTemporalContinuousAtKey(key, true);
					prop.setTemporalAutoBezierAtKey(key, true);
				}
				else
				{
					//influences
					if (!prop.isSpatial && prop.value.length == 3) { prop.setTemporalEaseAtKey(key,[easeInValue,easeInValue,easeInValue],[easeOutValue,easeOutValue,easeOutValue]); }
					else if (!prop.isSpatial && prop.value.length == 2) { prop.setTemporalEaseAtKey(key,[easeInValue,easeInValue],[easeOutValue,easeOutValue]); }
					else { prop.setTemporalEaseAtKey(key,[easeInValue],[easeOutValue]); }
					prop.setInterpolationTypeAtKey(key,typeIn,typeOut);
					//not continuous
					prop.setTemporalContinuousAtKey(key, false);
				}
			}
		}
	}
	else
	{
		for (var i=0;i<props.length;i++)
		{
			var propInfo = props[i];
			var prop = props[i];
			if (!(propInfo instanceof PropertyInfo)) propInfo = new PropertyInfo(prop);
			prop = props[i].getProperty();

			if (prop.canVaryOverTime)
			{
				//for keys
				for (var k=0;k<prop.selectedKeys.length;k++)
				{
					if (typeIn == "roving") {if(prop.isSpatial) prop.setRovingAtKey(prop.selectedKeys[k],true);}
					else if (typeIn == "continuous")
					{
						prop.setInterpolationTypeAtKey(prop.selectedKeys[k],KeyframeInterpolationType.BEZIER);
						prop.setTemporalContinuousAtKey(prop.selectedKeys[k], true);
						prop.setTemporalAutoBezierAtKey(prop.selectedKeys[k], true);
						//not roving
						try { prop.setRovingAtKey(prop.selectedKeys[k],false); } catch(e){}
					}
					else
					{
						//influences
						if (!prop.isSpatial && prop.value.length == 3) { prop.setTemporalEaseAtKey(prop.selectedKeys[k],[easeInValue,easeInValue,easeInValue],[easeOutValue,easeOutValue,easeOutValue]); }
						else if (!prop.isSpatial && prop.value.length == 2) { prop.setTemporalEaseAtKey(prop.selectedKeys[k],[easeInValue,easeInValue],[easeOutValue,easeOutValue]); }
						else { prop.setTemporalEaseAtKey(prop.selectedKeys[k],[easeInValue],[easeOutValue]); }
						//type
						prop.setInterpolationTypeAtKey(prop.selectedKeys[k],typeIn,typeOut);
						//not roving
						try { prop.setRovingAtKey(prop.selectedKeys[k],false); } catch(e){}
						//not continuous
						prop.setTemporalContinuousAtKey(prop.selectedKeys[k], false);
					}
				}
			}
		}
	}
}

/**
* Changes the ease influences of the selected keys
* @param {PropertyBase[]|PropertyInfo[]} props - The properties
* @param {int[]|int} [easeInValue] - The in interpolation ease value. Will be ignored if undefined.
* @param {int[]|int} [easeOutValue] - The out interpolation ease value. Will be ignored if undefined.
* @param {int[]|int} [velocityInValue] - The out interpolation ease value. Will be ignored if undefined.
* @param {int[]|int} [velocityOutValue] - The out interpolation ease value. Will be ignored if undefined.
*/
DuAEF.DuAE.Property.setEase = function(props,easeInValue,easeOutValue,velocityInValue,velocityOutValue)
{
	if (isNaN(easeInValue) && easeInValue != undefined) easeInValue = 33;
	if (isNaN(easeOutValue) && easeOutValue != undefined) easeOutValue = 33;
	if (isNaN(velocityInValue) && velocityInValue != undefined) velocityInValue = 0;
	if (isNaN(velocityOutValue) && velocityOutValue != undefined) velocityOutValue = 0;

	for (var i = 0; i < props.length ; i++)
	{
		var propInfo = props[i];
		var prop = props[i];
		if (!(propInfo instanceof PropertyInfo)) propInfo = new PropertyInfo(prop);
		prop = propInfo.getProperty();

		if (prop.canVaryOverTime)
		{
			for (var k=0 ; k < prop.selectedKeys.length ; k++)
			{
				var key = prop.selectedKeys[k];
				var easeIn =  [ new KeyframeEase(velocityInValue != undefined ? velocityInValue : prop.keyInTemporalEase(key)[0].speed, easeInValue != undefined ? easeInValue : prop.keyInTemporalEase(key)[0].influence) ];
				var easeOut = [ new KeyframeEase(velocityOutValue != undefined ? velocityOutValue : prop.keyOutTemporalEase(key)[0].speed, easeOutValue != undefined ? easeOutValue : prop.keyOutTemporalEase(key)[0].influence) ];
				if (!prop.isSpatial)
				{
					for (var j = 1;j < prop.keyInTemporalEase(prop.selectedKeys[k]).length ; j++)
					{
						easeIn.push( new KeyframeEase(velocityInValue != undefined ? velocityInValue : prop.keyInTemporalEase(key)[j].speed, easeInValue != undefined ? easeInValue : prop.keyInTemporalEase(key)[j].influence) );
						easeOut.push( new KeyframeEase(velocityOutValue != undefined ? velocityOutValue : prop.keyOutTemporalEase(key)[j].speed, easeOutValue != undefined ? easeOutValue : prop.keyOutTemporalEase(key)[j].influence) );
					}
				}
				prop.setTemporalEaseAtKey(key,easeIn,easeOut);
			}
		}
	}
}

/**
* Checks if the property has some selected keyframes.<br />
* The property can be either a Property or a PropertyGroup.
* @param {PropertyBase} prop - The property
* @return {boolean} true if the property have at least one selected keyframe
*/
DuAEF.DuAE.Property.hasSelectedKeys = function (prop)
{
	var yes = false;

	if (prop.propertyType == PropertyType.PROPERTY)
	{
		if (prop.selectedKeys.length >0)
		{
			yes = true;
		}
	}
	else if (prop.numProperties > 0)
	{
		for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
		{
			yes = DuAEF.DuAE.Property.hasSelectedKeys(prop.property(propIndex));
			if (yes) break;
		}
	}
	return yes;
}

/**
* Sets the spatial interpolation of the selected keyframes on the property
* @param {Property|PropertyInfo} prop - The property
* @param {KeyframeInterpolationType} typeIn - The in interpolation type (see AE API)
* @param {KeyframeInterpolationType} [typeOut=typeIn] - The in interpolation type (see AE API)
*/
DuAEF.DuAE.Property.setSpatialInterpolation = function (prop,typeIn,typeOut)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (typeOut == undefined) typeOut = typeIn;
	if (!prop.isSpatial) return;
		if (prop.selectedKeys.length == 0) return;
	for (var k=0;k<prop.selectedKeys.length;k++)
	{
		if (typeIn == KeyframeInterpolationType.BEZIER && typeOut == KeyframeInterpolationType.BEZIER)
		{
			prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
		}
		else if (typeIn == KeyframeInterpolationType.LINEAR && typeOut == KeyframeInterpolationType.LINEAR)
		{
			prop.setSpatialContinuousAtKey(prop.selectedKeys[k],false);
			prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],false);
			if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL)
			{
				prop.setSpatialTangentsAtKey(prop.selectedKeys[k],[0,0,0],[0,0,0]);
    		}
    		else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL)
    		{
    		    prop.setSpatialTangentsAtKey(prop.selectedKeys[k],[0,0],[0,0]);
    		}
		}
		else if (typeIn == KeyframeInterpolationType.BEZIER)
		{
			prop.setSpatialContinuousAtKey(prop.selectedKeys[k],false);
            prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],false);
            var keyIndex = prop.selectedKeys[k];
            if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL)
            {
                if (prop.keyInSpatialTangent(keyIndex)[0] == 0 && prop.keyInSpatialTangent(keyIndex)[1] == 0 && prop.keyInSpatialTangent(keyIndex)[2] == 0)
                {
                    prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
                }
                prop.setSpatialTangentsAtKey(keyIndex,prop.keyInSpatialTangent(keyIndex),[0,0,0]);
            }
            else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL)
            {
                if (prop.keyInSpatialTangent(keyIndex)[0] == 0 && prop.keyInSpatialTangent(keyIndex)[1] == 0)
                {
                    prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
                }
                prop.setSpatialTangentsAtKey(keyIndex,prop.keyInSpatialTangent(keyIndex),[0,0]);
            }
		}
		else if (typeIn == KeyframeInterpolationType.LINEAR)
		{
			prop.setSpatialContinuousAtKey(prop.selectedKeys[k],false);
            prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],false);
            var keyIndex = prop.selectedKeys[k];
            if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL)
            {
                if (prop.keyOutSpatialTangent(keyIndex)[0] == 0 && prop.keyOutSpatialTangent(keyIndex)[1] == 0 && prop.keyOutSpatialTangent(keyIndex)[2] == 0)
                {
                    prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
                }
                prop.setSpatialTangentsAtKey(keyIndex,[0,0,0],prop.keyOutSpatialTangent(keyIndex));
            }
            else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL)
            {
                if (prop.keyOutSpatialTangent(keyIndex)[0] == 0 && prop.keyOutSpatialTangent(keyIndex)[1] == 0)
                {
                    prop.setSpatialAutoBezierAtKey(prop.selectedKeys[k],true);
                }
                prop.setSpatialTangentsAtKey(keyIndex,[0,0],prop.keyOutSpatialTangent(keyIndex));
            }
		}
	}
}

/**
* Fixes the spatial interpolation of the selected keys.<br />
* Sets the interpolation to linear when the property does not move between keyframes
* @param {Property|PropertyInfo} prop - The property
*/
DuAEF.DuAE.Property.fixSpatialInterpolation = function(prop)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();

	if (!prop.isSpatial) return;
    if (!prop.canVaryOverTime) return;

    var keyIndices = prop.selectedKeys;
    if (keyIndices.length < 2) return;

	for (var k=0;k<keyIndices.length-1;k++)
	{
	    var key = keyIndices[k];
	    var nextKey = keyIndices[k+1]
	    //get this key value
	    var keyValue = prop.valueAtTime(prop.keyTime(key),true);
	    //get next key value
	    var nextKeyValue = prop.valueAtTime(prop.keyTime(key+1),true);

	    //compare and set
	    if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL)
	    {
	        if (keyValue[0] == nextKeyValue[0] && keyValue[1] == nextKeyValue[1] && keyValue[2] == nextKeyValue[2])
	        {
	            prop.setSpatialTangentsAtKey(key,prop.keyInSpatialTangent(key),[0,0,0]);
	            prop.setSpatialTangentsAtKey(nextKey,[0,0,0],prop.keyOutSpatialTangent(nextKey));
	        }
	    }
	    else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL)
	    {
	        if (keyValue[0] == nextKeyValue[0] && keyValue[1] == nextKeyValue[1])
	        {
	            prop.setSpatialTangentsAtKey(key,prop.keyInSpatialTangent(key),[0,0]);
	            prop.setSpatialTangentsAtKey(nextKey,[0,0],prop.keyOutSpatialTangent(nextKey));
	        }
	    }
	}
}

/**
* Gets the average speed of the animated propreties
* @param {Property[]|PropertyInfo[]} props - The Properties
* @return {float} The average speed
*/
DuAEF.DuAE.Property.getAverageSpeed = function(props)
{
	var averageSpeed = 0;
	var count = 0;

	for (var i = 0 ; i < props.length ; i++)
	{
		var prop = props[i];
		if (prop instanceof PropertyInfo) prop = prop.getProperty();
		if (prop.propertyType != PropertyType.PROPERTY) continue;
		if (!prop.canVaryOverTime) continue;
		if (prop.numKeys < 1) continue;

		var comp = DuAEF.DuAE.Property.getComp(prop);
		var frames = comp.duration / comp.frameDuration ;
		var lastTime = prop.keyTime(prop.numKeys);
		var firstTime = prop.keyTime(1);
		var lastFrame = lastTime/comp.frameDuration ;
		var firstFrame = firstTime/comp.frameDuration ;
		if (lastFrame > frames) lastFrames = frames;
		if (firstFrame < 1) firstFrame = 1;
		var sum = 0;
		for (var frame = firstFrame ; frame < lastFrame ; frame++)
		{
			var time = frame*comp.frameDuration;
			sum += DuAEF.DuAE.Property.getSpeed(prop,time);
		}
		var speed = sum/(lastFrame-firstFrame);

		if (speed > 0)
		{
			averageSpeed += speed;
			count++;
		}
	}

	averageSpeed = averageSpeed/count;
	return averageSpeed;
}

/**
* Gets the speed of a property at a given time
* @param {Property|PropertyInfo} prop - The property
* @param {float} [time=composition.time] - The time.
* @return {float} The speed
*/
DuAEF.DuAE.Property.getSpeed = function (prop,time)
{
	if (prop instanceof PropertyInfo) prop = prop.getProperty();
	if (prop.propertyType != PropertyType.PROPERTY) return 0;
	if (prop.numKeys == 0) return 0;
	var comp = DuAEF.DuAE.Property.getComp(prop);
	if (time == undefined) time = comp.time;

	var speed = DuAEF.DuJS.Math.getLength(prop.valueAtTime(time+comp.frameDuration,false),prop.valueAtTime(time-comp.frameDuration,false));
	return speed;
}

/**
* Bezier Paths methods
* @namespace
* @memberof DuAEF.DuAE.Property
*/
DuAEF.DuAE.Property.Shape = {};

/**
* Makes a horizontal symetry transformation on the path.
* @param {Property}	pathProperty	- The After Effects Property containing the path to symetrize
*/
DuAEF.DuAE.Property.Shape.horizontalSymetry = function(pathProperty)
{
	if (pathProperty.propertyType !== PropertyType.PROPERTY) throw "Expected a shape property, got a group.";
	if (pathProperty.propertyValueType !== PropertyValueType.SHAPE) throw "Expected a shape property, got another type of value.";

	var shape = pathProperty.value;
	var vertices = shape.vertices;
	var inTangents = shape.inTangents;
	var outTangents = shape.outTangents;

	//get the horizontal center.
	var center = 0;
	for (var i = 0 ; i < vertices.length; i++)
	{
		center += vertices[i][0];
	}
	center = center / vertices.length;

	//twice the value for computing symetry
	center = center*2;

	//compute
	for (var i = 0 ; i < vertices.length; i++)
	{
		vertices[i][0] = center - vertices[i][0];
		inTangents[i][0] = -inTangents[i][0];
		outTangents[i][0] = -outTangents[i][0];
	}

	//set
	shape.vertices = vertices;
	shape.inTangents = inTangents;
	shape.outTangents = outTangents;
	if (pathProperty.numKeys > 0)
	{
		pathProperty.setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperty).time,shape);
	}
	else
	{
		pathProperty.setValue(shape);
	}
}

/**
* Makes a horizontal symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
* @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
*/
DuAEF.DuAE.Property.Shape.horizontalSymetries = function(pathProperties)
{
	var shapes = [];
	//get shapes and center
	var center = 0;
	var verticesCount = 0;
	for (var i = 0 ; i < pathProperties.length ; i++)
	{
		var shape = pathProperties[i].value;
		shapes.push(shape);
		for (var j = 0 ; j < shape.vertices.length; j++)
		{
			verticesCount++;
			center += shape.vertices[j][0];
		}
	}
	center = center / verticesCount;
	center = center *2;

	//compute
	for (var i = 0 ; i < shapes.length; i++)
	{
		var shape = shapes[i];
		var vertices = shape.vertices;
		var inTangents = shape.inTangents;
		var outTangents = shape.outTangents;
		for (var j = 0 ; j < shape.vertices.length ; j++)
		{
			vertices[j][0] = center - vertices[j][0];
			inTangents[j][0] = -inTangents[j][0];
			outTangents[j][0] = -outTangents[j][0];
		}
		shape.vertices = vertices;
		shape.inTangents = inTangents;
		shape.outTangents = outTangents;
		if (pathProperties[i].numKeys > 0)
		{
			pathProperties[i].setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperties[i]).time,shape);
		}
		else
		{
			pathProperties[i].setValue(shape);
		}
	}
}

/**
* Makes a vertical symetry transformation on the path.
* @param {Property}	pathProperty	- The After Effects Property containing the path to symetrize
*/
DuAEF.DuAE.Property.Shape.verticalSymetry = function(pathProperty)
{
	if (pathProperty.propertyType !== PropertyType.PROPERTY) throw "Expected a shape property, got a group.";
	if (pathProperty.propertyValueType !== PropertyValueType.SHAPE) throw "Expected a shape property, got another type of value.";

	var shape = pathProperty.value;
	var vertices = shape.vertices;
	var inTangents = shape.inTangents;
	var outTangents = shape.outTangents;

	//get the horizontal center.
	var center = 0;
	for (var i = 0 ; i < vertices.length; i++)
	{
		center += vertices[i][1];
	}
	center = center / vertices.length;

	//twice the value for computing symetry
	center = center*2;

	//compute
	for (var i = 0 ; i < vertices.length; i++)
	{
		vertices[i][1] = center - vertices[i][1];
		inTangents[i][1] = -inTangents[i][1];
		outTangents[i][1] = -outTangents[i][1];
	}

	//set
	shape.vertices = vertices;
	shape.inTangents = inTangents;
	shape.outTangents = outTangents;
	if (pathProperty.numKeys > 0)
	{
		pathProperty.setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperty).time,shape);
	}
	else
	{
		pathProperty.setValue(shape);
	}
}

/**
* Makes a vertical symetry transformation on the paths, using the same axis of symetry for all shapes (shapes must be on the same layer).
* @param {Property[]}	pathProperties	- The After Effects Properties containing the paths to symetrize
*/
DuAEF.DuAE.Property.Shape.verticalSymetries = function(pathProperties)
{
	var shapes = [];
	//get shapes and center
	var center = 0;
	var verticesCount = 0;
	for (var i = 0 ; i < pathProperties.length ; i++)
	{
		var shape = pathProperties[i].value;
		shapes.push(shape);
		for (var j = 0 ; j < shape.vertices.length; j++)
		{
			verticesCount++;
			center += shape.vertices[j][1];
		}
	}
	center = center / verticesCount;
	center = center *2;

	//compute
	for (var i = 0 ; i < shapes.length; i++)
	{
		var shape = shapes[i];
		var vertices = shape.vertices;
		var inTangents = shape.inTangents;
		var outTangents = shape.outTangents;
		for (var j = 0 ; j < shape.vertices.length ; j++)
		{
			vertices[j][1] = center - vertices[j][1];
			inTangents[j][1] = -inTangents[j][1];
			outTangents[j][1] = -outTangents[j][1];
		}
		shape.vertices = vertices;
		shape.inTangents = inTangents;
		shape.outTangents = outTangents;
		if (pathProperties[i].numKeys > 0)
		{
			pathProperties[i].setValueAtTime(DuAEF.DuAE.Property.getPropertyComp(pathProperties[i]).time,shape);
		}
		else
		{
			pathProperties[i].setValue(shape);
		}
	}
}
