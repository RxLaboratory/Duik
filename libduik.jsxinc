/*
Duik - Duduf IK Tools
Copyright (c) 2008 - 2015 Nicolas Dufresne
http://www.duduf.net

Many thanks to :
Dan Ebberts - Writing the first IK Expressions
Eric Epstein - making the IK's work with 3D Layers
All 258 indiegogo crowdfunders for making this libDuik possible!

This file is part of Duik.

    Duik is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Duik is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Duik. If not, see <http://www.gnu.org/licenses/>.
*/

// =====================================================================
//                                   LibDuik 
// =====================================================================

/* This file should not be edited,

	If you need to change some settings, you should change them inside your own script.
	Example:
	Changing controllers size (in pixels):
		Duik.settings.controllerSize = 50;
		
	A complete list of settings is available in the developper's guide of libDuik on
	http://www.duduf.net
	
	If you need to change UI strings (for localization) you can access them in Duik.uiStrings
	Example:
		Duik.uiStrings.ikFkBox = "IK / FK"
		
	A complete list of uiStrings is available in the developper's guide of libDuik on
	http://www.duduf.net
	
	However, if you're modifying this file, you may want to force reload the class for testing purposes.
	Uncomment the first line of the script (FORCE RELOAD section)
		if (typeof Duik === 'object') delete Duik;
	
*/

/////////////////////////////
// FORCE RELOAD
/////////////////////////////
if (typeof Duik === 'object') delete Duik;

////////////////////////////
// DEFINITIONS
////////////////////////////
{
	if (typeof Duik !== 'object')
	{
		Duik = {};
		Duik.versionNumber = 0.0;
	}
	function KeySpatialProperties ()
	{
		this.inTangent = null;
		this.outTangent = null;
		this.continuous = true;
		this.autoBezier = false;
		this.roving = false;
	}
	function KeyFrame()
	{
		this.time = 0;
		this.value = null;
		this.inInterpolationType = KeyframeInterpolationType.LINEAR;
		this.outInterpolationType = KeyframeInterpolationType.LINEAR;
		this.spatial = false;
		this.spatialProperties = new KeySpatialProperties();
		this.inEase = 0;
		this.outEase = 0;
		this.continuous = false;
		this.autoBezier = false;
	}
	function PropertyAnim()
	{
		this.name = "";
		this.keys = [];
		this.startValue = null;
	}
	function MaskAnim()
	{
		this.name = "";
		this.anims = [];
	}
	function EffectAnim()
	{
		this.name = "";
		this.matchName = "";
		this.anims = [];
	}
	function LayerAnim()
	{
		this.name = "";
		this.index = 0;
		this.transformAnims = [];
		this.masksAnims = [];
		this.effectsAnims = [];
	}
	function IKRig()
	{
		this.type = 0;
		this.layer1 = null; //root
		this.layer2 = null; //middle
		this.layer3 = null; //end
		this.goal = null;
		this.controller = null;
		this.threeD = false;
		this.frontFacing = false;
		this.clockWise = false;
		this.created = false;
	}
	IKRig.prototype.create = function ()
	{
		if (this.created) return null;
		if (this.type == 1 && this.layer1 != null && this.controller != null)
		{
			this.created = Duik.oneLayerIK(this.controller,this.layer1);
			if (!this.created) return;
			if (this.goal != null)
			{
				if (this.layer1.parent = this.goal) this.layer1.parent = null;
				this.goal.parent = this.layer1;
				Duik.goal(this.goal,this.controller);
			}
			return null;
		}
		else if (this.type == 2 && this.layer1 != null && this.layer2 != null && this.controller != null)
		{
			//parents
			if (this.layer1.parent == this.layer2) this.layer1.parent = null;
			this.layer2.parent = this.layer1;
			//3d
			this.threeD = this.controller.threeDLayer && this.layer1.threeDLayer && this.layer2.threeDLayer;
			//create
			var zero = Duik.twoLayerIK(this.controller,this.layer1,this.layer2,this.clockWise,this.frontFacing);
			if (zero == null)
			{
				this.created = false;
				return zero;
			}
			this.created = true;
			//goal
			if (this.goal != null)
			{
				this.goal.parent = zero;
				Duik.goal(this.goal,this.controller);
			}
			return zero;
		}
		else if (this.type == 3 && this.layer1 != null && this.layer2 != null && this.layer3 != null && this.controller != null)
		{
			//parents
			if (this.layer2.parent == this.layer3) this.layer2.parent = null;
			if (this.layer1.parent == this.layer2) this.layer1.parent = null;
			this.layer3.parent = this.layer2;
			this.layer2.parent = this.layer1;
			//create
			var zero = Duik.threeLayerIK(this.controller,this.layer1,this.layer2,this.layer3,this.clockWise);
			if (zero == null) {
				this.created = false;
				return zero;
			}
			this.created = true;
			//goal			
			if (this.goal != null)
			{
				this.goal.parent = zero;
				Duik.goal(this.goal,this.controller);
			}
			return zero;
		}
	}
	function PropertyDescription()
	{
		this.isEffect = false;
		this.index = 0;
		this.depth = 0;
		this.parentName = "";
		this.dimensions = 0;
		this.canSetExpression = false;
	}
	function Controller()
	{
		this.locked = false;
		this.xPosition = false;
		this.yPosition = false;
		this.rotation = false;
		this.scale = false;
		this.arc = false;
		this.eye = false;
		this.size = 0;
		this.color = [1,1,1,1];
		this.layer = null;
		this.type = Duik.layerTypes.VECTOR;
	}
	Controller.prototype.lock = function()
	{
		if (this.layer == null)
		{
			this.locked = false;
			return;
		}
		//get value
		var posValue = this.layer.transform.position.value;
		var rotValue = this.layer.transform.rotation.value;
		var scaValue = this.layer.transform.scale.value;
		if (!this.xPosition && !this.yPosition && !this.eye)
		{
			if (this.layer.transform.position.canSetExpression)
			{
				this.layer.transform.position.expression = "[" + posValue[0] + "," + posValue[1] + "]";
			}
			else
			{
				this.layer.transform.xPosition.expression = posValue[0];
				this.layer.transform.yPosition.expression = posValue[1];
			}
		}
		else if (this.xPosition && !this.yPosition)
		{
			this.layer.transform.position.expression = "[value[0]," + posValue[1] + "]";
		}
		else if (this.yPosition && !this.xPosition)
		{
			this.layer.transform.position.expression = "[" + posValue[0] + ",value[1]]";
		}
		if (!this.rotation || !this.arc)
		{
			this.layer.transform.rotation.expression = rotValue;
		}
		if (!this.scale)
		{
			this.layer.transform.scale.expression = "[" + scaValue[0] + "," + scaValue[1] + "]";
		}
		this.locked = true;
	}
	Controller.prototype.unlock = function()
	{
		if (this.layer == null)
		{
			this.locked = false;
			return;
		}
		//get value
		var posValue = this.layer.transform.position.value;
		var rotValue = this.layer.transform.rotation.value;
		var scaValue = this.layer.transform.scale.value;
		this.layer.transform.position.expression = "";
		this.layer.transform.position.setValue(posValue);
		this.layer.transform.rotation.expression = "";
		this.layer.transform.rotation.setValue(rotValue);
		this.layer.transform.scale.expression = "";
		this.layer.transform.scale.setValue(scaValue);
		this.locked = false;
	}
	Controller.prototype.update = function()
	{
		if (this.type != Duik.layerTypes.VECTOR || this.layer == null) return;
		
		var iconGroup = this.layer.property("ADBE Root Vectors Group")("Icon");
		if (iconGroup != null) iconGroup.remove();

		//controller size
		var controllerSize = this.size;
		if (controllerSize == 0)
		{
			controllerSize = this.layer.containingComp.width/2 + this.layer.containingComp.height/2;
			if (Duik.settings.controllerSizeHint == Duik.sizes.SMALL) controllerSize = Math.floor(controllerSize/40)*100/30;
			else if (Duik.settings.controllerSizeHint == Duik.sizes.MEDIUM) controllerSize = Math.floor(controllerSize/20)*100/30;
			else if (Duik.settings.controllerSizeHint == Duik.sizes.BIG) controllerSize = Math.floor(controllerSize/10)*100/30;
		}

		if (this.arc)
		{
			this.xPosition = false;
			this.yPosition = false;
			this.rotation = false;
			this.scale = false;
			this.eye = false;
		}
		else if (this.eye)
		{
			this.xPosition = false;
			this.yPosition = false;
			this.rotation = false;
			this.scale = false;
			this.arc = false;
		}
		
		iconGroup = this.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
		iconGroup.name = "Icon";
		controllerSizeFactor = controllerSize;
		iconGroup("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([controllerSizeFactor,controllerSizeFactor]);
		if (this.rotation)
		{
			//draw
			var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
			group.name = "Rotation";
			var groupContent = group.property("ADBE Vectors Group");
			var ellipse = groupContent.addProperty("ADBE Vector Shape - Ellipse");
			ellipse("ADBE Vector Ellipse Size").setValue([30,30]);
			var trim = groupContent.addProperty("ADBE Vector Filter - Trim");
			 trim("ADBE Vector Trim End").setValue(85);
			var arrowShape = new Shape();
			arrowShape.vertices = [[0,-15], [10,-20]];
			arrowShape.closed = false;
			var arrow = groupContent.addProperty("ADBE Vector Shape - Group");
			arrow("ADBE Vector Shape").setValue(arrowShape);
			var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").setValue(this.color);
			stroke("ADBE Vector Stroke Width").setValue(2);
			group("ADBE Vector Transform Group")("ADBE Vector Rotation").setValue(-20);
		}
		if (this.xPosition)
		{
			var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
			group.name = "xPosition";
			var groupContent = group.property("ADBE Vectors Group");
			var horizontalShape = new Shape();
			horizontalShape.vertices = [[15,0], [-15,0]];
			horizontalShape.closed = false;
			var horizontal = groupContent.addProperty("ADBE Vector Shape - Group");
			horizontal("ADBE Vector Shape").setValue(horizontalShape);
			var arrowShape1 = new Shape();
			arrowShape1.vertices = [[10,-7],[15,0], [10,7]];
			arrowShape1.closed = false;
			var arrow1 = groupContent.addProperty("ADBE Vector Shape - Group");
			arrow1("ADBE Vector Shape").setValue(arrowShape1);
			var arrowShape2 = new Shape();
			arrowShape2.vertices = [[-10,7],[-15,0], [-10,-7]];
			arrowShape2.closed = false;
			 var arrow2 = groupContent.addProperty("ADBE Vector Shape - Group");
			arrow2("ADBE Vector Shape").setValue(arrowShape2);
			var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").setValue(this.color);
			if (this.rotation) stroke("ADBE Vector Stroke Width").setValue(2);
			else stroke("ADBE Vector Stroke Width").setValue(2);
			if (this.rotation) group("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([70,70]);
		}
		if (this.yPosition)
		{
			var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
			group.name = "yPosition";
			var groupContent = group.property("ADBE Vectors Group");
			var verticalShape = new Shape();
			verticalShape.vertices = [[0,-15], [0,15]];
			verticalShape.closed = false;
			var vertical = groupContent.addProperty("ADBE Vector Shape - Group");
			vertical("ADBE Vector Shape").setValue(verticalShape);
			var arrowShape3 = new Shape();
			arrowShape3.vertices = [[-7,10],[0,15], [7,10]];
			arrowShape3.closed = false;
			var arrow3 = groupContent.addProperty("ADBE Vector Shape - Group");
			arrow3("ADBE Vector Shape").setValue(arrowShape3);
			var arrowShape4 = new Shape();
			arrowShape4.vertices = [[-7,-10],[0,-15], [7,-10]];
			arrowShape4.closed = false;
			 var arrow4 = groupContent.addProperty("ADBE Vector Shape - Group");
			arrow4("ADBE Vector Shape").setValue(arrowShape4);
			var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").setValue(this.color);
			if (this.rotation) stroke("ADBE Vector Stroke Width").setValue(2);
			else stroke("ADBE Vector Stroke Width").setValue(2);
			if (this.rotation) group("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([70,70]);
		}
		if (this.scale)
		{
			var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
			group.name = "Scale";
			var groupContent = group.property("ADBE Vectors Group");
			var cornerShape1 = new Shape();
			cornerShape1.vertices = [[-10,-20],[-20,-20], [-20,-10]];
			cornerShape1.closed = false;
			var corner1 = groupContent.addProperty("ADBE Vector Shape - Group");
			corner1("ADBE Vector Shape").setValue(cornerShape1);
			var cornerShape2 = new Shape();
			cornerShape2.vertices = [[10,-20],[20,-20], [20,-10]];
			cornerShape2.closed = false;
			var corner2 = groupContent.addProperty("ADBE Vector Shape - Group");
			corner2("ADBE Vector Shape").setValue(cornerShape2);
			var cornerShape3 = new Shape();
			cornerShape3.vertices = [[10,20],[20,20], [20,10]];
			cornerShape3.closed = false;
			var corner3 = groupContent.addProperty("ADBE Vector Shape - Group");
			corner3("ADBE Vector Shape").setValue(cornerShape3);
			var cornerShape4 = new Shape();
			cornerShape4.vertices = [[-10,20],[-20,20], [-20,10]];
			cornerShape4.closed = false;
			var corner4 = groupContent.addProperty("ADBE Vector Shape - Group");
			corner4("ADBE Vector Shape").setValue(cornerShape4);
			var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").setValue(this.color);
			stroke("ADBE Vector Stroke Width").setValue(2);
		}
		if (this.arc)
		{
			var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
			group.name = "Arc";
			var groupContent = group.property("ADBE Vectors Group");
			var ellipse = groupContent.addProperty("ADBE Vector Shape - Ellipse");
			ellipse("ADBE Vector Ellipse Size").setValue([30,30]);
			var trim = groupContent.addProperty("ADBE Vector Filter - Trim");
			trim("ADBE Vector Trim End").setValue(35);
			var arrowShape = new Shape();
			arrowShape.vertices = [[0,-15], [10,-20]];
			arrowShape.closed = false;
			var arrow = groupContent.addProperty("ADBE Vector Shape - Group");
			arrow("ADBE Vector Shape").setValue(arrowShape);
			var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").setValue(this.color);
			stroke("ADBE Vector Stroke Width").setValue(2);
			group("ADBE Vector Transform Group")("ADBE Vector Rotation").setValue(-60);
		}
		if (this.eye)
		{
			var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
			group.name = "Eye";
			var groupContent = group.property("ADBE Vectors Group");
			
			var eyeGroup = groupContent.addProperty("ADBE Vector Group");
			eyeGroup.name = "eye";
			var eyeGroupContent = eyeGroup.property("ADBE Vectors Group");
			var eye = eyeGroupContent.addProperty("ADBE Vector Shape - Group");
			var eyeShape = new Shape();
			eyeShape.vertices = [[-12,0], [12,0]];
			eyeShape.inTangents = [[0,0], [-12,12]];
			eyeShape.outTangents = [[0,0], [-12,-12]];
			eyeShape.closed = true;
			eye("ADBE Vector Shape").setValue(eyeShape);
			var pupil = eyeGroupContent.addProperty("ADBE Vector Shape - Ellipse");
			pupil("ADBE Vector Ellipse Size").setValue([7,7]);
			var fill = eyeGroupContent.addProperty("ADBE Vector Graphic - Fill");
			fill("ADBE Vector Fill Color").setValue(this.color);
			
			var xGroup = groupContent.addProperty("ADBE Vector Group");
			xGroup.name = "xPosition";
			var xGroupContent = xGroup.property("ADBE Vectors Group");
			var arrowShape1 = new Shape();
			arrowShape1.vertices = [[10,-7],[15,0], [10,7]];
			arrowShape1.closed = false;
			var arrow1 = xGroupContent.addProperty("ADBE Vector Shape - Group");
			arrow1("ADBE Vector Shape").setValue(arrowShape1);
			var arrowShape2 = new Shape();
			arrowShape2.vertices = [[-10,7],[-15,0], [-10,-7]];
			arrowShape2.closed = false;
			var arrow2 = xGroupContent.addProperty("ADBE Vector Shape - Group");
			arrow2("ADBE Vector Shape").setValue(arrowShape2);
			var stroke = xGroupContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").setValue(this.color);
			stroke("ADBE Vector Stroke Width").setValue(2);
			
			var yGroup = groupContent.addProperty("ADBE Vector Group");
			yGroup.name = "yPosition";
			var yGroupContent = yGroup.property("ADBE Vectors Group");
			var arrowShape3 = new Shape();
			arrowShape3.vertices = [[-7,10],[0,15], [7,10]];
			arrowShape3.closed = false;
			var arrow3 = yGroupContent.addProperty("ADBE Vector Shape - Group");
			arrow3("ADBE Vector Shape").setValue(arrowShape3);
			var arrowShape4 = new Shape();
			arrowShape4.vertices = [[-7,-10],[0,-15], [7,-10]];
			arrowShape4.closed = false;
			 var arrow4 = yGroupContent.addProperty("ADBE Vector Shape - Group");
			arrow4("ADBE Vector Shape").setValue(arrowShape4);
			var stroke = yGroupContent.addProperty("ADBE Vector Graphic - Stroke");
			stroke("ADBE Vector Stroke Color").setValue(this.color);
			stroke("ADBE Vector Stroke Width").setValue(2);

		}
		
	}
}

/////////////////////////////
// INITIALIZATION
/////////////////////////////
(function ()
{
	if (Duik.versionNumber != 15.0013)
	{
		delete Duik;
		Duik = {};
		Duik.version = "15.alpha13";
		Duik.versionNumber = 15.0013;
		Duik.usePresets = true;
		Duik.presetPath = $.fileName.substring(0,$.fileName.lastIndexOf("/")) + "/";
		Duik.presetEffectsInstalledVersion = 0.0;
		Duik.copiedAnim = [];
		Duik.sizes = {};
		Duik.sizes.SMALL = 0;
		Duik.sizes.MEDIUM = 1;
		Duik.sizes.BIG = 2;
		Duik.layerTypes = {};
		Duik.layerTypes.VECTOR = 2;
		Duik.layerTypes.NULL = 1;
		Duik.layerTypes.SOLID = 0;
		Duik.getLayers = {};
		Duik.getLayers.INDEX = 0;
		Duik.getLayers.NAME = 1;
		Duik.getLayers.SELECTION_INDEX = 2;
	}
}());

/////////////////////////////
// INSTALLATION CHECKS
/////////////////////////////
(function ()
{
	//=======================
	//===== METHODS =========
	//=======================
	if (typeof Duik.setup !== 'object')
	{
		Duik.setup = {};
		//Duik.setup.presetEffects String
		{
			Duik.setup.presetEffects = "<!-- BEGIN DUIK PSEUDO EFFECTS v15.0013 -->\r\n" + 
				"<Effect matchname='DUIK_One_Layer_IK' name='$$$/AE/Preset/1ik=DUIK_One_Layer_IK'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikWeight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" + 
				"    <Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='true'/>\r\n" + 
				"    <Angle name='$$$/AE/Preset/DuikFK=FK' default='0'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Two_Layer_IK' name='$$$/AE/Preset/2ik=DUIK_Two_Layer_IK'>\r\n" + 
				"    <Checkbox name='$$$/AE/Preset/DuikClockwise=Clockwise' default='false'/>\r\n" + 
				"    <Group name='$$$/AE/Preset/DuikFK=FK'>\r\n" + 
				"        <Checkbox name='$$$/AE/Preset/DuikDisableIK=Disable IK' default='false'/>\r\n" + 
				"        <Angle name='$$$/AE/Preset/DuikUpperFK=Upper FK' default='0'/>\r\n" + 
				"        <Angle name='$$$/AE/Preset/DuikLowerFK=Lower FK' default='0'/>\r\n" + 
				"    </Group>\r\n" + 
				"    <Group name='$$$/AE/Preset/Stretch=Stretch'>\r\n" + 
				"        <Checkbox name='$$$/AE/Preset/DuikAuto-Stretch=Auto-Stretch' default='true'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikStretch=Stretch' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1'/>\r\n" + 
				"    </Group>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Three_Layer_IK' name='$$$/AE/Preset/2ik=DUIK_Three_Layer_IK'>\r\n" + 
				"    <Checkbox name='$$$/AE/Preset/DuikClockwise=Clockwise' default='false'/>\r\n" + 
				"    <Group name='$$$/AE/Preset/DuikFK=FK'>\r\n" + 
				"        <Checkbox name='$$$/AE/Preset/DuikDisableIK=Disable IK' default='false'/>\r\n" + 
				"        <Angle name='$$$/AE/Preset/DuikUpperFK=Upper FK' default='0'/>\r\n" + 
				"        <Angle name='$$$/AE/Preset/DuikMiddleFK=Middle FK' default='0'/>\r\n" + 
				"        <Angle name='$$$/AE/Preset/DuikLowerFK=Lower FK' default='0'/>\r\n" + 
				"    </Group>\r\n" + 
				"    <Group name='$$$/AE/Preset/Stretch=Stretch'>\r\n" + 
				"        <Checkbox name='$$$/AE/Preset/DuikAuto-Stretch=Auto-Stretch' default='true'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikStretch=Stretch' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1'/>\r\n" + 
				"    </Group>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_3D_Wiggle' name='$$$/AE/Preset/3dwiggle=DUIK_3D_Wiggle'>\r\n" + 
				"    <Group name='$$$/AE/Preset/DuikAmplitudes=Amplitudes'>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikXAmp=X Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikYAmp=Y Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikZAmp=Z Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 
				"    </Group>\r\n" + 
				"    <Group name='$$$/AE/Preset/DuikFrequencies=Frequencies'>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikXFrequ=X Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikYFreq=Y Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikZFreq=Z Freq' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"    </Group>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_2D_Wiggle' name='$$$/AE/Preset/2dwiggle=DUIK_2D_Wiggle'>\r\n" + 
				"    <Group name='$$$/AE/Preset/DuikAmplitudes=Amplitudes'>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikXAmp=X Amp.' default='0' valid_min='0' valid_max='10000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikYAmp=Y Amp.' default='0' valid_min='0' valid_max='10000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" + 
				"    </Group>\r\n" + 
				"    <Group name='$$$/AE/Preset/DuikFrequencies=Frequencies'>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikXFreq=X Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikYFreq=Y Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"    </Group>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_1D_Wiggle' name='$$$/AE/Preset/1dwiggle=DUIK_1D_Wiggle'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikAmplitude=Amplitude' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikFrequency=Frequency' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Exposure' name='$$$/AE/Preset/exposure=DUIK_Exposure'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikExposure=Exposure (frames)' default='1' valid_min='1' valid_max='1000' slider_min='1' slider_max='30' precision='1'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_RotMorph' name='$$$/AE/Preset/rotmorph=DUIK_RotMorph'>\r\n" + 
				"    <Layer name='$$$/AE/Preset/DuikReferenceLayer=Reference Layer' default_self='true'/>\r\n" + 
				"    <Angle name='$$$/AE/Preset/DuikMin.Angle=Min. Angle' default='0'/>\r\n" + 
				"    <Angle name='$$$/AE/Preset/DuikMax.Angle=Max. Angle' default='0'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Swing' name='$$$/AE/Preset/swing=DUIK_Swing'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikAmplitude=Amplitude' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikFrequency=Frequency' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='50' precision='1'/>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikOffset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='1'/>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikDamping=Damping' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Wheel' name='$$$/AE/Preset/wheel=DUIK_Wheel'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikRadius=Radius' default='100' valid_min='1' valid_max='10000' slider_min='1' slider_max='1000' precision='1'/>\r\n" + 
				"    <Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='false'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_LensFlare' name='$$$/AE/Preset/lensflare=DUIK_LensFlare'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikIntensity=Intensity' default='100' valid_min='0' valid_max='1000' slider_min='0' slider_max='200' precision='1' DISPLAY_PERCENT='true'/>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikScale=Scale' default='100' valid_min='0' valid_max='1000' slider_min='0' slider_max='200' precision='1' DISPLAY_PERCENT='true'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_LensFlareDistance' name='$$$/AE/Preset/lensflaredistance=DUIK_LensFlareDistance'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikDistance=Distance' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_DistanceLink' name='$$$/AE/Preset/distancelink=DUIK_DistanceLink'>\r\n" + 
				"    <Group name='$$$/AE/Preset/DuikRange=Range'>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikMinimumDistance=Minimum Distance' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 
				"        <Slider name='$$$/AE/Preset/DuikMaximumDistance=Maximum Distance' default='500' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" + 
				"    </Group>\r\n" + 
				"    <Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='false'/>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikFalloff=Falloff' default='10' valid_min='0' valid_max='1000' slider_min='0' slider_max='100' precision='1'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Spring' name='$$$/AE/Preset/spring=DUIK_Spring'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikElasticity=Elasticity' default='10' valid_min='0' valid_max='100' slider_min='0' slider_max='25' precision='1'/>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikDamping=Damping' default='5' valid_min='0' valid_max='100' slider_min='0' slider_max='20' precision='1'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Spring_Bounce' name='$$$/AE/Preset/springbounce=DUIK_Spring_Bounce'>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikElasticity=Elasticity' default='10' valid_min='0' valid_max='100' slider_min='0' slider_max='25' precision='1'/>\r\n" + 
				"    <Slider name='$$$/AE/Preset/DuikDamping=Damping' default='5' valid_min='0' valid_max='100' slider_min='0' slider_max='20' precision='1'/>\r\n" + 
				"    <Checkbox name='$$$/AE/Preset/DuikBounce=Bounce' default='false'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Paint_Rig' name='$$$/AE/Preset/DUIK_Paint_Rig=DUIK_Paint_Rig'>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Start=Start' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/End=End' default='100' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Diameter=Diameter' default='0' valid_min='-1000' valid_max='10000' slider_min='-100' slider_max='100' precision='0'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Blink_1D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_1D'>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Offvalue=Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Blink_2D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_2D'>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/xOffvalue=X Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/yOffvalue=Y Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" + 
				"</Effect>\r\n" + 
				"<Effect matchname='DUIK_Blink_3D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_3D'>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/xOffvalue=X Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/yOffvalue=Y Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" + 
				"	<Slider name='$$$/AE/Preset/zOffvalue=Z Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" + 
				"</Effect>\r\n" + 
				"<!-- END DUIK PSEUDO EFFECTS -->\r\n";
		}
		// INSTALL PSEUDO EFFECTS - Duik.setup.installCustomEffects();
		Duik.setup.installPseudoEffects = function ()
		{
			//-------------------------------------------------------------
			//------ Edit presetEffects.xml to add Duik Effects -----------
			//-------------------------------------------------------------
			if (Duik.allowedToWriteFiles && Duik.presetEffectsInstalledVersion < Duik.versionNumber)
			{
				var appPath = Folder.appPackage.fsName;
				var presetEffectsFile = new File(appPath + "\\PresetEffects.xml");
				if ($.os.toLowerCase().indexOf("mac") >= 0) presetEffectsFile = new File(appPath + "/Contents/Resources/PresetEffects.xml");
				if (presetEffectsFile.exists)
				{
					presetEffectsFile.open("r","TEXT");
					var presetEffectsString = presetEffectsFile.read();
					presetEffectsFile.close();
					//update
					var startIndex = presetEffectsString.indexOf("<!-- BEGIN DUIK PSEUDO EFFECTS v");
					var endIndex = presetEffectsString.indexOf("<!-- END DUIK PSEUDO EFFECTS -->") + 32;
					if (startIndex >= 0)
					{
						var stringToRemove = presetEffectsString.substring(startIndex,endIndex);
						presetEffectsString = presetEffectsString.replace(stringToRemove,Duik.setup.presetEffects);
					}
					else
					{
						presetEffectsString = presetEffectsString.replace("</Effects>",Duik.setup.presetEffects + "\r\n</Effects>");
					}
					//gets write access
					if ($.os.toLowerCase().indexOf("mac") >= 0)
					{
						var cmd = "chmod u+rw  " + "\"" + appPath + "/PresetEffects.xml\"";
						system.callSystem(cmd);
					}
					else
					{
						var cmd = "cmd /c attrib -r /S /D \"" + appPath + "\"";
						system.callSystem(cmd);
						cmd = "cmd /c attrib -r /S /D \"" + appPath + "\\PresetEffects.xml\"";
						system.callSystem(cmd);
					}
					//backup file
					presetEffectsFile.copy(presetEffectsFile.fullName + ".bak");
					//write the new file
					var isReadOnly = presetEffectsFile.readonly;
					presetEffectsFile.readonly = false;
					presetEffectsFile.open("w","TEXT");
					presetEffectsFile.write(presetEffectsString);
					presetEffectsFile.close();
					presetEffectsFile.readonly = isReadOnly;
				}
				Duik.setup.checkPresetEffectsVersion();
			}
		}
		Duik.setup.checkPresetEffectsVersion = function ()
		{
			var presetEffectsFile = new File(Folder.appPackage.absoluteURI + "/PresetEffects.xml");
			if ($.os.toLowerCase().indexOf("mac") >= 0) presetEffectsFile = new File(Folder.appPackage.absoluteURI + "/Contents/Resources/PresetEffects.xml");
			Duik.presetEffectsInstalledVersion = 0;
			if (presetEffectsFile.exists)
			{
				presetEffectsFile.open("r","TEXT");
				var presetEffectsString = presetEffectsFile.read();
				presetEffectsFile.close();
				//find version
				var startIndex = presetEffectsString.indexOf("<!-- BEGIN DUIK PSEUDO EFFECTS v");
				if (startIndex >= 0)
				{
					startIndex += 32 ;
					Duik.presetEffectsInstalledVersion = parseFloat(presetEffectsString.substr(startIndex,7));
				}
			}
		}
	
	}
	
	//-----------------------------------------------------------------
	//--------- Check if presetEffects.xml is up-to-date --------------
	//-----------------------------------------------------------------
	Duik.setup.checkPresetEffectsVersion();
	if (Duik.presetEffectsInstalledVersion == Duik.versionNumber)
	{
		Duik.usePresets = false;
	}

	//-----------------------------------------------------------------
	//--------- Check if scripts are allowed to write files -----------
	//-----------------------------------------------------------------
	Duik.allowedToWriteFiles = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;
	
	//-----------------------------------------------------------------
	//------------------------------ INSTALL --------------------------
	//-----------------------------------------------------------------
	if (Duik.usePresets)
	{
		Duik.setup.installPseudoEffects();
	}
}());

/////////////////////////////
// MAIN
/////////////////////////////
(function ()
{	
	//================================
	//========= UI Strings ===========
	//================================
	
	/* UI Strings
		class Duik.uiStrings
		containing all needed uiString (localizable strings)
	*/
	if (typeof Duik.uiStrings !== 'object')
	{
		Duik.uiStrings = {};
		
		Duik.uiStrings.ik = "IK";
		Duik.uiStrings.wiggle = "Wiggle";
		Duik.uiStrings.exposure = "Exposure";
		Duik.uiStrings.rotMorph = "Rotation Morph";
		Duik.uiStrings.swing = "Swing";
		Duik.uiStrings.wheel = "Wheel";
		Duik.uiStrings.lensFlare = "Lens Flare";
		Duik.uiStrings.distanceLink = "Distance Link";
		Duik.uiStrings.spring = "Spring";
		Duik.uiStrings.paintRig = "Paint Rig";
		Duik.uiStrings.blink = "Blink";
		Duik.uiStrings.scale = "Scale";
		Duik.uiStrings.flip = "Flip";
		Duik.uiStrings.moveAway = "Distance from parent";
	}

	//================================
	//========= SETTINGS =============
	//================================
	
	/* Duik Settings
	
	*/
	if (typeof Duik.settings !== 'object')
	{
		Duik.settings = {};
		if (! app.settings.haveSetting("duik", "boneType")){app.settings.saveSetting("duik","boneType",Duik.layerTypes.SOLID);}
		if (! app.settings.haveSetting("duik", "controllerType")){app.settings.saveSetting("duik","controllerType",Duik.layerTypes.VECTOR);}
		if (! app.settings.haveSetting("duik", "boneSize")){app.settings.saveSetting("duik","boneSize",20);}
		if (! app.settings.haveSetting("duik", "ctrlSize")){app.settings.saveSetting("duik","ctrlSize",100);}
		if (! app.settings.haveSetting("duik", "ctrlSizeAuto")){app.settings.saveSetting("duik","ctrlSizeAuto",true);}
		if (! app.settings.haveSetting("duik", "boneSizeAuto")){app.settings.saveSetting("duik","boneSizeAuto",true);}
		if (! app.settings.haveSetting("duik", "boneSizeAutoValue")){app.settings.saveSetting("duik","boneSizeAutoValue",Duik.sizes.MEDIUM);}
		if (! app.settings.haveSetting("duik", "ctrlSizeAutoValue")){app.settings.saveSetting("duik","ctrlSizeAutoValue",Duik.sizes.MEDIUM);}
		if (! app.settings.haveSetting("duik", "boneColor")){app.settings.saveSetting("duik","boneColor","FF0000");}
		if (! app.settings.haveSetting("duik", "morpherKeyframes")){app.settings.saveSetting("duik","morpherKeyframes",true);}
		if (! app.settings.haveSetting("duik", "getLayersMethod")){app.settings.saveSetting("duik","getLayersMethod",Duik.getLayers.NAME);}
		if (! app.settings.haveSetting("duik", "boneOnTopOfLayer")){app.settings.saveSetting("duik","boneOnTopOfLayer",true);}
		
		Duik.settings.save = function ()
		{
			app.settings.saveSetting("duik","boneType",Duik.settings.boneType);
			app.settings.saveSetting("duik","controllerType",Duik.settings.controllerType);
			app.settings.saveSetting("duik","boneSize",Duik.settings.boneSize);
			app.settings.saveSetting("duik","ctrlSize",Duik.settings.controllerSize);
			app.settings.saveSetting("duik","ctrlSizeAuto",Duik.settings.controllerSizeAuto);
			app.settings.saveSetting("duik","boneSizeAuto",Duik.settings.boneSizeAuto);
			app.settings.saveSetting("duik","boneSizeAutoValue",Duik.settings.boneSizeHint);
			app.settings.saveSetting("duik","ctrlSizeAutoValue",Duik.settings.controllerSizeHint);
			app.settings.saveSetting("duik","boneColor",Duik.settings.boneColor);
			app.settings.saveSetting("duik","morpherKey",Duik.settings.morpherCreatesKeyframes);
			app.settings.saveSetting("duik","getLayersMethod",Duik.settings.getLayersMethod);
			app.settings.saveSetting("duik","boneOnTopOfLayer",Duik.settings.boneOnTopOfLayer);
		}
		
		Duik.settings.load = function ()
		{
			Duik.settings.controllerSize = eval(app.settings.getSetting("duik","ctrlSize"));
			Duik.settings.controllerType = eval(app.settings.getSetting("duik","controllerType"));
			Duik.settings.controllerSizeAuto = eval(app.settings.getSetting("duik","ctrlSizeAuto"));
			Duik.settings.controllerSizeHint = eval(app.settings.getSetting("duik","ctrlSizeAutoValue"));
			Duik.settings.boneType = eval(app.settings.getSetting("duik","boneType"));
			Duik.settings.boneSize = eval(app.settings.getSetting("duik","boneSize"));
			Duik.settings.boneSizeAuto = eval(app.settings.getSetting("duik","boneSizeAuto"));
			Duik.settings.boneSizeHint = eval(app.settings.getSetting("duik","boneSizeAutoValue"));
			Duik.settings.boneColor = app.settings.getSetting("duik","boneColor");
			Duik.settings.morpherCreatesKeyframes = eval(app.settings.getSetting("duik","morpherKeyframes"));
			Duik.settings.getLayersMethod = eval(app.settings.getSetting("duik","getLayersMethod"));
			Duik.settings.boneOnTopOfLayer = eval(app.settings.getSetting("duik","boneOnTopOfLayer"));
		}
		
		Duik.settings.restoreDefaults = function ()
		{
			Duik.settings.controllerSize = 100;
			Duik.settings.controllerType = Duik.layerTypes.VECTOR;
			Duik.settings.controllerSizeAuto = true;
			Duik.settings.controllerSizeHint = Duik.sizes.MEDIUM;
			Duik.settings.boneType = Duik.layerTypes.SOLID;
			Duik.settings.boneSize = 20;
			Duik.settings.boneSizeAuto = true;
			Duik.settings.boneSizeHint = Duik.sizes.MEDIUM;
			Duik.settings.boneColor = "FF0000";
			Duik.settings.morpherCreatesKeyframes = true;
			Duik.settings.getLayersMethod = Duik.getLayers.NAME;
			Duik.settings.boneOnTopOfLayer = true;
			
			Duik.settings.save();
		}
		
		Duik.settings.load();
	}
	
	//================================
	//========== JS TOOLS ============
	//================================
	
	if (typeof Duik.javascript !== 'object')
	{
		Duik.javascript = {};
		// ESCAPE REGEXP
		if (typeof Duik.javascript.escapeRegExp !== 'function')
		{
			Duik.javascript.escapeRegExp = function (string)
			{
				return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
			}
		}
		// ESCAPE REGEXP
		if (typeof Duik.javascript.replaceAll !== 'function')
		{
			Duik.javascript.replaceAll = function (string, find, replace, caseSensitive)
			{
				if (caseSensitive == undefined) caseSensitive = true;
				var re = new RegExp(Duik.javascript.escapeRegExp(find),caseSensitive ? 'g' : 'gi');
				return string.replace(re, replace);
			}
		}
	}
	
	//================================
	//========== UTILS ===============
	//================================
	
	if (typeof Duik.utils !== 'object')
	{
		Duik.utils = {};
		// RIG PROPERTY - Duik.utils.rigProperty(layer,prop,effectMatchName)
		if (typeof Duik.utils.rigProperty !== 'function')
		{
			Duik.utils.rigProperty = function (layer,prop,effectMatchName)
			{
				//if prop is an effect, need a way to recover it
				var propDescription = Duik.utils.prepareProperty(prop);
				if (!propDescription.canSetExpression) return null;
				//pseudo effect
				var effect = null;
				if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(layer,effectMatchName);
				else effect = layer.effect.addProperty(effectMatchName);
				if (propDescription.isEffect){ prop = layer.effect(propDescription.parentName)(propDescription.index); }
				return [effect,prop];
			}
		}
		// PREPARE PROPERTY - Duik.utils.prepareProperty(prop,isFX,ind,prof,parentName,dimensions)
		if (typeof Duik.utils.prepareProperty !== 'function')
		{
			Duik.utils.prepareProperty = function (prop)
			{
				var propDescr = new PropertyDescription();
				propDescr.canSetExpression = prop.canSetExpression;
				propDescr.isEffect = prop.parentProperty.isEffect;
				propDescr.index = prop.propertyIndex;
				propDescr.depth = prop.propertyDepth;
				propDescr.parentName = prop.parentProperty.name;
				propDescr.dimensions = Duik.utils.getPropertyDimensions(prop);
				
				return propDescr;
			}
		}
		// GET DIMENSIONS - Duik.utils.getPropertyDimensions(property)
		if (typeof Duik.utils.getPropertyDimensions !== 'function')
		{
			Duik.utils.getPropertyDimensions = function (prop)
			{
				var dimensions = 1;
				if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
				{
					//if this is a position and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......
					if (!prop.parentProperty.isEffect && prop.name.toLowerCase() == "position" && !app.project.activeItem.selectedLayers[0].threeDLayer)
					{
						dimensions = 2;
					}
					else
					{
						dimensions = 3;
					}
				}
				else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
				{
					dimensions = 2;
				}
				return dimensions;
			}
		}
		// GET LENGTH - Duik.utils.getLength(value1,value2)
		if (typeof Duik.utils.getLength !== 'function')
		{
			Duik.utils.getLength = function (value1,value2)
			{
				if (typeof value1 !== typeof value2)
				{
					return null;
				}
				if (value1.length > 0)
				{
					var result = 0;
					for (var dim = 0;dim<value1.length;dim++)
					{
						result += (value1[dim]-value2[dim])*(value1[dim]-value2[dim]);
					}
					result = Math.sqrt(result);
					return result;
				}
				else return Math.abs(value1 - value2) ;
			}
		}
		// GET AVERAGE SPEED - Duik.utils.getAverageSpeed(layer,property)
		if (typeof Duik.utils.getAverageSpeed !== 'function')
		{
			Duik.utils.getAverageSpeed = function (layer,prop)
			{
				if (prop.numKeys < 1) return 0;
				//for each frame of the comp
				var frames = layer.containingComp.duration / layer.containingComp.frameDuration ;
				var lastTime = prop.keyTime(prop.numKeys);
				var firstTime = prop.keyTime(1);
				var lastFrame = lastTime/layer.containingComp.frameDuration ;
				var firstFrame = firstTime/layer.containingComp.frameDuration ;
				if (lastFrame > frames) lastFrames = frames;
				if (firstFrame < 1) firstFrame = 1;
				var sum = 0;
				for (var frame = firstFrame ; frame < lastFrame ; frame++)
				{
					var time = frame*app.project.activeItem.frameDuration;
					sum += Duik.utils.getLength(prop.valueAtTime(time,false),prop.valueAtTime(time-layer.containingComp.frameDuration,false));
				}
				return sum/(lastFrame-firstFrame);
			}
		}
		// GET AVERAGE SPEEDS - Duik.utils.getAverageSpeeds(layers)
		if (typeof Duik.utils.getAverageSpeeds !== 'function')
		{
			Duik.utils.getAverageSpeeds = function (layers)
			{
				var averageSpeed = 0;
				var count = 0;
				for (var i = 0 ; i < layers.length ; i++)
				{
					var layer = Duik.utils.getItem(layers,i);
					for (var j = 0 ; j < layer.selectedProperties.length ; j++)
					{
						var prop = layer.selectedProperties[j];
						if (prop.propertyType != PropertyType.PROPERTY) continue;
						if (prop.numKeys < 1) continue;
						var newSpeed = Duik.utils.getAverageSpeed(layer,prop);
						if (newSpeed > 0)
						{
							averageSpeed += newSpeed;
							count++;
						}
					}
				}
				averageSpeed = averageSpeed/count;
				return averageSpeed;
			}
		}
		// ADD PSEUDO EFFECT - Duik.utils.addPseudoEffect(layer,pseudoEffectName)
		if (typeof Duik.utils.addPseudoEffect !== 'function')
		{
			Duik.utils.addPseudoEffect = function (layer,preset)
			{
				//applyPreset is bugged and always applies presets on selected layers instead of the given one,
				//first deselect everything and select the wanted layer
				var selection = app.project.activeItem.selectedLayers;
				Duik.utils.deselectLayers();
				layer.selected = true;

				var presetFile = new File(Duik.presetPath + preset + ".ffx");
				layer.applyPreset(presetFile);
				
				var newEffect = null;
				
				for (var fx = 1;fx <= layer("Effects").numProperties;fx++)
				{
					if (layer.effect(fx).name == preset )
					{
						newEffect = layer.effect(fx);
						break;
					}
				}
				
				//restore selection...
				layer.selected = false;
				for (var selectedLayerIndex=0;selectedLayerIndex<selection.length;selectedLayerIndex++)
				{
					selection[selectedLayerIndex].selected = true;
				}
				
				return newEffect;
			}
		}
		// GET ALL PUPPET PINS FROM A LAYER - Duik.utils.getPuppetPins(prop)
		if (typeof Duik.utils.getPuppetPins !== 'function')
		{
			Duik.utils.getPuppetPins = function (prop) {
				var coins = [];
				if (prop != null)
				{
					if (prop.matchName == "ADBE FreePin3 PosPin Atom")
					{
						coins.push(prop);
					}
					else if (prop.numProperties > 0)
					{
						//contournement de bug...
						//d'abord recup les propriétés dans un tableau avant de les parcourir
						//sinon l'incrément fonctionne pas dans la boucle, allez savoir pourquoi

						var proprietes = [];
						for (var p=1;p<=prop.numProperties;p++)
						{
							proprietes.push(prop.property(p));
						}

						for (var pi = 0;pi < proprietes.length;pi++)
						{
							var newCoins = Duik.utils.getPuppetPins(proprietes[pi]);
							if (newCoins.length > 0)
							{
								coins = coins.concat(newCoins);
							}
						}
					}
				}
				
				return coins;
			}
		}
		// MEASURE DISTANCE BETWEEN TWO LAYERS - Duik.utils.getDistance(layer1,layer2)
		if (typeof Duik.utils.getDistance !== 'function')
		{
			Duik.utils.getDistance = function (layer1,layer2)
			{
				//parents
				var layer1Parent = layer1.parent;
				var layer2Parent = layer2.parent;	
				//unlink
				layer1.parent = null;
				layer2.parent = null;
				var O = layer1.transform.position.value;
				var A = layer2.transform.position.value;
				var OA = Duik.utils.getLength(O,A);
				//re-link
				layer1.parent = layer1Parent;
				layer2.parent = layer2Parent;
				return Math.round(OA);
			}
		}
		// DESELECT ALL LAYERS - Duik.utils.deselectLayers()
		if (typeof Duik.utils.deselectLayers !== 'function')
		{
			Duik.utils.deselectLayers = function ()
			{
				var sel = app.project.activeItem.selectedLayers;
				for (var selectedLayerIndex=0;selectedLayerIndex<sel.length;selectedLayerIndex++)
				{
					sel[selectedLayerIndex].selected = false;
				}
			}
		}
		// CHECK NAMES - Duik.utils.checkNames(comp)
		if (typeof Duik.utils.checkNames !== 'function')
		{
			Duik.utils.checkNames = function (comp)
			{
				if (comp == undefined) comp = app.project.activeItem;
				if (comp == undefined) return false;
				
				var layers = comp.layers;
				var numLayers = comp.numLayers;
				var renamed = false;
				
				var counts = {};
				// first pass, assign the counts
				for (var layerI = 1; layerI <= numLayers; layerI++)
				{
					var layer = layers[layerI];
					var name = layer.name;

					if (counts[name] == undefined)
					{
						counts[name] = 1;
					}
					else
					{
						counts[name]++;
					}

					if (counts[name] > 1)
					{
						var l = layer.locked;
						layer.locked = false;
						layer.name = name + " " + counts[name];
						layer.locked = l;
						renamed = true;
					}
				}
				
				return renamed;
			}
		}
		// GET ITEM from Array or Collection
		if (typeof Duik.utils.getItem !== 'function')
		{
			Duik.utils.getItem = function (items,itemIndex)
			{
				if (items instanceof ItemCollection || items instanceof LayerCollection || items instanceof OMCollection || items instanceof RQItemCollection) return items[itemIndex+1];
				else return items[itemIndex];
			}
		}
		// GET KEY at index from property
		//return KeyFrame
		if (typeof Duik.utils.getKey !== 'function')
		{
			Duik.utils.getKey = function (prop,keyIndex)
			{
				if (Math.abs(keyIndex) > prop.numKeys || keyIndex == 0)
				{
					return null;
				}
				if (keyIndex < 0)
				{
					keyIndex = prop.numKeys - keyIndex + 1;
				}
					
				var key = new KeyFrame();
				key.time = prop.keyTime(keyIndex);
				key.value = prop.keyValue(keyIndex);
				key.inInterpolationType = prop.keyInInterpolationType(keyIndex);
				key.outInterpolationType = prop.keyOutInterpolationType(keyIndex);
				if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL )
				{
					key.spatial = true;
					key.spatialProperties.inTangent = prop.keyInSpatialTangent(keyIndex);
					key.spatialProperties.outTangent  = prop.keyOutSpatialTangent(keyIndex);
					key.spatialProperties.continuous = prop.keySpatialContinuous(keyIndex);
					key.spatialProperties.autoBezier = prop.keySpatialAutoBezier(keyIndex);
					key.spatialProperties.roving = prop.keyRoving(keyIndex);
				}
				key.inEase = prop.keyInTemporalEase(keyIndex);
				key.outEase = prop.keyOutTemporalEase(keyIndex);
				key.continuous = prop.keyTemporalContinuous(keyIndex);
				key.autoBezier = prop.keyTemporalAutoBezier(keyIndex);
	
				return key;
			}
		}
		// GET PROPERTY ANIMS between startTime and Endtime (if propertyGroup, recursive)
		//return Array of PropertyAnim
		if (typeof Duik.utils.getPropertyAnims !== 'function')
		{
			Duik.utils.getPropertyAnims = function (prop,selectedKeysOnly,startTime,endTime)
			{
				var anims = [];
				if (prop.propertyType == PropertyType.PROPERTY)
				{
					if (prop.PropertyValueType != PropertyValueType.NO_VALUE)
					{
						var anim = Duik.utils.getPropertyAnim(prop,selectedKeysOnly,startTime,endTime);
						if (anim != null)
						{
							if (selectedKeysOnly && anim.keys.length >= 1) anims.push(anim);
							else if (!selectedKeysOnly) anims.push(anim);
						}
					}
				}
				else if (prop.numProperties > 0)
				{
					for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
					{
						var newAnims = Duik.utils.getPropertyAnims(prop.property(propIndex),selectedKeysOnly,startTime,endTime);
						if (newAnims.length > 0)
						{
							anims = anims.concat(newAnims);
						}
					}
				}
				return anims;
			}
		}
		// GET PROPERTY ANIM between startTime and Endtime (not for PropertyGroup)
		//return PropertyAnim
		if (typeof Duik.utils.getPropertyAnim !== 'function')
		{
			Duik.utils.getPropertyAnim = function (prop,selectedKeysOnly,startTime,endTime)
			{
				if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;
				
				var anim = new PropertyAnim();
				anim.name = prop.name;
				
				anim.startValue = prop.valueAtTime(startTime,true);
				
				if (prop.elided) return anim;
				
				if (prop.isTimeVarying)
				{
					if (selectedKeysOnly)
					{
						for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
						{
							var key = Duik.utils.getKey(prop,prop.selectedKeys[keyIndex]);
							if (key.time >= startTime && key.time <= endTime)
							{
								key.time = key.time - startTime;
								anim.keys.push(key);
							}
						}
					}
					else if (prop.numKeys > 0)
					{
						for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
						{
							var time = prop.keyTime(keyIndex);
							if (time >= startTime && time <= endTime)
							{
								var key = Duik.utils.getKey(prop,keyIndex);
								key.time = key.time - startTime;
								anim.keys.push(key);
							}
						}
					}
				}
				return anim;
			}
		}
		// SET PROPERTY ANIM
		//return boolean
		if (typeof Duik.utils.setPropertyAnim !== 'function')
		{
			Duik.utils.setPropertyAnim = function (prop,propAnim,startTime)
			{					
				var name = propAnim.name;
				//trouver la propriété portant ce nom dans la prop demandée
				if (prop.propertyType == PropertyType.PROPERTY && prop.name == name && !prop.elided && prop.canVaryOverTime)
				{
					//if there are keys, paste them
					if (propAnim.keys.length > 0)
					{
						for (var iclef = 0; iclef < propAnim.keys.length;iclef++)
						{
							Duik.utils.addKey(prop,propAnim.keys[iclef],startTime);
						}
					}
					else //set the start value
					{
						try { prop.setValue(propAnim.startValue); } catch (err) {};
					}
					return true;
				}
				else if (prop.numProperties != undefined)
				{
					if (prop.numProperties > 0)
					{
						for (var pi = 1;pi <= prop.numProperties;pi++)
						{
							if (Duik.utils.setPropertyAnim(prop.property(pi),propAnim,startTime)) return true;
						}
					}
				}
				return false;
			}
		}
		// ADD KEY
		//return void
		if (typeof Duik.utils.addKey !== 'function')
		{
			Duik.utils.addKey = function (prop,key,startTime)
			{	
				if (prop.elided) return;
				if (startTime == undefined) startTime = 0;
				var time = startTime+key.time;
				try //au cas où on est sur du XPosition alors que le calque est 2D, par exemple
				{
					prop.setValueAtTime(time,key.value); 
					//get the index of the created key
					var index = prop.nearestKeyIndex(time);
					if (key.spatial && (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL))
					{
						prop.setSpatialContinuousAtKey(index,key.spatialProperties.continuous);
						prop.setSpatialAutoBezierAtKey(index,key.spatialProperties.autoBezier);
						prop.setRovingAtKey(index,key.spatialProperties.roving);
						prop.setSpatialTangentsAtKey(index,key.spatialProperties.inTangent,key.spatialProperties.outTangent);
					}
                       try {
                            prop.setTemporalEaseAtKey(index,key.inEase,key.outEase);
                            prop.setTemporalContinuousAtKey(index,key.continuous);
                            prop.setTemporalAutoBezierAtKey(index,key.autoBezier);
                            prop.setInterpolationTypeAtKey(index,key.inInterpolationType,key.outInterpolationType);
                       }
                   catch(err){}
					
				}
				catch (err)
				{}
			}
		}
		// GET FIRST KEYTIME in PropertyGroup (recursive)
		//return int
		if (typeof Duik.utils.getFirstKeyTime !== 'function')
		{
			Duik.utils.getFirstKeyTime = function (prop)
			{
				var firstKeyTime = 86339;
				
				if (prop.propertyType == PropertyType.PROPERTY)
				{
					if (prop.selectedKeys.length > 0)
					{
						for (var key = 0;key<prop.selectedKeys.length;key++)
						{
							if (prop.keyTime(prop.selectedKeys[key]) < firstKeyTime)
							{
								firstKeyTime = prop.keyTime(prop.selectedKeys[key]);
							}
						}
					}
				}
				else if (prop.numProperties > 0)
				{
					for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
					{
						testKeyTime = Duik.utils.getFirstKeyTime(prop.property(propIndex));
						if (testKeyTime < firstKeyTime) firstKeyTime = testKeyTime;
					}
				}

				return firstKeyTime;
			}
		}
		// ARE THERE SELECTED KEYS in PropertyGroup
		//return boolean
		if (typeof Duik.utils.hasSelectedKeys !== 'function')
		{
			Duik.utils.hasSelectedKeys = function (prop)
			{
				var yes = false;
				
				if (prop.propertyType == PropertyType.PROPERTY)
				{
					if (prop.selectedKeys.length >0)
					{
						yes = true;
					}
				}
				else if (prop.numProperties > 0)
				{
					for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
					{
						yes = Duik.utils.hasSelectedKeys(prop.property(propIndex));
						if (yes) break;
					}
				}
				return yes;
			}
		}
		// CONVERT COLLECTION TO Array
		//return array
		if (typeof Duik.utils.convertCollectionToArray !== 'function')
		{
			Duik.utils.convertCollectionToArray = function (collection)
			{
				var arr = [];
				if (collection instanceof ItemCollection || collection instanceof LayerCollection || collection instanceof OMCollection || collection instanceof RQItemCollection)
				{
					for (var i = 1;i<=collection.length;i++)
					{
						arr.push(collection[i]);
					}
				}
				else 
				{
					arr = collection;
				}
				return arr;
			}
		}
		// PREP LAYERS FOR IK
		//return IKRig
		if (typeof Duik.utils.prepIK !== 'function')
		{
			Duik.utils.prepIK = function (layrs)
			{
				rig = new IKRig();
				if (layrs.length < 2) return rig;
				if (layrs.length > 5) return rig;
				
				var layers = Duik.utils.convertCollectionToArray(layrs);
				
				
				if (layers.length == 2)
				{
					rig.type = 1;
					rig.layer1 = layers[0];
					rig.controller = layers[1];
				}
				else
				{
					//find controller
					var found = false;
					var ctrl = null;
					for (var i = 0;i<layers.length;i++)
					{
						var l = layers[i];
						var ok = true;
						for (var j = 0;j<layers.length;j++)
						{
							if (i == j) continue;
							var ll = layers[j];
							if (l.parent != null)
							{
								if (l.parent == ll)
								{
									ok = false;
									break;
								}
							}
							if (ll.parent != null)
							{
								if (ll.parent == l)
								{
									ok = false;
									break;
								}
							}
						}
						if (ok && found)
						{
							ctrl = null;
							break;
						}
						else if (ok)
						{
							found = true;
							ctrl = l;
						}
					}
					
					var valid = true;
					if (ctrl == null) valid = false;
					var sortedLayers = [];
					if (valid)
					{
						//sort layers
						//find the one which has no parents, will be the root (first)
						var first = null;
						for (var i = 0;i<layers.length;i++)
						{
							var l = layers[i];
							if (l == ctrl) continue;
							var ok = true;
							//search if l has a parent
							for (var j = 0;j<layers.length;j++)
							{
								if (l.parent == layers[j])
								{
									ok = false;
									break;
								}
							}
							//if a parent is found, skip
							if (!ok) continue;
							//if we haven't found it already
							if (first == null)
							{
								first = l;
							}
							//else break
							else
							{
								first = null;
								break;
							}
						}
						
						if (first != null)
						{
							sortedLayers.push(first);
							//find children
							while (sortedLayers.length < layers.length-1)
							{
								var found = false;
								var ok = true;
								for (var i = 0;i<layers.length;i++)
								{
									var l = layers[i];
									if (l == ctrl) continue;
									if (l.parent != null)
									{
										if (l.parent == sortedLayers[sortedLayers.length-1])
										{
											if (found)
											{
												ok = false;
												break;
											}
											else
											{
												sortedLayers.push(l);
											}
										}
									}
								}
								if (!ok) break;
							}
						}
					}
					if (sortedLayers.length != layers.length-1) valid = false;
					
					if (layers.length == 3)
					{
						if (valid)
						{
							rig.layer1 = sortedLayers[0];
							rig.layer2 = sortedLayers[1];
							rig.controller = ctrl;
						}
						else
						{
							rig.layer1 = layers[1];
							rig.layer2 = layers[0];
							rig.controller = layers[2];
						}
						//2 layer or 1+goal ?
						if (Duik.utils.getDistance(rig.layer2,rig.controller) < 10)
						{
							rig.goal = rig.layer2;
							rig.layer2 = null;
							rig.type = 1;
						}
						else
						{
							rig.type = 2;
						}
					}
					else if (layers.length == 4)
					{
						if (valid)
						{
							rig.layer1 = sortedLayers[0];
							rig.layer2 = sortedLayers[1];
							rig.layer3 = sortedLayers[2];
							rig.controller = ctrl;
						}
						else
						{
							rig.layer1 = layers[2];
							rig.layer2 = layers[1];
							rig.layer3 = layers[0];
							rig.controller = layers[3];
						}
						//3 layer or 2+goal ?
						if (Duik.utils.getDistance(rig.layer3,rig.controller) < 10)
						{
							rig.goal = rig.layer3;
							rig.layer3 = null;
							rig.type = 2;
						}
						else
						{
							rig.type = 3;
						}
					}
					else if (layers.length == 5)
					{
						if (valid)
						{
							rig.layer1 = sortedLayers[0];
							rig.layer2 = sortedLayers[1];
							rig.layer3 = sortedLayers[2];
							rig.goal = sortedLayers[3];
							rig.controller = ctrl;
							rig.type = 3;
						}
						else
						{
							rig.layer1 = layers[3];
							rig.layer2 = layers[2];
							rig.layer3 = layers[1];
							rig.goal = layers[0];
							rig.controller = layers[4];
							rig.type = 3;
						}
					}
				}
				
				//detect 3d
				var threeD = true;
				for (var i = 0 ; i < layers.length ; i++)
				{
					if (!layers[i].threeDLayer)
					{
						threeD = false;
						break;
					}
				}
				rig.threeD = threeD;
				
				//Detect frontFacing if 3D
				//add a point effect on the layer to get values with expressions
				if (threeD)
				{
					var tempEffect = rig.layer1.effect.addProperty("ADBE Point3D Control");
					tempEffect(1).expression = "C = thisComp.layer(\"" + rig.layer1.name + "\");\n" + 
							"u = C.toWorldVec([1,0,0]);\n" + 
							"v = C.toWorldVec([0,1,0]);\n" + 
							"w = C.toWorldVec([0,0,1]);\n" + 
							"sinb = clamp(w[0],-1,1);\n" + 
							"b = Math.asin(sinb);\n" + 
							"cosb = Math.cos(b);\n" + 
							"if (Math.abs(cosb) > .0005){\n" + 
							"c = -Math.atan2(v[0],u[0]);\n" + 
							"a = -Math.atan2(w[1],w[2]);\n" + 
							"}else{\n" + 
							"a = Math.atan2(u[1],v[1]);\n" + 
							"c = 0;\n" + 
							"}\n" + 
							"xValue=Math.round(radiansToDegrees(a));\n" + 
							"yValue=Math.round(radiansToDegrees(b));\n" + 
							"zValue=Math.round(radiansToDegrees(c));\n" + 
							"[(xValue),(yValue),(zValue)]\n";
					var orientation = tempEffect(1).value;
					rig.frontFacing = false;
					if (orientation[0]%180 > 10 || orientation[1]%90 >10) rig.threeD = false;
					else if (orientation[1]%180 < 10) rig.frontFacing = true;
					tempEffect.remove();
				}
				
				return rig;
			}
		}
		// GET CONTROLLERS
		//return Array of Controllers
		if (typeof Duik.utils.getControllers !== 'function')
		{
			Duik.utils.getControllers = function (layrs)
			{
				if (layrs == undefined) layrs = app.project.activeItem.layers;
				else if (layrs.length == 0) layrs = app.project.activeItem.layers;
				var layers = Duik.utils.convertCollectionToArray(layrs);
				
				var controllers = [];
				
				for (var i = 0 ; i< layers.length; i++)
				{
					var l = layers[i];
					if (l instanceof ShapeLayer)
					{
						var iconGroup = l.property("ADBE Root Vectors Group")("Icon");
						if (iconGroup == null) continue;
						var controller = new Controller();
						controller.type = Duik.layerTypes.VECTOR;
						controller.layer = l;
						controller.size = iconGroup("ADBE Vector Transform Group")("ADBE Vector Scale").value[0];
						//check properties
						for (var j = 1 ; j <= iconGroup("ADBE Vectors Group").numProperties ; j++)
						{
							if (iconGroup("ADBE Vectors Group")(j).name == "Rotation")
							{
								controller.rotation = true;
								controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
							}
							else if (iconGroup("ADBE Vectors Group")(j).name == "xPosition")
							{
								controller.xPosition = true;
								controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
							}
							else if (iconGroup("ADBE Vectors Group")(j).name == "yPosition")
							{
								controller.yPosition = true;
								controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
							}
							else if (iconGroup("ADBE Vectors Group")(j).name == "Scale")
							{
								controller.scale = true;
								controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
							}
							else if (iconGroup("ADBE Vectors Group")(j).name == "Arc")
							{
								controller.arc = true;
								controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
							}
							else if (iconGroup("ADBE Vectors Group")(j).name == "Eye")
							{
								controller.eye = true;
								controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")(2)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
							}
						}
						controllers.push(controller);
					}
					else if (l instanceof AVLayer && l.name.indexOf("C_") == 0)
					{
						var controller = new Controller();
						controller.type = Duik.layerTypes.NULL;
						controllers.push(controller);
					}
				}
				return controllers;
			}
		}
		// PICKWHIP
		//returns void
		if (typeof Duik.utils.pickWhip !== 'function')
		{
			Duik.utils.pickWhip = function (childProp,parentProp)
			{
				if (!childProp.canSetExpression) return;
				var exprCode = "";
				var prop = parentProp;
				var name;
				while (prop.parentProperty !== null)
				{
					name = "\"" + prop.name + "\"";
					exprCode = "(" + name + ")" + exprCode;
					// Traverse up the property tree
					prop = prop.parentProperty;
				}
				var comp = prop.containingComp;
				// Prefix the layer reference
			   name = "\"" + prop.name + "\"";
			   exprCode = "layer(" + name + ")" + exprCode;
				// Prefix the comp reference
				exprCode = "comp(\"" + comp.name + "\")." + exprCode;
				
				childProp.expression = exprCode;
			}
		}
		// LINK PROPERTIES
		//returns void
		if (typeof Duik.utils.linkProperties !== 'function')
		{
			Duik.utils.linkProperties = function (childProp,parentProp)
			{
				for (var p = 1 ; p <= childProp.numProperties ; p++)
				{
					if (childProp(p).propertyType == PropertyType.PROPERTY && !childProp(p).elided)
					{
						//copy paste the animation / value
						var anim = Duik.utils.getPropertyAnim(childProp(p),false,0,23000);
						if (anim != null) Duik.utils.setPropertyAnim(parentProp(p),anim,0);
						//get the expression
						if (parentProp(p).canSetExpression && childProp(p).expression != "")
						{ 
							try { parentProp(p).expression = childProp(p).expression; }
							catch (err) {};
					   }
					   //set the link
					   Duik.utils.pickWhip(childProp(p),parentProp(p));
					}
					else
					{
						Duik.utils.linkProperties(childProp(p),parentProp(p));
					}
				}
			}
		}
		// SMART COMP DUPLICATE: DUPLICATE COMP
		//returns void
		if (typeof Duik.utils.duplicateComp !== 'function')
		{
			Duik.utils.duplicateComp = function (comp,prefix)
			{
				var previousComps = [];
				 
				//NEEDED FUNCTIONS
        
				//gets an item with its ID
				function getItemWithID(id)
				{
					for (x=1; x<=app.project.numItems; x++) 
					{
						if (app.project.item(x).id == id)
						{
							return app.project.item(x);
						}
					}
					return null;
				}
    
				//duplicates a comp (recursive through precomps)
				function duplicateStructure(comp,parentFolder,prefix) {
					// Duplicate the incoming comp
					var newCompName = prefix + comp.name;
					var comp = comp.duplicate();
					comp.name = newCompName;
					
					// For each of the layers in the comp, check for subcomps
					for (var i=1; i<=comp.numLayers; i++)
					{
						var layer = comp.layer(i);
						//Check if layer has a source and that its type is a composition
						if (layer.source && layer.source instanceof CompItem)
						{
							// Check if this comp has already been duplicated
							var check = null;
							if (previousComps[layer.source.id])
							{
								check = getItemWithID(previousComps[layer.source.id]);
							}
							
							if (check == null)
							{
								// The subcomp hasn't been duplicated before

								// Store the original comp id to remember the correlation
								var sourceID = layer.source.id;
								// Replace the source of the layer, and recursively check in that subcomp for sub-subcomps
								layer.replaceSource(duplicateStructure(layer.source, parentFolder,prefix), false); 
								// Store the new comp id to remember the correlation
								var destID = layer.source.id;
								//Add the correlation to an array
								previousComps[sourceID] = destID;
							} else
							{
								// Replace the source with the already duplicated comp
								layer.replaceSource(check, false);
							}
						}
					}
    
					//Move the comp to the folder
					comp.parentFolder = parentFolder;
					
					// For the recursion, return the duplicated comp
					return comp;
				}

				//LET's GO
   
				//create a new folder
				var parentFolder = app.project.items.addFolder(prefix + comp.name);
				
				// If the mainComp is not in the root of the project, then put the new folder on the same hierarchy level as the original parent folder
				if (comp.parentFolder.parentFolder)
				{
					parentFolder.parentFolder = comp.parentFolder.parentFolder;
				} else
				{
					parentFolder.parentFolder = comp.parentFolder;
				}
				  
				//go
				var newMainComp = duplicateStructure(comp, parentFolder,prefix);
				
				//add the main comp to the comps duplicated
				previousComps[comp.id] = newMainComp.id;
				
				//update expressions
				for (var i in previousComps)
				{
					//for each comp, get the new name
					var oldComp = getItemWithID(i);
					if (oldComp == null) continue;
					var newComp = getItemWithID(previousComps[i]);
					var oldName = oldComp.name;
					var newName = newComp.name;
					//in all comps, update the name in the expressions
					for (var j in previousComps)
					{
						var oldComp2 = getItemWithID(j);
						if (oldComp2 == null) continue;
						var newComp2 = getItemWithID(previousComps[j]);
						//double quotes
						var old = "comp(\"" + oldName + "\"";
						var newExpr = "comp(\"" + newName + "\"";
						Duik.utils.replaceInLayersExpressions(newComp2.layers,old,newExpr);
						//single quotes
						var old = "comp('" + oldName + "'";
						var newExpr = "comp('" + newName + "'";
						Duik.utils.replaceInLayersExpressions(newComp2.layers,old,newExpr);
					}
				}
				return newMainComp;
			}
		}
		// REPLACE IN EXPRESSIONS - Duik.utils.replaceInExpressions(prop,oldString,newString)
		if (typeof Duik.utils.replaceInExpressions !== 'function')
		{
			Duik.utils.replaceInExpressions = function (prop,oldString,newString)
			{
				if (prop.propertyType == PropertyType.PROPERTY)
				{
					if (prop.canSetExpression)
					{
						var expr = prop.expression;
						expr = Duik.javascript.replaceAll(expr,oldString,newString);
						prop.expression = expr;
						delete expr;
					}
				}
				else if (prop.numProperties > 0)
				{
					for (var propertyIndex = 1;propertyIndex <= prop.numProperties;propertyIndex++)
					{
						Duik.utils.replaceInExpressions(prop.property(propertyIndex),oldString,newString);
					}
				}
			}			
		}
		/* REPLACE IN LAYERS EXPRESSIONS - Duik.utils.replaceInLayersExpressions(layers,oldString,newString);
		
			Replaces all occurences of oldString by newString in all the expressions of all the layers.
		
			parameters
			layers | Array of AVLayers or LayerCollection
			oldString | string
			newString | string
			
			returns
			void
		
		*/
		if (typeof Duik.utils.replaceInLayersExpressions !== 'function')
		{
			Duik.utils.replaceInLayersExpressions = function (layrs,oldString,newString)
			{
				if (newString.indexOf(oldString) >=0) return;
				var layers = Duik.utils.convertCollectionToArray(layrs);
				for (var layerIndex = 0 ; layerIndex<layers.length ; layerIndex++)
				{
					var l = Duik.utils.getItem(layers,layerIndex);
					var locked = l.locked;
					l.locked = false;
					//transform
					Duik.utils.replaceInExpressions(l.transform,oldString,newString);
					//masks
					if (l("ADBE Mask Parade") != null) Duik.utils.replaceInExpressions(l("ADBE Mask Parade"),oldString,newString);
					//effects
					if (l("ADBE Effect Parade") != null) Duik.utils.replaceInExpressions(l("ADBE Effect Parade"),oldString,newString);
					//time remapping
					if (l("ADBE Time Remapping") != null) Duik.utils.replaceInExpressions(l("ADBE Time Remapping"),oldString,newString);
					l.locked = locked;
					delete l;
					delete locked;
				}
			}
		}
		// RENAME LAYER
		if (typeof Duik.utils.renameLayer !== 'function')
		{
			Duik.utils.renameLayer = function (layer,newName,updateExpressions)
			{
				if (layer == undefined) return;
				if (newName == undefined) return;
				if (newName == "") return;
				if (updateExpressions == undefined) updateExpressions = true;
				
				app.beginSuppressDialogs();
				
				var oldName = layer.name;
				layer.name = newName;
				
				var compName = layer.containingComp.name;
				//update expressions
				if (updateExpressions)
				{
					
					//all items
					for (var j = 1;j<=app.project.items.length;j++)
					{
						var comp = app.project.item(j);
						if (comp instanceof CompItem)
						{
							try
							{
								//double quotes
								var old = "comp(\"" + compName + "\").layer(\"" + oldName + "\"";
								var newExpr = "comp(\"" + compName + "\").layer(\"" + newName + "\"";
								Duik.utils.replaceInLayersExpressions(comp.layers,old,newExpr);
								//single quotes
								var old = "comp('" + compName + "').layer('" + oldName + "'";
								var newExpr = "comp('" + compName + "').layer('" + newName + "'";
								Duik.utils.replaceInLayersExpressions(comp.layers,old,newExpr);
							}
							catch (err) {};
						}
					}
					
					//containing comp (thisComp)
					try
					{
						//double quotes
						var old = "layer(\"" + oldName + "\"";
						var newExpr = "layer(\"" + newName + "\"";
						Duik.utils.replaceInLayersExpressions(app.project.activeItem.layers,old,newExpr);
						//single quotes
						var old = "layer('" + oldName + "'";
						var newExpr = "layer('" + newName + "'";
						Duik.utils.replaceInLayersExpressions(app.project.activeItem.layers,old,newExpr);
					}
					catch (err) {};
				}
				
				app.endSuppressDialogs(false);
			}
		}
		// RENAME ITEM
		if (typeof Duik.utils.renameItem !== 'function')
		{
			Duik.utils.renameItem = function (item,newName,updateExpressions)
			{
				if (item == undefined) return;
				if (newName == undefined) return;
				if (newName == "") return;
				if (updateExpressions == undefined) updateExpressions = true;
				
				var oldName = item.name;
				item.name = newName;
				
				
				app.beginSuppressDialogs();
				
				//update expressions
				if (updateExpressions && item instanceof CompItem)
				{
					for (var j = 1;j<=app.project.items.length;j++)
					{
						var comp = app.project.item(j);
						if (comp instanceof CompItem)
						{
							try
							{
								//double quotes
								var old = "comp(\"" + oldName + "\"";
								var newExpr = "comp(\"" + newName + "\"";
								Duik.utils.replaceInLayersExpressions(comp.layers,old,newExpr);
								//single quotes
								var old = "comp('" + oldName + "'";
								var newExpr = "comp('" + newName + "'";
								Duik.utils.replaceInLayersExpressions(comp.layers,old,newExpr);
							}
							catch (err) {};
						}
					}
				}
				
				app.endSuppressDialogs(false);
			}
		}
	}

	//================================
	//========= METHODS ==============
	//================================
	
	//TODO, instead of returning true or false, functions should return the effect created
	
	/*	ADD IK - Duik.autoIK(layers,clockWise,frontFacing)
		adds an IK to the layers
		
		parameters:
		layers | Array of AVLayers or LayerCollection
		clockWise | boolean, used only with two-layer and three-layer IK, default: false
		frontFacing | boolean, default: false
		
		returns
		IKRig object
	*/
	if (typeof Duik.autoIK !== 'function')
	{
		Duik.autoIK = function (layers,cw,frontFacing)
		{				
			if (cw == undefined) cw = false;
			if (frontFacing == undefined) frontFacing = false;

			var ik = Duik.utils.prepIK(layers);
			ik.frontFacing = frontFacing;
			ik.clockWise = cw;
			ik.create();

			return ik;
		}
	}
	// ADD ONE-LAYER IK - Duik.oneLayerIK(controller,layer)
	if (typeof Duik.oneLayerIK !== 'function')
	{
		Duik.oneLayerIK = function (ctrl,layer1)
		{
			//if there's not at least one controller and one layer, abort creation
			if (ctrl == undefined || layer1 == undefined) return false;
			
			//check names
			Duik.utils.checkNames(ctrl.containingComp);
					
			var controllerName = ctrl.name;
			
			//pseudo effect
			var effect;
			if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(ctrl,"DUIK_One_Layer_IK");
			else effect = ctrl.effect.addProperty("DUIK_One_Layer_IK");
			effect.name = Duik.uiStrings.ik + " "  + layer1.name;
						
			//rotation d'origine
			var orot = layer1.transform.rotation.value;

			//=========================================================
			//EXPRESSION TO INSERT
			var expression = "//Duik.oneLayerIK\r\n" + 
			"CName = \"" + controllerName + "\";\r\n" +
			"C = thisComp.layer(CName).toWorld(thisComp.layer(CName).anchorPoint);\r\n" +
			"O =  thisLayer.toWorld(thisLayer.anchorPoint);\r\n" +
			"W = thisComp.layer(CName).effect(\"" + effect.name + "\")(1)/100;\r\n" + 
			"FK = thisComp.layer(CName).effect(\"" + effect.name + "\")(3);\r\n" +
			"R = thisComp.layer(CName).effect(\"" + effect.name + "\")(2);\r\n" + 
			"angle = lookAt(C,O);\r\n" +
			"angle = angle*W;\r\n" +
			"R == 1 ? angle = -angle : angle;\r\n" +
			"var result;\r\n" +
			"angle[0] > 0 ? result = angle[0]+angle[1]+FK+value : result = angle[0]-angle[1]+FK+value;\r\n" +
			"if (angle[1]==-90 || angle[1]==90) result-=90;\n" + 
			"var layer = thisLayer;\r\n" +
			"while (layer.hasParent)\r\n" +
			"{\r\n" +
			"layer = layer.parent;\r\n" +
			"result = result - layer.rotation;\r\n" +
			"}\r\n" +
			"result;";
			//=========================================================

			layer1.transform.rotation.expression = expression;
			
			//nouvelle rotation
			var nrot = layer1.transform.rotation.value;

			layer1.transform.rotation.setValue(-nrot+2*orot);
			
			//select controller
			Duik.utils.deselectLayers();
			ctrl.selected = true;
			
			return true;
		}
	}
	// ADD TWO-LAYER IK - Duik.twoLayerIK(controller,root,end,clockWise,frontFacing)
	if (typeof Duik.twoLayerIK !== 'function')
	{
		Duik.twoLayerIK = function (controller,root,end,clockWise,frontFacing)
		{
			//if there's not at least one controller and two layers, abort creation
			if (controller == undefined || root == undefined || end == undefined) return false;
			if (frontFacing == undefined) frontFacing = false;
			threeD = controller.threeDLayer && root.threeDLayer && end.threeDLayer;
			
			//check names
			Duik.utils.checkNames(controller.containingComp);
			
			//Names
			var endName = end.name;
			var rootName = root.name;
			var controllerName = controller.name;
			
			//pseudo effect
			var effect;
			if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(controller,"DUIK_Two_Layer_IK");
			else effect = controller.effect.addProperty("DUIK_Two_Layer_IK");
			effectName = Duik.uiStrings.ik + " "  + endName;
			effect.name = effectName;
			if (clockWise) effect(1).setValue(1);

			if (threeD) {
				direction = controller.Effects.addProperty("ADBE Angle Control");
				direction.name = "IK Direction " +  rootName.slice(-15);
			}
					
			//créer un zéro
			endZero = controller.containingComp.layers.addNull();
			endZero.threeDLayer = true;
			var controllerParent = controller.parent;
			controller.parent = null;
			endZero.position.setValue(controller.position.value);
			endZero.name = "IK_zero " + endName.slice(-24);
			controller.parent = controllerParent;
	
			//lier le zéro au bone du bout
			endZero.parent = end;

			//verrouiller et masquer le zéro
			endZero.moveToEnd();
			endZero.guideLayer = true;
			endZero.locked = true;
			endZero.enabled = false;
			endZero.shy = true;

			endZeroName = endZero.name;

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE BOUT
			var endExpression = "//Duik.twoLayerIK\r\n" +
				"boneracine = \"" + rootName + "\";\n" + 
				"bonebout = \"" + endName + "\";\n" + 
				"zero = \"" + endZeroName + "\";\n" + 
				"controleur = \"" + controllerName + "\";\n" +
				"FK = thisComp.layer(controleur).effect(\"" + effectName + "\")(5);\n" +
				"IKFK = thisComp.layer(controleur).effect(\"" + effectName + "\")(3) == 0;\n" +
				"if (thisComp.layer(controleur).effect(\"" + effectName + "\")(1) == 1) {cw = true}else{cw=false}\n" +
				"function getWorldPos(theLayerName){\n" + 
				"  L = thisComp.layer(theLayerName);\n" + 
				"  return L.toWorld(L.anchorPoint);\n" + 
				"}\n" + 
				"function oriente(a, b, P) {\n" +
				"return ((b[0]-a[0])*(P[1]-a[1]) - (P[0]-a[0])*(b[1]-a[1]) );\n" +
				"}\n" +
				"A = getWorldPos(boneracine);\n" + 
				"B = getWorldPos(bonebout);\n" + 
				"C = getWorldPos(zero);\n" + 
				"E = getWorldPos(controleur);\n" + 
				"a = length(B,C);\n" + 
				"b = length(E,A);\n" + 
				"c = length(A,B);\n" + 
				"x = (b*b + c*c - a*a )/(2*b);\n" + 
				"alpha = Math.acos(clamp(x/c,-1,1));\n" + 
				"y = b - x;\n" + 
				"  gamma = Math.acos(clamp(y/a,-1,1));\n" + 
				"result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);" +
				"  V1 = B - A;\n" + 
				"  adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n" + 
				"  V2 = C - B;\n" + 
				"  adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n" + 
				"  IK = result +  adj1 - adj2 + value;\n" + 
				"IKFK ? IK : FK;";
			//=========================================================

			threeD ? end.transform.zRotation.expression = endExpression : end.transform.rotation.expression = endExpression;

			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE RACINE
			var rootExpression = "//Duik.twoLayerIK\r\n" +
				"boneracine = \"" + rootName + "\";\n" + 
				"bonebout = \"" + endName + "\";\n" + 
				"zero = \"" + endZeroName + "\";\n" + 
				"controleur = \"" + controllerName + "\";\n" +
				"FK = thisComp.layer(controleur).effect(\"" + effectName + "\")(4);\n" +
				"IKFK = thisComp.layer(controleur).effect(\"" + effectName + "\")(3) == 0;\n" +
				"if (thisComp.layer(controleur).effect(\"" + effectName + "\")(1) == 1) {cw = true}else{cw=false}\n" +
				"function getWorldPos(theLayerName){\n" + 
				"  L = thisComp.layer(theLayerName);\n" + 
				"  return L.toWorld(L.anchorPoint);\n" + 
				"}\n" + 
				"function oriente(a, b, P) {\n" +
				"return ((b[0]-a[0])*(P[1]-a[1]) - (P[0]-a[0])*(b[1]-a[1]) );\n" +
				"}\n" +
				"A = getWorldPos(boneracine);\n" + 
				"B = getWorldPos(bonebout);\n" + 
				"C = getWorldPos(zero);\n" + 
				"E = getWorldPos(controleur);\n" + 
				"a = length(B,C);\n" + 
				"b = length(E,A);\n" + 
				"c = length(A,B);\n" + 
				"x = (b*b + c*c - a*a )/(2*b);\n" + 
				"alpha = Math.acos(clamp(x/c,-1,1));\n" + 
				"D = E - A;\n" + 
				"delta = Math.atan2(D[1],D[0]);\n" + 
				"result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n" +
				"V = B - A;\n" + 
				"adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n" + 
				"IK = result - adj1 + value;\n" + 
				"IKFK ? IK : FK;";
			//=======================================================

			threeD ? root.transform.zRotation.expression = rootExpression : root.transform.rotation.expression = rootExpression;

			if (threeD) {
				//si 3D : le zéro de la jambe pour l'orientation
				//créer un zéro
				var zero = app.project.activeItem.layers.addNull();
				zero.threeDLayer = true;
				var calqueparent = root.parent;
				root.parent = null;
				zero.position.setValue(root.position.value);
				zero.name = "Zero_" + rootName.slice(-24);
				//verrouiller et masquer le zéro
				zero.moveToEnd();
				zero.guideLayer = true;
				zero.shy = true;

				if (frontFacing) {
					var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +
						"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" + 
						"C = controleur.toWorld(controleur.anchorPoint);\n" +
						"Cx = C[0];\n" +
						"Cy = C[1];\n" +
						"Cz = C[2];\n" +
						"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
						"Lx = L[0];\n" +
						"Ly = L[1];\n" +
						"Lz = L[2];" +
						"angle = lookAt([Cz,Cy,Cx],[Lz,Ly,Lx]);\n" +
						"[-angle[1]+90,-angle[0],value[2]]\n"
				} else { //front
					var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +
						"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" + 
						"C = controleur.toWorld(controleur.anchorPoint);\n" +
						"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
						"angle = lookAt(C,L);\n" +
						"[angle[0],angle[1],value[2]]\n"
				} //else front
				zero.transform.orientation.expression = zeroExpression;
				zero.transform.xRotation.expression = "//Duik.twoLayerIK.threeD\r\n" + "thisComp.layer(\"" + controllerName + "\").effect(\"IK Direction " +  rootName.slice(-15) + "\")(1)";

				root.parent = zero;
				//lier le zéro au bone du bout
				zero.parent = calqueparent;
				zero.enabled = false;
				zero.locked = true;
			} //tridi

			//les expressions de stretch
			//les positions d'origine
			var posbout = end.transform.position.value.toString();
			var poszero = endZero.transform.position.value.toString();
			var apracine = root.transform.anchorPoint.value.toString();
			var apbout = end.transform.anchorPoint.value.toString();

			var expressionstretchbout = "//Duik.twoLayerIK.stretch\r\n" +
				"boneracine = \"" + rootName + "\";\n" + 
				"controleur = \"" + controllerName + "\";\n" + 
				"stretch = thisComp.layer(\"" + controllerName + "\").effect(\"" + effectName + "\")(9)/2;\n" + 
				"auto = thisComp.layer(\"" + controllerName + "\").effect(\"" + effectName + "\")(8);\n" +
				"IKFK = thisComp.layer(controleur).effect(\"" + effectName + "\")(3) == 0;\n" +
				"function getWorldPos(theLayerName){\n" + 
				"L = thisComp.layer(theLayerName);\n" + 
				"return L.toWorld(L.anchorPoint);\n" + 
				"}\n" + 
				"dist1 = length([" + apracine + "],[" + posbout + "]);\n" + 
				"dist2 = length([" + apbout + "],[" + poszero + "]);\n" + 
				"proportion = dist1/(dist1+dist2);\n" + 
				"posC = getWorldPos(controleur);\n" + 
				"posR = getWorldPos(boneracine);\n" + 
				"distC = length(posC,posR);\n" + 
				"if (distC > dist1+dist2+stretch && auto ==1 && IKFK) stretch = (distC-dist1-dist2)*proportion;\n" + 
				"else stretch = stretch*proportion;\n" + 
				"coef = 1;\n" + 
				"dist1 != 0 ? coef = (dist1+stretch)/dist1 : coef = 1;\n" +
				"([" + posbout + "]-[" + apracine + "])*coef+[" + apracine + "];";

			end.transform.position.expression = expressionstretchbout;

			var expressionstretchzero = "//Duik.twoLayerIK.stretch\r\n" +
				"boneracine = \"" + rootName + "\";\n" + 
				"controleur = \"" + controllerName + "\";\n" + 
				"stretch = thisComp.layer(\"" + controllerName + "\").effect(\"" + effectName + "\")(9)/2;\n" + 
				"auto = thisComp.layer(\"" + controllerName + "\").effect(\"" + effectName + "\")(8);\n" +
				"IKFK = thisComp.layer(controleur).effect(\"" + effectName + "\")(3) == 0;\n" +
				"function getWorldPos(theLayerName){\n" + 
				"L = thisComp.layer(theLayerName);\n" + 
				"return L.toWorld(L.anchorPoint);\n" + 
				"}\n" + 
				"dist1 = length([" + apracine + "],[" + posbout + "]);\n" + 
				"dist2 = length([" + apbout + "],[" + poszero + "]);\n" + 
				"proportion = dist2/(dist1+dist2);\n" + 
				"posC = getWorldPos(controleur);\n" + 
				"posR = getWorldPos(boneracine);\n" + 
				"distC = length(posC,posR);\n" + 
				"if (distC > dist1+dist2+stretch && auto ==1 && IKFK) stretch = (distC-dist1-dist2)*proportion;\n" + 
				"else stretch = stretch*proportion;\n" + 
				"coef = 1;\n" + 
				"dist2 != 0 ? coef = (dist2+stretch)/dist2 : coef = 1;\n" +
				"([" + poszero + "]-[" + apbout + "])*coef+[" + apbout + "];";

			endZero.transform.position.expression = expressionstretchzero;
			
			//select controller
			Duik.utils.deselectLayers();
			controller.selected = true;
			
			return endZero;
		}
	}
	// ADD THREE-LAYER IK - Duik.threeLayerIK(controller,root,middle,end,clockWise)
	if (typeof Duik.threeLayerIK !== 'function')
	{
		Duik.threeLayerIK = function (controller,root,middle,end,clockWise)
		{
			//if there's not at least one controller and three layers, abort creation
			if (controller == undefined || root == undefined || end == undefined || middle == undefined) return false;
			
			//check names
			Duik.utils.checkNames(controller.containingComp);
			
			//Names
			var endName = end.name;
			var middleName = middle.name;
			var rootName = root.name;
			var controllerName = controller.name;
			
			//pseudo effect
			var effect;
			if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(controller,"DUIK_Three_Layer_IK");
			else effect = controller.effect.addProperty("DUIK_Three_Layer_IK");
			effect.name = Duik.uiStrings.ik + " "  + endName;
			if (clockWise) effect(1).setValue(1);
			
			//créer un zéro
			endZero = controller.containingComp.layers.addNull();
			endZero.threeDLayer = true;
			var controllerParent = controller.parent;
			controller.parent = null;
			endZero.position.setValue(controller.position.value);
			endZero.name = "IK_zero " + endName.slice(-24);
			controller.parent = controllerParent;
	
			//lier le zéro au bone du bout
			endZero.parent = end;

			//verrouiller et masquer le zéro
			endZero.moveToEnd();
			endZero.guideLayer = true;
			endZero.locked = true;
			endZero.enabled = false;
			endZero.shy = true;

			endZeroName = endZero.name;
			
			
			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE BOUT
			end.transform.rotation.expression = "//Duik.threeLayerIK\n" + 
					"zero = \"" + endZeroName + "\";\n" + 
					"upperBone = \"" + rootName + "\";\n" + 
					"middleBone = \"" + middleName + "\";\n" + 
					"lowerBone = \"" + endName + "\";\n" + 
					"controller = \"" + controllerName + "\";\n" + 
					"FK = thisComp.layer(controller).effect(\"" + effect.name + "\")(6);\n" + 
					"IKFK = thisComp.layer(controller).effect(\"" + effect.name + "\")(3) == 0;\n" + 
					"if (thisComp.layer(controller).effect(\"" + effect.name + "\")(1) == 1) {cw = true}else{cw=false}\n" + 
					"function getWorldPos(layer){\n" + 
					"return layer.toWorld(layer.anchorPoint);\n" + 
					"}\n" + 
					"function sq(result){\n" + 
					"return result*result;\n" + 
					"}\n" + 
					"function getAngle(p1,p2){\n" + 
					"var dist = p2-p1;\n" + 
					"var angle = Math.atan2(dist[1],dist[0]);\n" + 
					"return radiansToDegrees(angle);\n" + 
					"}\n" + 
					"function ik() {\n" + 
					"var zPos = getWorldPos(thisComp.layer(zero));\n" + 
					"var uPos = getWorldPos(thisComp.layer(upperBone));\n" + 
					"var mPos = getWorldPos(thisComp.layer(middleBone));\n" + 
					"var lPos = getWorldPos(thisComp.layer(lowerBone));\n" + 
					"var cPos = getWorldPos(thisComp.layer(controller));\n" + 
					"var uLength = length(uPos,mPos);\n" + 
					"var mLength = length(mPos,lPos);\n" + 
					"var lLength = length(lPos,zPos);\n" + 
					"var ikLength = length(uPos,cPos);\n" + 
					"if (ikLength == 0) ikLength = 1;\n" + 
					"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" + 
					"var d2 = sq(ikLength) * (uLength+lLength);\n" + 
					"var d3 = -sq(ikLength) * uLength * lLength;\n" + 
					"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" + 
					"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" + 
					"var d6 = Math.sqrt( sq(ikLength) + sq(uLength) - 2*ikLength*uLength*Math.cos(baseA));\n" + 
					"var lowerA = Math.acos(clamp((sq(d6) - sq(lLength) - sq(mLength)) / (-2*lLength*mLength),-1,1));\n" + 
					"lowerA = cw ? -lowerA : lowerA;\n" + 
					"lowerA = radiansToDegrees(lowerA);\n" + 
					"var mToL =getAngle(mPos,lPos);\n" + 
					"var lToZ =getAngle(lPos,zPos);\n" + 
					"var ikResult = lowerA + mToL - lToZ +180;\n" + 
					"return ikResult;\n" + 
					"}\n" + 
					"var result = value;\n" + 
					"IKFK ? result += ik() : result += FK;\n" + 
					"result;\n";
			//=========================================================
			
			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE MIDDLE
			middle.transform.rotation.expression = "//Duik.threeLayerIK\n" + 
					"zero = \"" + endZeroName + "\";\n" + 
					"upperBone = \"" + rootName + "\";\n" + 
					"middleBone = \"" + middleName + "\";\n" + 
					"lowerBone = \"" + endName + "\";\n" + 
					"controller = \"" + controllerName + "\";\n" + 
					"FK = thisComp.layer(controller).effect(\"" + effect.name + "\")(5);\n" + 
					"IKFK = thisComp.layer(controller).effect(\"" + effect.name + "\")(3) == 0;\n" + 
					"if (thisComp.layer(controller).effect(\"" + effect.name + "\")(1) == 1) {cw = true}else{cw=false}\n" + 
					"function getWorldPos(layer){\n" + 
					"return layer.toWorld(layer.anchorPoint);\n" + 
					"}\n" + 
					"function sq(result){\n" + 
					"return result*result;\n" + 
					"}\n" + 
					"function getAngle(p1,p2){\n" + 
					"var dist = p2-p1;\n" + 
					"var angle = Math.atan2(dist[1],dist[0]);\n" + 
					"return radiansToDegrees(angle);\n" + 
					"}\n" + 
					"function ik()\n" + 
					"{\n" + 
					"var zPos = getWorldPos(thisComp.layer(zero));\n" + 
					"var uPos = getWorldPos(thisComp.layer(upperBone));\n" + 
					"var mPos = getWorldPos(thisComp.layer(middleBone));\n" + 
					"var lPos = getWorldPos(thisComp.layer(lowerBone));\n" + 
					"var cPos = getWorldPos(thisComp.layer(controller));\n" + 
					"var uLength = length(uPos,mPos);\n" + 
					"var mLength = length(mPos,lPos);\n" + 
					"var lLength = length(lPos,zPos);\n" + 
					"var ikLength = length(uPos,cPos);\n" + 
					"if (ikLength == 0) ikLength = 1;\n" + 
					"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" + 
					"var d2 = sq(ikLength) * (uLength+lLength);\n" + 
					"var d3 = -sq(ikLength) * uLength * lLength;\n" + 
					"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" + 
					"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" + 
					"var d5 = Math.sqrt( sq(ikLength) + sq(lLength) - 2*ikLength*lLength*Math.cos(baseA));\n" + 
					"var middleA = Math.acos(clamp((sq(d5)-sq(uLength)-sq(mLength)) / (-2*uLength*mLength),-1,1));\n" + 
					"middleA = cw ? -middleA : middleA ;\n" + 
					"middleA = radiansToDegrees(middleA);\n" + 
					"var uToM =getAngle(uPos,mPos);\n" + 
					"var mToL =getAngle(mPos,lPos);\n" + 
					"var ikResult = middleA + uToM - mToL +180;\n" + 
					"return ikResult;\n" + 
					"}\n" + 
					"var result = value;\n" + 
					"IKFK ? result += ik() : result += FK;\n" + 
					"result;\n";
			//=========================================================
			
			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE ROOT
			root.transform.rotation.expression = "//Duik.threeLayerIK\n" + 
					"zero = \"" + endZeroName + "\";\n" + 
					"upperBone = \"" + rootName + "\";\n" + 
					"middleBone = \"" + middleName + "\";\n" + 
					"lowerBone = \"" + endName + "\";\n" + 
					"controller = \"" + controllerName + "\";\n" + 
					"FK = thisComp.layer(controller).effect(\"" + effect.name + "\")(4);\n" + 
					"IKFK = thisComp.layer(controller).effect(\"" + effect.name + "\")(3) == 0;\n" + 
					"if (thisComp.layer(controller).effect(\"" + effect.name + "\")(1) == 1) {cw = true}else{cw=false}\n" + 
					"function getWorldPos(layer){\n" + 
					"return layer.toWorld(layer.anchorPoint);\n" + 
					"}\n" + 
					"function sq(result){\n" + 
					"return result*result;\n" + 
					"}\n" + 
					"function getAngle(p1,p2){\n" + 
					"var dist = p2-p1;\n" + 
					"var angle = Math.atan2(dist[1],dist[0]);\n" + 
					"return radiansToDegrees(angle);\n" + 
					"}\n" + 
					"function ik() \n" + 
					"{\n" + 
					"var zPos = getWorldPos(thisComp.layer(zero));\n" + 
					"var uPos = getWorldPos(thisComp.layer(upperBone));\n" + 
					"var mPos = getWorldPos(thisComp.layer(middleBone));\n" + 
					"var lPos = getWorldPos(thisComp.layer(lowerBone));\n" + 
					"var cPos = getWorldPos(thisComp.layer(controller));\n" + 
					"var uLength = length(uPos,mPos);\n" + 
					"var mLength = length(mPos,lPos);\n" + 
					"var lLength = length(lPos,zPos);\n" + 
					"var ikLength = length(uPos,cPos);\n" + 
					"if (ikLength == 0) ikLength = 1;\n" + 
					"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" + 
					"var d2 = sq(ikLength) * (uLength+lLength);\n" + 
					"var d3 = -sq(ikLength) * uLength * lLength;\n" + 
					"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" + 
					"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" + 
					"var upperA = cw ? -baseA : baseA ;\n" + 
					"upperA = radiansToDegrees(upperA);\n" + 
					"var uToC =getAngle(uPos,cPos);\n" + 
					"var uToM =getAngle(uPos,mPos);\n" + 
					"var ikResult = upperA + uToC - uToM;\n" + 
					"return ikResult;\n" + 
					"}\n" + 
					"var result = value;\n" + 
					"IKFK ? result += ik() : result += FK;\n" + 
					"result;\n";
			//=========================================================
			
			//les expressions de stretch
			//les positions d'origine
			var posmiddle = middle.transform.position.value.toString();
			var posend = end.transform.position.value.toString();
			var poszero = endZero.transform.position.value.toString();
			var aproot = root.transform.anchorPoint.value.toString();
			var apmiddle = middle.transform.anchorPoint.value.toString();
			var apend = end.transform.anchorPoint.value.toString();
			
			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE MIDDLE
			middle.transform.position.expression = "//Duik.threeLayerIK.stretch\n" + 
					"boneracine = \"" + rootName + "\";\n" + 
					"controleur = \"" + controllerName + "\";\n" + 
					"stretch = thisComp.layer(controleur).effect(\"" + effect.name + "\")(10)/2;\n" + 
					"auto = thisComp.layer(controleur).effect(\"" + effect.name + "\")(9);\n" + 
					"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" + 
					"function getWorldPos(theLayerName){\n" + 
					"L = thisComp.layer(theLayerName);\n" + 
					"return L.toWorld(L.anchorPoint);\n" + 
					"}\n" + 
					"var upperAP = [" + aproot + "];\n" + 
					"var middlePos = [" + posmiddle + "];\n" + 
					"var middleAP = [" + apmiddle + "];\n" + 
					"var lowerPos = [" + posend + "];\n" + 
					"var lowerAP = [" + apend + "];\n" + 
					"var zeroPos = [" + poszero + "];\n" + 
					"dist1 = length(upperAP,middlePos);\n" + 
					"dist2 = length(middleAP,lowerPos);\n" + 
					"dist3 = length(lowerAP,zeroPos);\n" + 
					"ikLength = dist1+dist2+dist3;\n" + 
					"proportion = dist1/ikLength;\n" + 
					"posC = getWorldPos(controleur);\n" + 
					"posR = getWorldPos(boneracine);\n" + 
					"distC = length(posC,posR);\n" + 
					"if (distC > ikLength+stretch && auto ==1 && IKFK) stretch = (distC-ikLength)*proportion;\n" + 
					"else stretch = stretch*proportion;\n" + 
					"coef = 1;\n" + 
					"dist1 != 0 ? coef = (dist1+stretch)/dist1 : coef = 1;\n" + 
					"(middlePos-upperAP)*coef+upperAP;\n";
			//=========================================================
			
			//=========================================================
			//EXPRESSION A INSERER SUR LE BONE BOUT
			end.transform.position.expression = "//Duik.threeLayerIK.stretch\n" + 
					"boneracine = \"" + rootName + "\";\n" + 
					"controleur = \"" + controllerName + "\";\n" + 
					"stretch = thisComp.layer(controleur).effect(\"" + effect.name + "\")(10)/2;\n" + 
					"auto = thisComp.layer(controleur).effect(\"" + effect.name + "\")(9);\n" + 
					"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" + 
					"function getWorldPos(theLayerName){\n" + 
					"L = thisComp.layer(theLayerName);\n" + 
					"return L.toWorld(L.anchorPoint);\n" + 
					"}\n" + 
					"var upperAP = [" + aproot + "];\n" + 
					"var middlePos = [" + posmiddle + "];\n" + 
					"var middleAP = [" + apmiddle + "];\n" + 
					"var lowerPos = [" + posend + "];\n" + 
					"var lowerAP = [" + apend + "];\n" + 
					"var zeroPos = [" + poszero + "];\n" + 
					"dist1 = length(upperAP,middlePos);\n" + 
					"dist2 = length(middleAP,lowerPos);\n" + 
					"dist3 = length(lowerAP,zeroPos);\n" + 
					"ikLength = dist1+dist2+dist3;\n" + 
					"proportion = dist2/ikLength;\n" + 
					"posC = getWorldPos(controleur);\n" + 
					"posR = getWorldPos(boneracine);\n" + 
					"distC = length(posC,posR);\n" + 
					"if (distC > ikLength+stretch && auto ==1 && IKFK) stretch = (distC-ikLength)*proportion;\n" + 
					"else stretch = stretch*proportion;\n" + 
					"coef = 1;\n" + 
					"dist2 != 0 ? coef = (dist2+stretch)/dist2 : coef = 1;\n" + 
					"(lowerPos-middleAP)*coef+middleAP;\n";
			//=========================================================
			
			//=========================================================
			//EXPRESSION A INSERER SUR LE ZERO
			endZero.transform.position.expression = "//Duik.threeLayerIK.stretch\n" + 
					"boneracine = \"" + rootName + "\";\n" + 
					"controleur = \"" + controllerName + "\";\n" + 
					"stretch = thisComp.layer(controleur).effect(\"" + effect.name + "\")(10)/2;\n" + 
					"auto = thisComp.layer(controleur).effect(\"" + effect.name + "\")(9);\n" + 
					"IKFK = thisComp.layer(controleur).effect(\"" + effect.name + "\")(3) == 0;\n" + 
					"function getWorldPos(theLayerName){\n" + 
					"L = thisComp.layer(theLayerName);\n" + 
					"return L.toWorld(L.anchorPoint);\n" + 
					"}\n" + 
					"var upperAP = [" + aproot + "];\n" + 
					"var middlePos = [" + posmiddle + "];\n" + 
					"var middleAP = [" + apmiddle + "];\n" + 
					"var lowerPos = [" + posend + "];\n" + 
					"var lowerAP = [" + apend + "];\n" + 
					"var zeroPos = [" + poszero + "];\n" + 
					"dist1 = length(upperAP,middlePos);\n" + 
					"dist2 = length(middleAP,lowerPos);\n" + 
					"dist3 = length(lowerAP,zeroPos);\n" + 
					"ikLength = dist1+dist2+dist3;\n" + 
					"proportion = dist3/ikLength;\n" + 
					"posC = getWorldPos(controleur);\n" + 
					"posR = getWorldPos(boneracine);\n" + 
					"distC = length(posC,posR);\n" + 
					"if (distC > ikLength+stretch && auto ==1 && IKFK) stretch = (distC-ikLength)*proportion;\n" + 
					"else stretch = stretch*proportion;\n" + 
					"coef = 1;\n" + 
					"dist3 != 0 ? coef = (dist3+stretch)/dist3 : coef = 1;\n" + 
					"(zeroPos-lowerAP)*coef+lowerAP;\n";
			//=========================================================
			
			
			//select controller
			Duik.utils.deselectLayers();
			controller.selected = true;
			
			return endZero;
			
		}
	}
	/* ADD GOAL - Duik.goal(layer,controller)
		adds a goal to the layer which may be controlled by a controller
		
		parameters:
		layer	| AVLayer
		controller | AVLayer or undefined
			
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.goal !== 'function')
	{
		Duik.goal = function (layer,controller)
		{
			//pour ne pas bouger, il faut récupérer la rotation d'origine
			var ancienneRot = 0;
			if (layer.threeDLayer) ancienneRot = layer.transform.zRotation.value;
			else ancienneRot = layer.transform.rotation.value;
			
			//check names
			Duik.utils.checkNames(layer.containingComp);

			//si on a un controleur
			if (controller != undefined)
			{
				//ajouter la case sur le controleur
				var effetGoal = controller.Effects.addProperty("ADBE Checkbox Control");
				effetGoal.name = "Goal" + " " + layer.name;
				effetGoal(1).setValue(true);
				//ajouter l'expression dans le calque
				expr = "//Duik.goal\r\n" +
					"var C = thisComp.layer('" + controller.name + "');\r\n" + 
					"var goal = C.effect('" + effetGoal.name + "')(1);\r\n" + 
					"var result = value + C.rotation;\r\n" + 
					"if (goal == 1)\r\n" + 
					"{\r\n" + 
					"var layer = thisLayer;\r\n" + 
					"while (layer.hasParent)\r\n" + 
					"{\r\n" + 
					"layer = layer.parent;\r\n" + 
					"result = result - layer.rotation;\r\n" + 
					"}\r\n" + 
					"}\r\n" + 
					"result;";
		
				if (layer.threeDLayer) layer.transform.zRotation.expression = expr;
				else layer.transform.rotation.expression = expr;
			}
			else
			{
				//ajouter la case sur le calque
				var effetGoal = layer.Effects.addProperty("ADBE Checkbox Control");
				effetGoal.name = "Goal";
				effetGoal(1).setValue(true);
				//ajouter l'expression dans le calque
				layer.transform.rotation.expression = "//Duik.goal\r\n" +
					"var goal = thisLayer.effect('" + effetGoal.name + "')(1);\r\n" + 
					"var result = value;\r\n" + 
					"if (goal == 1)\r\n" + 
					"{\r\n" + 
					"var layer = thisLayer;\r\n" + 
					"while (layer.hasParent)\r\n" + 
					"{\r\n" + 
					"layer = layer.parent;\r\n" + 
					"result = result - layer.rotation;\r\n" + 
					"}\r\n" + 
					"}\r\n" + 
					"result;";
			}
	
			//et remettre la bonne rotation pour pas bouger
			var nouvelleRot = 0;
			if (layer.threeDLayer) nouvelleRot = layer.transform.zRotation.value;
			else nouvelleRot = layer.transform.rotation.value;

			if (layer.threeDLayer) layer.transform.zRotation.setValue(2*ancienneRot-nouvelleRot);
			else layer.transform.rotation.setValue(2*ancienneRot-nouvelleRot);
			
			//select controller
			if (controller != undefined)
			{
				Duik.utils.deselectLayers();
				controller.selected = true;
			}
			
			return true;
		}
	}
	/* ADD CONTROLLER - Duik.addController(layer,type,color,autoLock,rotation,xPosition,yPosition,scale,size)
	
		parameters
		layer | AVLayer
		color | Array of 4 floats R,V,B,A
		autoLock | boolean
		rotation | boolean
		position | boolean
		scale | boolean
		arc | boolean
		
		returns
		Controller Object
	*/
	if (typeof Duik.addController !== 'function')
	{
		Duik.addController = function (layer,type,color,autoLock,rotation,xPosition,yPosition,scale)
		{
			if (rotation == undefined) rotation = true;
			if (xPosition == undefined) xPosition = true;
			if (yPosition == undefined) yPosition = true;
			if (scale == undefined) scale = false;
			if (color == undefined) color = [1,1,1,1];
			if (autoLock == undefined) autoLock = false;
			if (type == undefined) type = Duik.settings.controllerType;
				
			if (layer != null)
			{
				var layerParent = layer.parent;
				layer.parent = null;
				var layerPosition = layer.transform.position.value;
				layer.parent = layerParent;
			}
			
			var controllerObj = new Controller();
			controllerObj.rotation = rotation;
			controllerObj.xPosition = xPosition;
			controllerObj.yPosition = yPosition;
			controllerObj.scale = scale;
			controllerObj.arc = false;
			controllerObj.eye = false;
			controllerObj.color = color;
			controllerObj.size = 0;

			//le controleur
			var controller;
			if (type == Duik.layerTypes.NULL)
			{
				if (layer != null) controller = layer.containingComp.layers.addNull();
				else controller = app.project.activeItem.layers.addNull();
				//controller size
				var controllerSize = Duik.settings.controllerSize;
				if (Duik.settings.controllerSizeAuto)
				{
					controllerSize = controller.containingComp.width/2 + controller.containingComp.height/2;
					if (Duik.settings.controllerSizeHint == Duik.sizes.SMALL) controllerSize = Math.floor(controllerSize/40);
					else if (Duik.settings.controllerSizeHint == Duik.sizes.MEDIUM) controllerSize = Math.floor(controllerSize/20);
					else if (Duik.settings.controllerSizeHint == Duik.sizes.BIG) controllerSize = Math.floor(controllerSize/10);
				}
				controller.source.width = controllerSize;
				controller.source.height = controllerSize;
				controller.anchorPoint.setValue([controller.source.width/2,controller.source.height/2]);
				controllerObj.layer = controller;
				controllerObj.type = Duik.layerTypes.NULL;
				controllerObj.size = controllerSize;
			}
			else
			{
				if (Duik.settings.controllerSizeAuto) controllerObj.size = 0;
				else controllerObj.size = Duik.settings.controllerSize/30*100;
				if (layer != null) controller = layer.containingComp.layers.addShape();
				else controller = app.project.activeItem.layers.addShape();
				controller.guideLayer = true;
				controllerObj.layer = controller;
				controllerObj.type = Duik.layerTypes.VECTOR;
				controllerObj.update();
			}
			if (layer != null)
			{
				controller.transform.position.setValue(layerPosition);
				var cname = "C_";
				if (layer.name.length > 29)
				{
					cname = cname + layer.name.slice(0,10) + " ... " + layer.name.slice(-13);
				}
				else
				{
					cname = cname + layer.name;
				}
				controller.name = cname;
			}
			else
			{
				controller.name = "C_";
			}
			
			if (autoLock) controllerObj.lock();
			
			//select controller
			Duik.utils.deselectLayers();
			controller.selected = true;

			return controllerObj;
		}
	}
	/* ADD CONTROLLERS - Duik.addControllers(layers,color,autoLock,rotation,xPosition,yPosition,scale)
		
		parameters
		layers | Array of AVLayer or LayerCollection
		color | Array of 4 floats R,V,B,A
		autoLock | boolean
		rotation | boolean
		position | boolean
		scale | boolean
		arc | boolean
		
		returns
		Array of Controller Objects
	*/
	if (typeof Duik.addControllers !== 'function')
	{
		Duik.addControllers = function (layers,type,color,autoLock,rotation,xPosition,yPosition,scale,arc)
		{
			var controllers = [];
			
			if (layers.length > 0)
			{
				for (var i = 0 ; i < layers.length ; i++)
				{
					controllers.push ( Duik.addController( Duik.utils.getItem(layers,i),type,color,autoLock,rotation,xPosition,yPosition,scale ) );
				}
			}
			else
			{
				controllers.push(Duik.addController(null,type,color,autoLock,rotation,xPosition,yPosition,scale,arc));
			}

			//select controllers
			Duik.utils.deselectLayers();
			for (var controllerI = 0; controllerI < controllers.length;controllerI++)
			{
				controllers[controllerI].layer.selected = true;
			}
			
			return controllers;
		}
	}
	/* ADD WIGGLE - Duik.wiggle(layer,property,separateDimensions)

		Adds a wiggle effect on the property of the layer
	
		parameters
		layer | AVLayer
		property | Property
		separateDimensions | boolean, default: false
		
		returns
		true if successful, false if anything went wrong
	*/
	if (typeof Duik.wiggle !== 'function')
	{
		Duik.wiggle = function (layer,prop,separateDimensions)
		{
			if (!prop.canSetExpression) return false;
			
			if (separateDimensions == undefined) separateDimensions = false;
			
			//dimensions
			var dimensions = Duik.utils.getPropertyDimensions(prop);
			if (!separateDimensions) dimensions = 1;
			
			var ok = false;
			
			if (dimensions == 3) ok = Duik.threeDWiggle(layer,prop);
			else if (dimensions == 2) ok = Duik.twoDWiggle(layer,prop);
			else ok = Duik.oneDWiggle(layer,prop);
			
			return ok;
		}
	}
	// ADD 3D WIGGLE - Duik.threeDWiggle(layer,property,x,y,z)
	if (typeof Duik.threeDWiggle !== 'function')
	{
		Duik.threeDWiggle = function (layer,prop)
		{
			var prep = Duik.utils.rigProperty(layer,prop,"DUIK_3D_Wiggle");
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.wiggle;
			effect(11).setValue(layer.containingComp.duration);
			
			prop.expression = "//Duik.3DWiggle\r\n" + 
						"Xfreq = effect(\"" + effect.name + "\")(7);\n" + 
						"Yfreq = effect(\"" + effect.name + "\")(8);\n" + 
						"Zfreq = effect(\"" + effect.name + "\")(9);\n" + 
						"Xamp = effect(\"" + effect.name + "\")(2);\n" + 
						"Yamp = effect(\"" + effect.name + "\")(3);\n" + 
						"Zamp = effect(\"" + effect.name + "\")(7);\n" + 
						"loop = effect(\"" + effect.name + "\")(11);\n" + 
						"if (loop == 0) loop = thisComp.duration;\n" + 
						"t = time % loop;\n" + 
						"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" + 
						"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" + 
						"Z1 = wiggle(Zfreq,Zamp, 1, 0.5, t);\n" +  
						"w1 = [X1[0],Y1[1],Z1[2]];\n" + 
						"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" + 
						"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" + 
						"Z2 = wiggle(Zfreq,Zamp, 1, 0.5, t - loop);\n" +  
						"w2 = [X2[0],Y2[1],Z2[2]];\n" + 
						"w = ease(t, 0,  loop, w1, w2);\n" + 
						"w + value - valueAtTime(0)";
		
			return true;
		}
	}
	// ADD 2D WIGGLE - Duik.twoDWiggle(layer,property)
	if (typeof Duik.twoDWiggle !== 'function')
	{
		Duik.twoDWiggle = function (layer,prop)
		{
			var prep = Duik.utils.rigProperty(layer,prop,"DUIK_2D_Wiggle");
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.wiggle;
			effect(9).setValue(layer.containingComp.duration);
			
			prop.expression = "//Duik.2DWiggle\n" + 
						"Xfreq = effect(\"" + effect.name + "\")(6);\n" + 
						"Yfreq = effect(\"" + effect.name + "\")(7);\n" + 
						"Xamp = effect(\"" + effect.name + "\")(2);\n" + 
						"Yamp = effect(\"" + effect.name + "\")(3);\n" + 
						"loop = effect(\"" + effect.name + "\")(9);\n" + 
						"if (loop == 0) loop = thisComp.duration;\n" + 
						"t = time % loop;\n" + 
						"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" + 
						"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" + 
						"w1 = [X1[0],Y1[1]];\n" + 
						"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" + 
						"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" + 
						"w2 = [X2[0],Y2[1]];\n" + 
						"w = ease(t, 0,  loop, w1, w2);\n" + 
						"w + value - valueAtTime(0)";
			return true;
		}
	}
	// ADD 1D WIGGLE - Duik.1DWiggle(layer,property)
	if (typeof Duik.oneDWiggle !== 'function')
	{
		Duik.oneDWiggle = function (layer,prop)
		{
			var prep = Duik.utils.rigProperty(layer,prop,"DUIK_1D_Wiggle");
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.wiggle;
			effect(3).setValue(layer.containingComp.duration);
			
			prop.expression = "//Duik.1DWiggle\n" + 
						"freq = effect(\"" + effect.name + "\")(2);\n" + 
						"amp = effect(\"" + effect.name + "\")(1);\n" + 
						"loop = effect(\"" + effect.name + "\")(3);\n" + 
						"if (loop == 0) loop = thisComp.duration;\n" + 
						"t = time % loop;\n" + 
						"w1 = wiggle(freq,amp, 1, 0.5, t);\n" + 
						"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" + 
						"w = ease(t, 0,  loop, w1, w2);\n" + 
						"w + value - valueAtTime(0)";
			return true;

		}
	}
	/* ADAPTATIVE EXPOSURE - Duik.adaptativeExposure(layers,precision,minExp,maxExp,sync,layerSync);
	
		Adds exposure controls to the animation of the property.
		The exposure adapts automatically to the speed, according to the given precision,
		of the properties between a minimum and a maximum exposure (in frames).
		
		parameters
		layers | Array of AVLayer or LayerCollection
		precision | integer, default: 100
		minExp | integer, default: 1
		maxExp | integer, default: 4
		
		returns
		Array of AVLayers, the bones created
		
	*/
	if (typeof Duik.adaptativeExposure !== 'function')
	{
		Duik.adaptativeExposure = function (layrs,limit,minExp,maxExp,sync,layerSync)
		{
			//functions
			function getSpeed(p,t)
			{
				if (p.propertyType != PropertyType.PROPERTY) return 0;
				if (p.numKeys == 0) return 0;
				
				//get the nearest key
				var nearKey = p.nearestKeyIndex(t);
				var nearKeyTime = p.keyTime(nearKey);
				
				//if we're still before the first key
				if (t <= nearKeyTime && nearKey == 1) return 0;

				//get the previous key
				var prevKey = 0;
				if (t < nearKeyTime) prevKey = nearKey -1;
				else prevKey = nearKey;
				
				//if the last key is in the past
				if (prevKey == p.numKeys) return 0;    
							
				//get speed & num frames from prevKey
				var difference = Duik.utils.getLength(p.valueAtTime(t,false),p.keyValue(prevKey));
				return difference;
			}
		
			//exposure
			if (layrs == undefined) return false;
			if (layrs.length == 0) return false;
			
			if (minExp == undefined) minExp = 1;
			if (maxExp == undefined) maxExp = 4;
			if (sync == undefined) sync = true;
			if (layerSync == undefined) layerSync = false;
			
			var layers = Duik.utils.convertCollectionToArray(layrs);
			
			if (minExp <= 0) minExp = 1;
			if (maxExp <= 0) maxExp = 1;
			
			if (limit == undefined) limit = 100;
			if (limit == 0) limit = 1;
			
			limit = 1/limit*10000;		
			
			//for each frame of the comp
			var comp = layers[0].containingComp;
			var frames = comp.duration / comp.frameDuration ;
			var exposure = 0;
			if (sync && !layerSync)
			{
				for (var frame = 0 ; frame < frames ; frame += minExp)
				{
					exposure++;
					var speed = 0;
					var time = frame*comp.frameDuration;
					//BOUCLE SUR LES CALQUES POUR VERIFIER SI LIMITE DEPASSEE
					for (var i = 0 ; i < layers.length ; i++)
					{
						var layer = layers[i];
						if (layer.selectedProperties.length == 0) continue;
						for (var j = 0 ; j < layer.selectedProperties.length ; j++)
						{
							var prop = layer.selectedProperties[j];
							var speedTest = getSpeed(prop,time);
							if (speedTest > speed) speed = speedTest;
						}
					}
					
					//BOUCLE SUR LES CALQUES POUR METTRE UNE CLEF SI LIMITE DEPASSEE
					if ((speed >= limit || exposure >= maxExp) && speed > 0)
					{
						exposure = 0;
						for (var i = 0 ; i < layers.length ; i++)
						{
							var layer = layers[i];
							if (layer.selectedProperties.length == 0) continue;
							for (var j = 0 ; j < layer.selectedProperties.length ; j++)
							{
								var prop = layer.selectedProperties[j];
								if (prop.propertyType != PropertyType.PROPERTY) continue;
								if (prop.numKeys == 0) continue;
								prop.addKey(time);
							}
						}
					}
					if (speed == 0) exposure = 0;
				}
			}
			else if (sync)
			{
				//POUR CHAQUE CALQUE
				for (var i = 0 ; i < layers.length ; i++)
				{
					var layer = layers[i];
					if (layer.selectedProperties.length == 0) continue;
					//pour chaque frame
					for (var frame = 0 ; frame < frames ; frame += minExp)
					{
						exposure++;
						var speed = 0;
						var time = frame*comp.frameDuration;
						//POUR CHAQUE PROP
						for (var j = 0 ; j < layer.selectedProperties.length ; j++)
						{
							var prop = layer.selectedProperties[j];
							var speedTest = getSpeed(prop,time);
							if (speedTest > speed) speed = speedTest;
						}
						if ((speed >= limit || exposure >= maxExp) && speed > 0)
						{
							exposure = 0;
							for (var j = 0 ; j < layer.selectedProperties.length ; j++)
							{
								var prop = layer.selectedProperties[j];
								if (prop.propertyType != PropertyType.PROPERTY) continue;
								if (prop.numKeys == 0) continue;
								prop.addKey(time);
							}
						}
						if (speed == 0) exposure = 0;
					}
				}
			}
			else
			{
				//POUR CHAQUE CALQUE
				for (var i = 0 ; i < layers.length ; i++)
				{
					var layer = layers[i];
					if (layer.selectedProperties.length == 0) continue;
					//POUR CHAQUE PROP
					for (var j = 0 ; j < layer.selectedProperties.length ; j++)
					{
						for (var frame = 0 ; frame < frames ; frame += minExp)
						{
							exposure++;
							var speed = 0;
							var time = frame*comp.frameDuration;
							var prop = layer.selectedProperties[j];
							var speed = getSpeed(prop,time);
							if ((speed >= limit || exposure >= maxExp) && speed > 0)
							{
								exposure = 0;
								prop.addKey(time);
							}
							if (speed == 0) exposure = 0;
						}
					}
				}
			}
			//all key interpolations to HOLD
			for (var i = 0 ; i < layers.length ; i++)
			{
				var layer = layers[i];
				if (layer.selectedProperties.length == 0) continue;
				for (var j = 0 ; j < layer.selectedProperties.length ; j++)
				{
					var prop = layer.selectedProperties[j];
					if (prop.propertyType != PropertyType.PROPERTY) continue;
					if (prop.numKeys == 0) continue;
					for (var keyIndex = 1;keyIndex <= prop.numKeys;keyIndex++)
					{
						prop.setInterpolationTypeAtKey(keyIndex,KeyframeInterpolationType.HOLD,KeyframeInterpolationType.HOLD);
					}
				}
			}
			return true;
		}
	}
	/* FIXED EXPOSURE - Duik.fixedExposure(layer,prop);
	
		Adds exposure controls to the animation of the property.
		
		parameters
		layer | AVLayer
		prop | Property
		
		returns
		Array of AVLayers, the bones created
		
	*/
	if (typeof Duik.fixedExposure !== 'function')
	{
		Duik.fixedExposure = function (layer,prop)
		{
			if (layer == undefined) return false;
			if (prop == undefined) return false;
			
			//créer l'effet
			var prep = Duik.utils.rigProperty(layer,prop,"DUIK_Exposure");
			var effect = prep[0];
			var prop = prep[1];
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.exposure;
			effect(1).setValue(1);
					
			prop.expression = "expo = effect(\"" + effect.name + "\")(1);\n" +
			"expo == 0 ? expo = 1 : Math.abs(expo);\n" +
			"timef = timeToFrames(time);\n" +
			"valueAtTime(framesToTime( timef - timef%expo ))";
		}
	}
	/* ADD BONES - Duik.addBones(layers);
	
		Adds bones to the layers, only on selected pins if any, or else on all puppet pins found on those layers.
	
		parameters
		layers | Array of AVLayer
		
		returns
		Array of AVLayers, the bones created
	
	*/
	if (typeof Duik.addBones !== 'function')
	{
		Duik.addBones = function (layers)
		{
			var createdBones = [];
			if (layers.length == 0) { return createdBones; }
			
			//check names
			Duik.utils.checkNames(layers[0].containingComp);
			
			for (var i=0;i<layers.length;i++)
			{
				var calque = Duik.utils.getItem(layers,i);
				// les propriétés sélectionnées
				var props = calque.selectedProperties;
				var coins = [];
				//lister les puppet pins
				if (props.length > 0)
				{
					for (var j=0;j<props.length;j++)
					{
						if (props[j].matchName == "ADBE FreePin3 PosPin Atom") coins.push(props[j]);
					}
				}
				//si il n'y a pas de coins sélectionnés, on les prend tous
				if (coins.length == 0) coins = Duik.utils.getPuppetPins(calque("Effects"));
				//if no pins were found, use every selected spatial properties
				if (coins.length == 0 && props.length > 0)
				{
					for (var j=0;j<props.length;j++)
					{
						if (props[j].propertyType == PropertyType.PROPERTY)
						{
							if (props[j].propertyValueType == PropertyValueType.TwoD_SPATIAL || props[j].propertyValueType == PropertyValueType.ThreeD_SPATIAL)
							{
								if (props[j].canSetExpression) coins.push(props[j]);
							}
						}
					}
				}
				if (coins.length == 0) return;
				
				for (var j=0;j<coins.length;j++)
				{
					var coin = coins[j];
					
					var position;
					
					if (coin.matchName == "ADBE FreePin3 PosPin Atom")
					{
						position = coin.position;
					}
					else
					{
						position = coin;
					}
					
					//créer le bone
					var bone;
					//sa taille
					boneTaille = Duik.settings.boneSize;
					if (Duik.settings.boneSizeAuto) {
						if (calque instanceof ShapeLayer)
						{
							boneTaille = app.project.activeItem.height/2 + app.project.activeItem.height/2;
						}
						else
						{
							var calqueParent = calque.parent;
							calque.parent = null;
							var calqueEchelle = calque.transform.scale.value;
							calque.parent = calqueParent;
							boneTaille = calque.source.width*Math.abs(calqueEchelle[0])/130 + calque.source.height*Math.abs(calqueEchelle[1])/130;
						}
						
						if (Duik.settings.boneSizeHint == Duik.sizes.SMALL) boneTaille = Math.floor(boneTaille/60);
						else if (Duik.settings.boneSizeHint == Duik.sizes.MEDIUM) boneTaille = Math.floor(boneTaille/40);
						else if (Duik.settings.boneSizeHint == Duik.sizes.BIG) boneTaille = Math.floor(boneTaille/20);
					}
					if (Duik.settings.boneType == Duik.layerTypes.NULL)
					{
						bone = app.project.activeItem.layers.addNull();
						bone.name = "B_" + coin.name;
						bone.source.width = boneTaille;
						bone.source.height = boneTaille;
						bone.transform.anchorPoint.setValue([bone.source.width/2,bone.source.height/2]);
					}
					else
					{
						var colorString = Duik.settings.boneColor;
						var red = parseInt(colorString.substr(0,2),16)/255.0;
						var green = parseInt(colorString.substr(2,2),16)/255.0;
						var blue = parseInt(colorString.substr(4,2),16)/255.0;
						bone = app.project.activeItem.layers.addSolid([red,green,blue],"B_" + coin.name,boneTaille,boneTaille,app.project.activeItem.pixelAspect);
					}
					createdBones.push(bone);
					
					//mettre le bone à la position du coin : utiliser une expression pour avoir la position en mode world du coin
					Duik.utils.pickWhip(bone.position,position);
					if (!(calque instanceof ShapeLayer))
					{
						bone.position.expression = "thisComp.layer(\"" + calque.name + "\").toWorld(" + bone.position.expression + ")";
					}

					bone.position.setValue(bone.position.value);
					bone.position.expression = "";
					//nom du bone
					if (coin.matchName == "ADBE FreePin3 PosPin Atom")
					{
						bone.name = "B_" + coin.name;
					}
					else
					{
						bone.name = "B_" + coin.parentProperty.name;
					}
					
					bone.guideLayer = true;
					//mettre l'expression dans le coin
					if (calque instanceof ShapeLayer)
					{
						position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint)";
					}
					else
					{
						position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint);\nfromWorld(bonePos)";
					}
				}//for coins
			}//for layers
			return createdBones;
		}
	}
	// ADD ZERO - Duik.addZero(layer);
	if (typeof Duik.addZero !== 'function')
	{
		Duik.addZero = function (layer)
		{
			//create null object
			var zero = layer.containingComp.layers.addNull();
			var calqueparent = layer.parent;
			layer.parent = null;
			zero.position.setValue(layer.position.value);
			zero.rotation.setValue(layer.rotation.value);
			zero.name = "Zero_" + layer.name.slice(-24);
			layer.parent = zero;
			zero.scale.setValue(layer.scale.value);
			layer.scale.setValue([100,100,100]);

			//parent
			zero.parent = calqueparent;

			//lock and hide
			zero.moveToEnd();
			zero.guideLayer = true;
			zero.locked = true;
			zero.shy = true;
			zero.enabled = false;
			
			return zero;
		}
	}
	/* ADD ZEROS - Duik.addZeros(layers);
	
		Adds a null object for each layer, at the same place and orientation,
		and then parents the layer to it, parenting the null object (the zero) to the former
		parent of the layer.
	
		parameters
		layers | Array of AVLayer
		
		returns
		Array of AVLayers, the zeros created
	
	*/
	if (typeof Duik.addZeros !== 'function')
	{
		Duik.addZeros = function (layers)
		{
			var zeros = [];
			for (var i = 0 ; i < layers.length ; i++)
			{
				var calque = Duik.utils.getItem(layers,i);
				var zero = Duik.addZero(calque);
				zeros.push(zeros);
			}
			return zeros;
		}
	}
	/* ROTATION MORPH - Duik.rotationMorph(layer,prop);
	
		Creates a rotation morph on the given property
	
		parameters
		layer | AVLayer
		prop | Property
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.rotationMorph !== 'function')
	{
		Duik.rotationMorph = function (layer,prop)
		{
			var prep = Duik.utils.rigProperty(layer,prop,"DUIK_RotMorph");
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.rotMorph;
			
			prop.expression = "//Duik.rotationMorph\r\n" + 
								"if (numKeys > 1)\r\n" + 
								"{\r\n" + 
								"r = thisLayer.effect('" + effect.name + "')(1).transform.rotation;\r\n" + 
								"n = timeToFrames(key(numKeys).time);\r\n" + 
								"Min =  thisLayer.effect('" + effect.name + "')(2);\r\n" + 
								"Max = thisLayer.effect('" + effect.name + "')(3);\r\n" + 
								"div =  (Max - Min) / n;\r\n" + 
								"val = 0;\r\n" + 
								"if (div != 0) val = r/div - (Min/div);\r\n" + 
								"valueAtTime(framesToTime(val));\r\n" + 
								"} else value;";
			
			return true;
		}
	}
	/* SWING - Duik.swing(layer,prop);
	
		Creates a swing on the given property
	
		parameters
		layer | AVLayer
		prop | Property
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.swing !== 'function')
	{
		Duik.swing = function (layer,prop)
		{
			var prep = Duik.utils.rigProperty(layer,prop,"DUIK_Swing");
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.swing;
			effect(1).setValue(10);
			effect(2).setValue(1);
			
			prop.expression = "//Duik.swing\r\n" + 
								"amp = effect('" + effect.name + "')(1);\n" +
								"freq = effect('" + effect.name + "')(2)*2*Math.PI;\n" +
								"decalage = framesToTime(effect('" + effect.name + "')(3));\n" +
								"amorti = Math.abs(effect('" + effect.name + "')(4));\n\n" +
								"sin = Math.sin(time*freq+decalage);\n\n" +
								"for(i=0;i<amorti;i++) {\n" +
								"sin = Math.sin(sin);\n" +
								"}\n" +
								"sin*amp+value;";
			
			return true;
		}
	}
	/* WHEEL - Duik.wheel(layer,radius,curved);
	
		Automates the rotation of the given layer using its position.
		If curved, works even if the trajectory is not horizontal, but is heavier to compute.
	
		parameters
		layer | AVLayer
		radius | float, default 100.0
		curved | boolean, default false
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.wheel !== 'function')
	{
		Duik.wheel = function (layer,radius,curved)
		{
			if (radius == undefined) radius = 100;
			else if (! (radius > 0)) radius = 100;
			if (curved == undefined) curved = false;
			var prep = Duik.utils.rigProperty(layer,layer.transform.rotation,"DUIK_Wheel");
			var effect = prep[0];
			if (effect == null) return false;
			effect.name = Duik.uiStrings.wheel;
			effect(1).setValue(radius);
			
			if (!curved) layer.transform.rotation.expression = "//Duik.Wheel\r\n" + 
																"O = thisLayer.toWorld(thisLayer.anchorPoint);\n" + 
																"R = thisLayer.effect('" + effect.name + "')(1);\n" + 
																"Rev = thisLayer.effect('" + effect.name + "')(2);\n" + 
																"result = 0;\n" +
																"R > 0 ? result = radiansToDegrees(O[0]/R) : result = 0 ;" +
																"Rev == 1 ? value - result : value + result;";
			else layer.transform.rotation.expression = "//Duik.Wheel\r\n" + 
															"R = thisLayer.effect('" + effect.name + "')(1);\n" + 
															"Rev = thisLayer.effect('" + effect.name + "')(2);\n" + 
															"var precision = 1;\n" + 
															"function pos(frame)\n" + 
															"{\n" + 
															"return thisLayer.toWorld(thisLayer.anchorPoint,framesToTime(frame));\n" + 
															"}\n" + 
															"function roue()\n" + 
															"{\n" + 
															"if (R<=0) return value;\n" + 
															"var distance = 0;\n" + 
															"var start = thisLayer.inPoint > thisComp.displayStartTime ? timeToFrames(thisLayer.inPoint) : timeToFrames(thisComp.displayStartTime) ;\n" + 
															"var end = time < thisLayer.outPoint ? timeToFrames(time) : timeToFrames(thisLayer.outPoint);\n" + 
															"for(i=start;i<end;i+=precision)\n" + 
															"{\n" + 
															"if (pos(i+precision)[0] - pos(i)[0] > 0) distance += length(pos(i+precision),pos(i));\n" + 
															"else distance -= length(pos(i+precision),pos(i));\n" + 
															"}\n" + 
															"return radiansToDegrees(distance/R) ;\n" + 
															"}\n" + 
															"Rev == 1 ? value - roue() : value + roue();";
			
			return true;
		}
	}
	/* MORPHER - Duik.morpher(layers);
	
		Adds a "morpher", a slider to easily control interpolations of selected properties of the given layers.
	
		parameters
		layers | Array of AVLayer
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.morpher !== 'function')
	{
		Duik.morpher = function (layers)
		{
			//récupérer la sélection d'effets du premier calque, puisqu'elle sera perdue à la création de la glissière..... (voir avec adobe si vous trouvez ca pas pratique)
			var selection = [];
			var effets = Duik.utils.getItem(layers,0).selectedProperties;
			
			for (var j=0;j<effets.length;j++) {
			if (effets[j].canSetExpression && effets[j].parentProperty.isEffect) {
				 var layerIndex = app.project.activeItem.selectedLayers[0].index;
				 var effetIndex =  effets[j].propertyIndex;
				 var effetParentName = effets[j].parentProperty.name;
				selection.push([layerIndex,effetParentName,effetIndex]);
				delete effetIndex;
				delete effetParentName;
				}
			}

			//créer le curseur
			var morpher = layers[0].Effects.addProperty("ADBE Slider Control");
			morpher.name = "Morpher";

			//boucle pour appliquer le morpher sur la sélection perdue
			for (var i=0;i<selection.length;i++)
			{
				var effet = layers[0].effect(selection[i][1])(selection[i][2]);
				effet.expression = "//Duik.Morpher\r\nvalueAtTime((thisComp.layer(\"" +  layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
				//la boucle pour créer automatiquement des clefs sur le morpher :
				if (Duik.settings.morpherCreatesKeyframes)
				{
					//nombre de clefs
					var nbreClefs = effet.numKeys;
					//durée d'image de la compo
					var ips = app.project.activeItem.frameDuration;
					var temps = 0;
					var prop = effet;
					for (var k=1;k<=nbreClefs;k++)
					{                 
						//récupère l'instant de la clef
						temps = prop.keyTime(k);
						//crée une image clef sur le morpher
						morpher(1).setValueAtTime(temps,temps/ips);
					}
					delete temps;
					delete prop;
					delete ips;
					delete nbreClefs;   
				}
			}

			//boucle pour appliquer le morpher partout
			for (var i=0;i<layers.length;i++)
			{
				for (var j=0;j<layers[i].selectedProperties.length;j++)
				{
					var effet = Duik.utils.getItem(layers,i).selectedProperties[j];
					if (effet.canSetExpression && effet.parentProperty.name != "Morpher")
					{
						effet.expression = "valueAtTime((thisComp.layer(\"" + layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
						//la boucle pour créer automatiquement des clefs sur le morpher :
						if (Duik.settings.morpherCreatesKeyframes)
						{
							//nombre de clefs
							var nbreClefs = effet.numKeys;
							//durée d'image de la compo
							var ips = app.project.activeItem.frameDuration;
							var temps = 0;
							var prop = effet;
							for (var k=1;k<=nbreClefs;k++)
							{                 
								//récupère l'instant de la clef
								temps = prop.keyTime(k);
								//crée une image clef sur le morpher
								morpher(1).setValueAtTime(temps,temps/ips);
							}
							delete temps;
							delete prop;
							delete ips;
							delete nbreClefs;   
						}
					}
				}
			}

			return true;
		}
	}
	/* LENS FLARE - Duik.lensFlare(layers);
	
		Rigs the layers to move like a lens flare.
	
		parameters
		layers | Array of AVLayer
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.lensFlare !== 'function')
	{
		Duik.lensFlare = function (layers)
		{
			//sortir le premier calque, le centre, et ajouter les contrôleurs
			var centre = layers.shift();
			
			//check names
			Duik.utils.checkNames(centre.containingComp);
			
			var nomcentre = centre.name;
			var centerEffect;
			if (Duik.usePresets) centerEffect = Duik.utils.addPseudoEffect(centre,"DUIK_LensFlare");
			else centerEffect = centre.effect.addProperty("DUIK_LensFlare");
			centerEffect.name = Duik.uiStrings.lensFlare;
			centerEffect(1).setValue(100);
			centerEffect(2).setValue(100);
			
			//l'expression de position
			var positionexpression = "//Duik.LensFlare\r\n" + 
			"calqueCentre = thisComp.layer(\"" + nomcentre + "\");\n\n" +
			"function positionAbs(calque) {\n" +
			"return calque.toWorld(calque.anchorPoint)\n" +
			"}\n\n" +
			"n=effect(\"" + centerEffect.name + "\")(1);\n\n" +
			"X = thisComp.width - positionAbs(calqueCentre)[0];\n" +
			"Y = thisComp.height - positionAbs(calqueCentre)[1];\n\n" +
			"i=n/100;\n" +
			"j=1-i;\n\n" +
			"if (n!=100) value + ( (  [X,Y]*(i/j) + positionAbs(calqueCentre) )*j)\n" + 
			"else value + [X,Y];";

			//l'expression d'opacité
			var opaciteexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + centre.name  + "\").effect(\"" + centerEffect.name + "\")(1);\n" + "value*n/100";
			
			//l'expression d'échelle
			var tailleexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + nomcentre  + "\").effect(\"" + centerEffect.name + "\")(2);\n" + "value*n/100";
			
			//appliquer les expressions sur le centre
			centre.transform.opacity.expression = opaciteexpression;
			centre.transform.scale.expression = tailleexpression;

			//la boucle d'application des expressions et contrôleurs
			var nombrecalques = layers.length;
			for (var layerI = 0; layerI < nombrecalques; layerI++)
			{
				calque = layers[layerI];
				calque.position.setValue([0,0]);
				//le controleur de la distance
				var distanceEffect;
				if (Duik.usePresets) distanceEffect = Duik.utils.addPseudoEffect(calque,"DUIK_LensFlareDistance");
				else distanceEffect = calque.effect.addProperty("DUIK_LensFlareDistance");
				distanceEffect.name = Duik.uiStrings.lensFlare;
				distanceEffect(1).setValue(100/nombrecalques*(layerI+1));
				
				//appliquer les expressions
				calque.transform.position.expression = positionexpression;
				calque.transform.opacity.expression = opaciteexpression;
				calque.transform.scale.expression = tailleexpression;
				
				//fin de la boucle
			}
			
			//sélectionner le centre (controleur)
			Duik.utils.deselectLayers();
			centre.selected = true;
		}
	}
	/* DISTANCE LINK - Duik.distanceLink(layer,property,parentLayer);
	
		Links the property to the distance of parentLayer
	
		parameters
		layer | AVLayer containing the property
		property | Property to rig
		parentLayer | AVLayer which distance from layer is used to rig
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.distanceLink !== 'function')
	{
		Duik.distanceLink = function (layer,prop,parentLayer)
		{
			//add effect
			var prep = Duik.utils.rigProperty(layer,prop,"DUIK_DistanceLink");
			var effect = prep[0];
			prop = prep[1];
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.distanceLink;
			//get the distance between the two layers
			var distance = Duik.utils.getDistance(layer,parentLayer);
			effect(2).setValue(distance - distance/4.0);
			effect(3).setValue(distance + distance/4.0);
			
			//check names
			Duik.utils.checkNames(layer.containingComp);
			
			if (parentLayer instanceof CameraLayer)
			{
				prop.expression = "//Duik.DistanceLink\r\n" + 
					"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" + 
					"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" + 
					"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" + 
					"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" + 
					"falloff=effect(\"" + effect.name + "\")(6);\n" + 
					"function positionAbs(calque) {\n" + 
					"return calque.toWorld(calque.anchorPoint);\n" + 
					"}\n\n" + 
					"distance = length(calqueRef.position,positionAbs(thisLayer));\n" + 
					"if (distMax>=distMin && falloff!=0){\n" + 
					"if (distance <= distMax && distance >=distMin) {value}\n" + 
					"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" + 
					"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" + 
					"if (distMax==0){value + distance/falloff}\n" + 
					"}else {value}";
			}
			else
			{
				prop.expression = "//Duik.DistanceLink\r\n" + 
					"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" + 
					"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" + 
					"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" + 
					"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" + 
					"falloff=effect(\"" + effect.name + "\")(6);\n" + 
					"function positionAbs(calque) {\n" + 
					"return calque.toWorld(calque.anchorPoint);\n" + 
					"}\n\n" + 
					"distance = length(positionAbs(calqueRef),positionAbs(thisLayer));\n" + 
					"if (distMax>=distMin && falloff!=0){\n" + 
					"if (distance <= distMax && distance >=distMin) {value}\n" + 
					"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" + 
					"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" + 
					"if (distMax==0){value + distance/falloff}\n" + 
					"}else {value}";
			}
			
			return true;
			
		}
	}
	/* SPRING - Duik.spring(property, layer, simulated);
	
		Adds a spring effect on the property
	
		parameters
		property | Array of property
		layer | AVLayer containing the property
		simulated | if true, applies the simulated version of the spring, default: false
		
		returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.spring !== 'function')
	{
		Duik.spring = function (prop, layer, simulated)
		{
			//search for one dimension effects, to know if we need a "bounce" checkbox
			var bounce = false;
			if (prop.propertyValueType == PropertyValueType.OneD) bounce = true;
			
			//if it's not a position, light version
			if (prop.matchName != "ADBE Position") simulated = false;
			if (simulated == undefined) simulated = false;

			var effect;
			if (bounce)
			{
				var prep = Duik.utils.rigProperty(layer,prop,"DUIK_Spring_Bounce");
				var effect = prep[0];
				prop = prep[1];
			}
			else
			{
				var prep = Duik.utils.rigProperty(layer,prop,"DUIK_Spring");
				var effect = prep[0];
				prop = prep[1];
			}
			if (effect == null) return false;
			effect.name = prop.name + " " + Duik.uiStrings.spring;
			
			if (bounce)
			{
				prop.expression = "//Duik.Spring\r\n" + 
							"amorti = effect(\"" + effect.name + "\")(2);\n" + 
							"freq = effect(\"" + effect.name + "\")(1);\n\n" + 
							"rebond = effect(\"" + effect.name + "\")(3);\n\n" + 
							"if (numKeys > 1 && freq != 0 ){\n" + 
							"if (nearestKey(time).index == 1) { value }\n" + 
							"else {\n\n" + 
							"if (length(velocity) == 0) {\n\n" + 
							"tempsClefProx = nearestKey(time).time;\n\n" + 
							"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" + 
							"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" + 
							"temps = time - tempsDebut;\n\n" + 
							"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n\n" + 
							"if (rebond == 0) valueAtTime(tempsDebut) + spring;\n\n" + 
							"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" + 
							"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" + 
							"}\n" + 
							"else { value }\n" + 
							"}\n" + 
							"}\n" + 
							"else { value }";
			}
			else if (!simulated)
			{
				prop.expression = "//Duik.Spring\r\n" + 
								"amorti = effect(\"" + effect.name + "\")(2);\n" + 
								"freq = effect(\"" + effect.name + "\")(1);\n\n" + 
								"rebond = 0;\n\n" + 
								"if (numKeys > 1 && freq != 0 ){\n" + 
								"if (nearestKey(time).index == 1) { value }\n" + 
								"else {\n\n" + 
								"if (length(velocity) == 0) {\n\n" + 
								"tempsClefProx = nearestKey(time).time;\n\n" + 
								"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" + 
								"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" + 
								"temps = time - tempsDebut;\n\n" + 
								"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n\n" + 
								"if (rebond == 0) valueAtTime(tempsDebut) + spring;\n\n" + 
								"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" + 
								"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" + 
								"}\n" + 
								"else { value }\n" + 
								"}\n" + 
								"}\n" + 
								"else { value }";
			}
			else
			{
				prop.expression = "//Duik.spring\r\n" +
							"amorti = effect(\"" + effect.name + "\")(2);\n" + 
							"freq = effect(\"" + effect.name + "\")(1);\n" + 
							"if (amorti == 0) amorti = 0.1;\n" + 
							"if (freq == 0) freq = 0.1;\n" + 
							"retard = freq/amorti;\n" + 
							"poids = 1/amorti/10;\n" + 
							"precision = thisComp.frameDuration;\n" + 
							"function worldVelocity(temps) {\n" + 
							"worldVelocityX = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[0]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[0])*100;\n" + 
							"worldVelocityY = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[1]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[1])*100;\n" + 
							"return [worldVelocityX,worldVelocityY];\n" + 
							"}\n" + 
							"function worldSpeed(temps) {\n" + 
							"return length(worldVelocity(temps));\n" + 
							"}\n" + 
							"tempsDebut = 0;\n" + 
							"tempsRedemarrage = 0;\n" + 
							"stop = false;\n" + 
							"arrete = false;\n" + 
							"for (i=timeToFrames(time);i>=0;i--) {\n" + 
							"var instant = framesToTime(i);\n" + 
							"var instantSuivant = instant-precision;\n" + 
							"if (worldSpeed(instant) == 0 ) {\n" + 
							"if (tempsRedemarrage == 0) tempsRedemarrage = instant;\n" + 
							"if (worldSpeed(instantSuivant) !=0 ) {\n" + 
							"tempsDebut = instantSuivant;\n" + 
							"break;\n" + 
							"}\n" + 
							"}\n" + 
							"}\n" + 
							"temps = time-tempsDebut;\n" + 
							"frameRedemarre = timeToFrames( time-tempsRedemarrage);\n" + 
							"valeur = value\n" + 
							"if ( frameRedemarre <= retard)\n" + 
							"valeur = value - worldVelocity(time)*poids*(frameRedemarre/retard);\n" + 
							"else\n" + 
							"valeur = value - worldVelocity(time)*poids;\n" + 
							"if (worldSpeed(time) == 0) {\n" + 
							"spring = worldVelocity(tempsDebut) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n" + 
							"valeur + spring;\n" + 
							"}else{ valeur; }\n";
			}
				
			return true;
		}
	}
	/* PATH FOLLOW - Duik.pathFollow(layer);
	
		Automates the rotation of the layer so it follows its path.
	
		parameters
		layer | AVLayer
		
		returns
		void
	
	*/
	if (typeof Duik.pathFollow !== 'function')
	{
		Duik.pathFollow = function (layer)
		{
			//expression a insérer
			layer.transform.rotation.expression  = "//Duik.PathFollow\n" + 
			"ff = framesToTime(1);\r\n" + 
			"pos = thisLayer.position;\r\n" + 
			"if (pos.numKeys > 1){\n" + 
			"A = pos.valueAtTime(time-ff);\r\n" + 
			"B =  pos.valueAtTime(time+ff);\r\n\r\n" + 
			"if (pos.key(1).time > time){\r\n" + 
			"A = pos.key(1).value;\r\n" + 
			"B =pos.valueAtTime(pos.key(1).time+ff);\r\n" + 
			"}\r\n\r\n" + 
			"if (thisLayer.position.key(thisLayer.position.numKeys).time < time){\r\n" + 
			"A = pos.valueAtTime(pos.key(pos.numKeys).time-ff);\r\n" + 
			"B = pos.key(pos.numKeys).value;\r\n" + 
			"}\r\n\r\n" + 
			"angle = lookAt(A,B);\r\n" + 
			"angle[0] > 0 ? angle[0]+angle[1]+value : angle[0]-angle[1]+value;\r\n" +
			"} else value;";
		}
	}
	/* MULTIPLANE - Duik.multiplane(numLayers,position,scale);
	
		Creates null objects rigged to easily animate a 2D multiplane camera.
	
		parameters
		numLayers | int, number of layers to create, default: 3
		position | boolean, true to rig positions, default: true
		scale | boolean, true to rig scales, default: false
		
		returns
		void
	
	*/
	if (typeof Duik.multiplane !== 'function')
	{
		Duik.multiplane = function (nbre,pos,sca)
		{
			if (nbre == undefined) nbre = 3;
			if (pos == undefined) pos = true;
			if (sca == undefined) sca = true;
			
			//la couche caméra
			camNbre = Math.ceil(nbre/2);

			if (pos && !sca)
			{
				//créer un zéro
				var zero = app.project.activeItem.layers.addNull();
				zero.name = "Zero_multiplane";
				//verrouiller et masquer le zéro
				zero.moveToEnd();
				zero.guideLayer = true;
				zero.locked = true;
				zero.shy = true;
				zero.enabled = false;

				for (var i=1;i<=nbre;i++)
				{
					var numero = "L00";
					i < 10 ? numero = "L0" + i : numero = "L" + i ;
					//créer les nuls et leurs zéros
					var calque = app.project.activeItem.layers.addNull() ;
					calque.parent = zero;
					if (i == camNbre) 
					{
						calque.name = numero + " cam";
					}
					else
					{
						calque.name = numero;
						calque.locked = true;
					}
					delete calque;
				}
			
				delete zero;

				//ajouter les expressions et curseurs
				for (var i=1;i<=nbre;i++)
				{
					//si on n'est pas sur le calque cam (dont on différencie le numéro si il est pair ou impair)
					if (i != camNbre-nbre%2+1 )
					{
						var calque = app.project.activeItem.layer(i);
						var curseur = calque.Effects.addProperty("ADBE Slider Control");
						curseur.name = "influence position";
						(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;
						delete curseur;
						calque.transform.position.expression = "thisComp.layer(\"L0" + camNbre + " cam\").position * effect(\"influence position\")(1)";
					}
				}
		   }

			else if (!pos && sca)
			{
				//créer un zéro
				var zero = app.project.activeItem.layers.addNull();
				zero.name = "Zero_multiplan";
				//verrouiller et masquer le zéro
				zero.moveToEnd();
				zero.guideLayer = true;
				zero.locked = true;
				zero.shy = true;
				zero.enabled = false;

				for (var i=1;i<=nbre;i++)
				{
					var numero = "L00";
					i < 10 ? numero = "L0" + i : numero = "L" + i ;
					//créer les nuls et leurs zéros
					var calque = app.project.activeItem.layers.addNull() ;
					calque.parent = zero;
					if (i == camNbre) 
					{
						calque.name = numero + " cam";
					}
					else
					{
						calque.name = numero;
						calque.locked = true;
					}
					delete calque;
				}
				
				delete zero;

				//ajouter les expressions et curseurs
				for (var i=1;i<=nbre;i++)
				{
					//si on n'est pas sur le calque cam (dont on différencie le numéro si il est pair ou impair)
					if (i != camNbre-nbre%2+1 )
					{
						var calque = app.project.activeItem.layer(i);
						var curseur = calque.Effects.addProperty("ADBE Slider Control");
						curseur.name = "influence echelle";
						(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;
						delete curseur;
						calque.transform.scale.expression = "thisComp.layer(\"L0" + camNbre + " cam\").scale * effect(\"influence echelle\")(1) - [100,100]* effect(\"influence echelle\")(1) + [100,100]";
					}
				}
			}

			else if (pos && sca)
			{
				//créer un zéro
				var zero = app.project.activeItem.layers.addNull();
				zero.name = "Zero_multiplan";
				//verrouiller et masquer le zéro
				zero.moveToEnd();
				zero.guideLayer = true;
				zero.locked = true;
				zero.shy = true;
				zero.enabled = false;

				for (var i=1;i<=nbre;i++)
				{
					var numero = "L00";
					i < 10 ? numero = "L0" + i : numero = "L" + i ;
					//créer les nuls et leurs zéros position
					var calque = app.project.activeItem.layers.addNull() ;
					calque.parent = zero;
					if (i == camNbre) 
					{
						calque.name = numero + " cam position";
					}
					else
					{
						calque.name = numero;
						calque.locked = true;
					}
					delete calque;
				}

				//ajouter les expressions et curseurs position
				for (var i=1;i<=nbre;i++)
				{
					//si on n'est pas sur le calque cam (dont on différencie le numéro si il est pair ou impair)
					if (i != camNbre-nbre%2+1 )
					{
						var calque = app.project.activeItem.layer(i);
						var curseur = calque.Effects.addProperty("ADBE Slider Control");
						curseur.name = "influence position";
						(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;
						delete curseur;
						calque.transform.position.expression = "thisComp.layer(\"L0" + camNbre + " cam position\").position * effect(\"influence position\")(1)";
					}
				}
				
				for (var i=1;i<=nbre;i++)
				{
					var numero = "L00";
					i < 10 ? numero = "L0" + i : numero = "L" + i ;
					//créer les nuls et leurs zéros scale
					var calque = app.project.activeItem.layers.addNull() ;
					calque.parent = zero;
					if (i == camNbre) 
					{
						calque.name = numero + " cam scale";
					}
					else
					{
						calque.name = numero;
						calque.locked = true;
					}
					delete calque;
				}
				
				//ajouter les expressions et curseurs scale
				for (var i=1;i<=nbre;i++)
				{
					//si on n'est pas sur le calque cam (dont on différencie le numéro si il est pair ou impair)
					if (i != camNbre-nbre%2+1 )
					{
						var calque = app.project.activeItem.layer(i);
						var curseur = calque.Effects.addProperty("ADBE Slider Control");
						curseur.name = "influence echelle";
						(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;
						delete curseur;
						calque.transform.scale.expression = "thisComp.layer(\"L0" + camNbre + " cam scale\").scale * effect(\"influence echelle\")(1) - [100,100]* effect(\"influence echelle\")(1) + [100,100]";
					}
				}

				delete zero;

				//relinker les positions aux échelles
				for (var i=1;i<=nbre;i++)
				{
					app.project.activeItem.layer(nbre + i).locked = false;
					app.project.activeItem.layer(nbre + i).parent = app.project.activeItem.layer(i);
					if (app.project.activeItem.layer(nbre + i).name.indexOf("cam") < 0) app.project.activeItem.layer(nbre + i).locked = true;
				}

			}
		}
	}
	/* COPY ANIM - Duik.copyAnim(layers,selectedKeysOnly,startTime,endTime);
	
		Copy all the animations (except expressions) on selected layers, and store them in Duik.copiedAnim.
	
		parameters
		layers | Array or Collection of AVLayers
		selectedKeysOnly | boolean, true to copy only selected keys, default: false
		startTime | float, default: start of comp
		endTime | float, default: end of comp
		
		returns
		Array of LayerAnim
	
	*/
	if (typeof Duik.copyAnim !== 'function')
	{
		Duik.copyAnim = function (layers,selectedKeysOnly,startTime,endTime)
		{
			if (layers.length == 0)
			{
				return null;
			}
						
			var comp = Duik.utils.getItem(layers,0).containingComp
			
			if (selectedKeysOnly == undefined) selectedKeysOnly = false;
			if (startTime == undefined) startTime = comp.workAreaStart;
			if (endTime == undefined) endTime = comp.workAreaDuration + comp.workAreaStart;

			Duik.copiedAnim = [];

			//parcourir tous les calques à la recherche des anims à sauvegarder
			for (var layerIndex = 0; layerIndex < layers.length ; layerIndex++)
			{
				var layerAnim = new LayerAnim();
				var l = Duik.utils.getItem(layers,layerIndex);
				layerAnim.name = l.name;
				layerAnim.index = l.index;

				// 1 - sauver l'anim des transformations
				layerAnim.transformAnims = Duik.utils.getPropertyAnims(l.transform,selectedKeysOnly,startTime,endTime);

				// 2 - les masques
				for (var maskIndex=1;maskIndex<=l("Masks").numProperties;maskIndex++)
				{
					var maskAnim = new MaskAnim();
					maskAnim.name = l("Masks")(maskIndex).name;
					maskAnim.anims = Duik.utils.getPropertyAnims(l("Masks")(maskIndex),selectedKeysOnly,startTime,endTime);
					if (maskAnim.anims.length >=1) layerAnim.masksAnims.push(maskAnim);
				}

				// 3 - les effets
				for (var effectIndex=1;effectIndex<=l("Effects").numProperties;effectIndex++)
				{
					var effectAnim = new EffectAnim();
					effectAnim.name = l("Effects")(effectIndex).name;
					effectAnim.matchName = l("Effects")(effectIndex).matchName;
					effectAnim.anims = Duik.utils.getPropertyAnims(l("Effects")(effectIndex),selectedKeysOnly,startTime,endTime);
					if (effectAnim.anims.length >=1) layerAnim.effectsAnims.push(effectAnim);
				}
				
				Duik.copiedAnim.push(layerAnim);
				
			}
			return Duik.copiedAnim;
		}
	}
	/* PASTE ANIM - Duik.pasteAnim(layers,layerAnims,startTime,getLayerMethod);

	Paste all the animations in the Array of LayerAnim on layers, using layer names or layer indexes, beginning at startTime

	parameters
	layers | Layers where to paste the animation
	layerAnims | Array of LayerAnim, default: Duik.copiedAnim
	startTime | float, default: comp.time
	getLayerMethod | one of Duik.getLayers.NAME, Duik.getLayers.INDEX, Duik.getLayers.SELECTION_INDEX, default: Duik.settings.getLayersMethod
	
	returns
	integer, number of layers where animations were pasted
	
	*/
	if (typeof Duik.pasteAnim !== 'function')
	{
		Duik.pasteAnim = function (layers,layerAnims,startTime,getLayerMethod)
		{
			if (layers == undefined) return 0;
			if (layers.length == 0) return 0;
			if (layerAnims == undefined) layerAnims = Duik.copiedAnim;
			if (getLayerMethod == undefined) getLayerMethod = Duik.settings.getLayersMethod;
			var comp = Duik.utils.getItem(layers,0).containingComp;
			if (startTime == undefined) startTime = comp.time;
			
			var totalPasted = 0;
			
			for (var li = 0;li < layers.length;li++)
			{
				var l = Duik.utils.getItem(layers,li);
				var layerAnim = null;
				//parcourir les animations sauvées pour trouver celle qui matche le calque
				if (getLayerMethod == Duik.getLayers.INDEX)
				{
					for (var ai = 0;ai < layerAnims.length;ai++)
					{
						if (layerAnims[ai].index == l.index)
						{
							layerAnim = layerAnims[ai];
							break;
						}
					}
				}
				else if (getLayerMethod == Duik.getLayers.NAME)
				{
					for (var ai = 0; ai < layerAnims.length ; ai++)
					{
						if (layerAnims[ai].name == l.name)
						{
							layerAnim = layerAnims[ai];
							break;
						}
					}
				}
				else if (getLayerMethod == Duik.getLayers.SELECTION_INDEX)
				{
					if (li < layerAnims.length) layerAnim = layerAnims[li];
				}
				
				if (layerAnim == null) continue;
				
				totalPasted++;

				//transform
				if (layerAnim.transformAnims.length > 0)
				{
					for (var j = 0;j< layerAnim.transformAnims.length; j++)
					{
						Duik.utils.setPropertyAnim(l.transform,layerAnim.transformAnims[j],startTime);
					}
				}
				
				//masks
				if (layerAnim.masksAnims.length > 0)
				{
					for (var j = 0;j< layerAnim.masksAnims.length; j++)
					{
						for (var k = 1;k<=l("Masks").numProperties;k++)
						{
							if (l("Masks")(k).name == layerAnim.masksAnims[j].name)
							{
								for (var mi = 0;mi < layerAnim.masksAnims[j].anims.length;mi++)
								{
									Duik.utils.setPropertyAnim(l("Masks")(layerAnim.masksAnims[j].name),layerAnim.masksAnims[j].anims[mi],startTime);
								}
								break;
							}
						}
					}
				}
				
				//effects
				if (layerAnim.effectsAnims.length > 0)
				{
					for (var j = 0;j< layerAnim.effectsAnims.length; j++)
					{
						for (var k = 1;k<=l("Effects").numProperties;k++)
						{
							if (l("Effects")(k).name == layerAnim.effectsAnims[j].name && l("Effects")(k).matchName == layerAnim.effectsAnims[j].matchName)
							{
								for (var ei = 0;ei < layerAnim.effectsAnims[j].anims.length;ei++)
								{
									Duik.utils.setPropertyAnim(l("Effects")(layerAnim.effectsAnims[j].name),layerAnim.effectsAnims[j].anims[ei],startTime);
								}
								break;
							}
						}
					}
				}
			}
			return totalPasted;
		}
	}
	/* RIG PAINT - Duik.rigPaint(layers);

	Rigs the paint effects to be able to animate all strokes as if there was only one.

	parameters
	layers | Array of Layers or LayerCollection which have a paint effect
		
	returns
	void
	
	*/
	if (typeof Duik.rigPaint !== 'function')
	{
		Duik.rigPaint = function (layrs)
		{
			var layers = Duik.utils.convertCollectionToArray(layrs);
			for (var i = 0 ; i < layers.length ; i++)
			{
				var layer = layers[i];
				
				//if there's no paint effect
				var paintEffect = layer("Effects")("ADBE Paint");
				if (paintEffect == null) continue;
				
				//add effect
				var effect;
				if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(layer,"DUIK_Paint_Rig");
				else effect = layer.effect.addProperty("DUIK_Paint_Rig");
				
				effectName = Duik.uiStrings.paintRig;
				effect.name = effectName;
				
				//need to get the paint effect again after addProperty, After Effects bug.......
				var paintEffect = layer("Effects")("ADBE Paint");

				//for each stroke
				var nbre = paintEffect.property(2).numProperties;
				for (var j=1;j<=nbre;j++)
				{
					var propStart = paintEffect.property(2).property(j).property(4).property(1);
					var propEnd = paintEffect.property(2).property(j).property(4).property(2);
					var propDiam = paintEffect.property(2).property(j).property(4).property(4);
					
					propStart.expression = "//Duik.PaintRig\n" + 
							"var ctrl = effect(\"" + effectName + "\")(1);\n" + 
							"var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n" + 
							"var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n" + 
							"result = ctrl - ((100/total)*(ind-1));\n" + 
							"result = result * total;\n" + 
							"result;";
							
					propEnd.expression = "//Duik.PaintRig\n" + 
							"var ctrl = effect(\"" + effectName + "\")(2);\n" + 
							"var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n" + 
							"var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n" + 
							"result = ctrl - ((100/total)*(ind-1));\n" + 
							"result = result * total;\n" + 
							"result;";
							
					propDiam.expression = "//Duik.PaintRig\n" + 
							"value+effect(\"" + effectName + "\")(3);";
				}
			}
		}
	}
	/* BLINK - Duik.blink(layer,prop);

	Adds a blink effect to the property.

	parameters
		layer | AVLayer
		prop | Property
		
	returns
		true if successful, false if anything went wrong
	
	*/
	if (typeof Duik.blink !== 'function')
	{
		Duik.blink = function (layer,prop)
		{
			var dim = Duik.utils.getPropertyDimensions(prop);
			if (dim == 1)
			{
				var prep = Duik.utils.rigProperty(layer,prop,"DUIK_Blink_1D");
				var effect = prep[0];
				prop = prep[1];
				if (effect == null) return false;
				effect.name = prop.name + " " + Duik.uiStrings.blink;
				
				prop.expression = "//Duik.blink\r\n" + 
									"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
									"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
									"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
									"var offValue = effect(\"" + effect.name + "\")(4);\r\n" +
									"freq= timeToFrames(1)/freq;\r\n" +
									"var currentFrame = timeToFrames(time)+offset;\r\n" +
									"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
									"else value;";
			}
			else if (dim == 2)
			{
				var prep = Duik.utils.rigProperty(layer,prop,"DUIK_Blink_2D");
				var effect = prep[0];
				prop = prep[1];
				if (effect == null) return false;
				effect.name = prop.name + " " + Duik.uiStrings.blink;
				
				prop.expression = "//Duik.blink\r\n" + 
									"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
									"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
									"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
									"var offValue = [effect(\"" + effect.name + "\")(4),effect(\"" + effect.name + "\")(5)];\r\n" +
									"freq= timeToFrames(1)/freq;\r\n" +
									"var currentFrame = timeToFrames(time)+offset;\r\n" +
									"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
									"else value;";
			}
			else if (dim == 3)
			{
				var prep = Duik.utils.rigProperty(layer,prop,"DUIK_Blink_3D");
				var effect = prep[0];
				prop = prep[1];
				if (effect == null) return false;
				effect.name = prop.name + " " + Duik.uiStrings.blink;
				
				prop.expression = "//Duik.blink\r\n" + 
									"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
									"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
									"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
									"var offValue = [effect(\"" + effect.name + "\")(4),effect(\"" + effect.name + "\")(5),effect(\"" + effect.name + "\")(6)];\r\n" +
									"freq= timeToFrames(1)/freq;\r\n" +
									"var currentFrame = timeToFrames(time)+offset;\r\n" +
									"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
									"else value;";
			}
			
			return true;
		}
	}
	/* LOCK PROPERTY - Duik.lockProperty(layer,prop);

	Locks the property with a simple expression.

	parameters
		prop | Property
		
	returns
		void
	
	*/
	if (typeof Duik.lockProperty !== 'function')
	{
		Duik.lockProperty = function (prop)
		{
			if (prop.canSetExpression)
			{
				prop.expression = uneval(prop.value);
			}
		}
	}
	/* SCALE Z-LINK - Duik.scaleZLink(layers);

	Links the distance of the layer from the camera to its scale so its apparent size won't change.
	If multiple cameras, include the camera used in the array

	parameters
		layers | Array of Layer or LayerCollection
		
	returns
		void
	
	*/
	if (typeof Duik.scaleZLink !== 'function')
	{
		Duik.scaleZLink = function (layrs)
		{
			if (layrs == undefined) return;
			if (layrs.length == 0) return;

			var camera = null;
			//find camera
			var layers = Duik.utils.convertCollectionToArray(layrs);
			for (i = 0 ; i <layers.length;i++)
			{
				var l = layers[i];
				if (l instanceof CameraLayer)
				{
					camera = l;
					break;
				}
			}
			if (camera == null)
			{
				var comp = layers[0].containingComp;
				for (var i = 1;i<=comp.layers.length;i++)
				{
					var l = comp.layers[i];
					if (l instanceof CameraLayer)
					{
						camera = l;
						break;
					}
				}
			}
			if (camera == null) return;
			
			//go!
			var layers = Duik.utils.convertCollectionToArray(layrs);
			for (i = 0 ; i <layers.length;i++)
			{
				var layer = layers[i];
				if (!layer.threeDLayer) continue;
				var currentDistance = Duik.utils.getDistance(layer,camera);
				if (currentDistance == 0) currentDistance = 1;
				var currentScale = layer.transform.scale.value;
				
				var effect = layer.Effects.addProperty("ADBE Slider Control");
				effect.name = Duik.uiStrings.scale;
				
				effect(1).setValue(currentScale[0]);
				
				layer.transform.scale.expression = "//Duik.scaleZLink\n" + 
													"var sca = effect(\"" + effect.name + "\")(1);\n" + 
													"var C = thisComp.layer(\"" + camera.name + "\").position;\n" + 
													"var O = thisLayer.toWorld(thisLayer.anchorPoint);\n" + 
													"var oDist = " + currentDistance + ";\n" + 
													"if (sca != 0) {\n" + 
													"var factor = oDist / sca;\n" + 
													"var dist = length(C,O);\n" + 
													"var result = dist/factor;\n" + 
													"result = [result,result,result];\n" + 
													"result = result ;\n" + 
													"result;\n" + 
													"} else [0,0,0];";
			}
		}
	}
	/* SMART TIME REMAP - Duik.timeRemap(layers);

	Activates the time remapping of the layers, extending them to the length of the comp and
	adjusting the last keyframe.

	parameters
		layers | Array of Layer or LayerCollection
		loopType | String, "in" or "out" or "none", default: "none"
		
	returns
		void
	
	*/
	if (typeof Duik.timeRemap !== 'function')
	{
		Duik.timeRemap = function (layrs,loopType)
		{
			if (layrs == undefined) return;
			if (layrs.length == 0 ) return;
			var layers = Duik.utils.convertCollectionToArray(layrs);
			for (var i = 0 ; i < layers.length ; i++)
			{
				var layer = layers[i];
				if (!layer.canSetTimeRemapEnabled) continue;
				
				var comp = layer.containingComp;
				var lastValueTime = layer.outPoint - comp.frameDuration;
				
				if (!layer.timeRemapEnabled) layer.timeRemapEnabled = true;

				layer.timeRemap.setValueAtTime(lastValueTime,layer.timeRemap.valueAtTime(lastValueTime,true));
				layer.timeRemap.removeKey(3);
				if (loopType == "out")
				{
					layer.timeRemap.setValueAtTime(lastValueTime+comp.frameDuration,0);
					layer.timeRemap.expression = "loopOut();";
				}
				if (loopType == "in")
				{
					layer.timeRemap.setValueAtTime(lastValueTime+comp.frameDuration,0);
					layer.timeRemap.expression = "loopIn();";
					layer.inPoint = 0;
				}
			}
		}
	}
	/* ONION SKIN - Duik.onionSkin(layer,activate,duration);

	Activates or deactivates an onion skin on paint effects on the layer.

	parameters
		layer | AVLayer
		activate | boolean, default: true
		duration | integer, onion skin duration in frames, default: 5
		
	returns
		void
	
	*/
	if (typeof Duik.onionSkin !== 'function')
	{
		Duik.onionSkin = function (layer,activate,onionDuration)
		{
			if (layer == undefined) return;
			if (activate == undefined) activate = true;
			if (onionDuration == undefined) onionDuration = 5;
			
			var comp = layer.containingComp;
			for (var i = 1 ; i <= layer.Effects.numProperties ; i++)
			{
				var paint = layer.effect(i);
				if (paint.matchName != "ADBE Paint") continue;
				for (var j = 1 ; j <= paint.property("ADBE Paint Group").numProperties ; j++)
				{
					var stroke = paint.property("ADBE Paint Group")(j);
					if (stroke.matchName != "ADBE Paint Atom") continue;
					if (activate)
					{
						//stroke.property("ADBE Paint Transfer Mode") : blending mode
						var inPoint = stroke.property("ADBE Paint Duration").value[0];
						var duration = stroke.property("ADBE Paint Duration").value[1] ;
						var outPoint = duration + inPoint;
						var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
						//if keyframes (already activated)
						if (opacity.numKeys > 0)
						{
							outPoint = opacity.keyTime(1);
							//remove keys
							while (opacity.numKeys>0)
							{
								opacity.removeKey(1);
							}
							opacity.setValue(100);
						}
						duration = (outPoint-inPoint) + onionDuration*comp.frameDuration;
						
						//set duration
						stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
						//add keyframes
						opacity.setValueAtTime(outPoint,100);
						opacity.setValueAtTime(inPoint +duration,0);
					}
					else
					{
						var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
						if (opacity.numKeys > 0)
						{
							var inPoint = stroke.property("ADBE Paint Duration").value[0];
							 outPoint = opacity.keyTime(1);
							 while (opacity.numKeys>0)
							{
								opacity.removeKey(1);
							}
							opacity.setValue(100);
							 //set duration
							stroke.property("ADBE Paint Duration").setValue([inPoint,outPoint-inPoint]);
						}
					}
				}
			}
			//deselect
			while(layer.selectedProperties.length > 0)
			{
				layer.selectedProperties[0].selected = false;
			}
		}
	}
	/* IMPORT RIG IN COMP - Duik.importRigInComp(comp,rigComp,rigName, progressBar, progressText,containingWindow);

	Imports a rig in the comp, transferring and linking the controllers in the new comp, while keeping the rig precomposed.
	The rig comp is duplicated, including precomps, renamed, and expressions are updated, so that one can import the same rig seeveral times.

	parameters
		comp | CompItem, the comp where to import the rig
		rigComp | CompItem, the comp containing the rig
		rigName | the name of this instance of the rig, must be unique in the project
		progressBar | scriptUI ProgressBar, optionnal, to display the progression
		progressText | Any scriptUI Control with a text property, needed if progressBar is provided
		containingWindow | scriptUI Window containing the provided progressBar and progressText
		
	returns
		void
	
	*/
	if (typeof Duik.importRigInComp !== 'function')
	{
		Duik.importRigInComp = function (comp, characterComp, characterName, progressBar, progressText, containingWindow)
		{	
			var useProgressBar = false;
			if (progressBar != undefined && progressText != undefined && containingWindow != undefined)
			{
				useProgressBar = true;
			}
			if (useProgressBar)
			{
				containingWindow.show();
				progressBar.maxValue = 1000;
				progressBar.value = 0;
				progressText.text = "Importing " + characterName + "_" + characterComp.name;
				containingWindow.update();
			}
			
			app.beginSuppressDialogs();
						
			//duplicate character comp
			var characterComp = Duik.utils.duplicateComp(characterComp,characterName + "_");

			//add character comp in the comp
			var characterLayer = comp.layers.add(characterComp);
			
			if (useProgressBar)
			{
				progressText.text = "Getting existing controllers";
				containingWindow.update();
			}
			
			//Create a null object to get world coordinates of the zeros in the character comp
			var tempNull = characterComp.layers.addNull();
			//check if all controllers have a zero, create it if needed
			//get world pos of the zeros
			var zerosPos = [];
			var characterZeros = [];
			var characterControllers = Duik.utils.getControllers(characterComp.layers);
			
			if (useProgressBar)
			{
				progressBar.maxValue = characterControllers.length*4;
				progressText.text = "Preparing controllers and zeros";
				containingWindow.update();
				var progressValue = 0;
			}
			
			for (var i in characterControllers)
			{
				if (useProgressBar)
				{
					progressValue++;
					progressBar.value = progressValue;
					containingWindow.update();
				}
				var zero = characterControllers[i].layer.parent;
				if (zero == null || zero.name.indexOf("Zero") != 0)
				{
					zero = Duik.addZero(characterControllers[i].layer);
				}
				//get the coordinates of the zero
				tempNull.transform.position.expression = "thisComp.layer(" + characterControllers[i].layer.parent.index + ").toWorld(thisComp.layer(" + characterControllers[i].layer.parent.index + ").anchorPoint)";
				zerosPos.push(tempNull.transform.position.value);
				characterZeros.push(zero);
			}
			tempNull.remove();
			
			if (useProgressBar)
			{
				progressText.text = "Creating new controllers";
				containingWindow.update();
			}
			
			//create the new zeros and controllers in the comp
			var newZeros = [];
			var newControllerLayers = [];
			for (var i = characterControllers.length -1; i>=0 ; i--)
			{
				if (useProgressBar)
				{
					progressValue++;
					progressBar.value = progressValue;
					containingWindow.update();
				}
				var oldZero = characterZeros[i];
				var newZero = comp.layers.addNull();
				newZero.parent = characterLayer;
				newZero.transform.position.setValue(zerosPos[i]);
				newZero.name = "Zero_" + characterName + "_" + characterControllers[i].layer.name;
				newZero.guideLayer = true;
				newZero.shy = true;
				newZero.moveToEnd();
				newZero.enabled = false;
				newZeros.unshift(newZero);
				
				var oldController = characterControllers[i];
				var newController = Duik.addController(newZero,oldController.type,oldController.color,false,oldController.rotation,oldController.xPosition,oldController.yPosition,oldController.scale);
				newController.size = oldController.size;
				newController.arc = oldController.arc;
				newController.eye = oldController.eye;
				newController.update();
				newController.layer.name = characterName + "_" + oldController.layer.name;
				newController.layer.parent = newZero;
				newControllerLayers.unshift(newController.layer);
				
				//Get the effects
				for (var j = 1; j <= oldController.layer.effect.numProperties ; j++)
				{
					var oldEffect = oldController.layer.effect(j);
					var newEffect = newController.layer.effect.addProperty(oldEffect.matchName);
					newEffect.name = oldEffect.name;
					//set the properties
					Duik.utils.linkProperties(oldEffect,newEffect);
				}
			
				Duik.utils.linkProperties(oldController.layer.transform,newController.layer.transform);
			}

			if (useProgressBar)
			{
				progressText.text = "Updating expressions";
				containingWindow.update();
			}
			
			//update expressions (controller and zeros names have changed)
			
			for (var i in characterControllers)
			{
				if (useProgressBar)
				{
					progressValue++;
					progressBar.value = progressValue;
					containingWindow.update();
				}
				
				//controllers
				try {
					//check names
					var oldName = characterControllers[i].layer.name;
					var newName = newControllerLayers[i].name;
					//update
					//double quotes
					var old = "layer(\"" + oldName + "\"";
					var newExpr = "layer(\"" + newName + "\"";
					Duik.utils.replaceInLayersExpressions(newControllerLayers,old,newExpr);
					//single quotes
					var old = "layer('" + oldName + "'";
					var newExpr = "layer('" + newName + "'";
					Duik.utils.replaceInLayersExpressions(newControllerLayers,old,newExpr);
				}
				catch (err2) {}
				//zeros
				try {
					//check names
					var oldName = characterZeros[i].name;
					var newName = newZeros[i].name;
					//update
					//double quotes
					var old = "layer(\"" + oldName + "\"";
					var newExpr = "layer(\"" + newName + "\"";
					Duik.utils.replaceInLayersExpressions(newControllerLayers,old,newExpr);
					//single quotes
					var old = "layer('" + oldName + "'";
					var newExpr = "layer('" + newName + "'";
					Duik.utils.replaceInLayersExpressions(newControllerLayers,old,newExpr);
				}
				catch (err2) {}
			}
			
			if (useProgressBar)
			{
				progressText.text = "Linking and locking zeros";
				containingWindow.update();
			}

			//link and lock the zeros in the comp
			for  (var i in characterZeros)
			{
				if (useProgressBar)
				{
					progressValue++;
					progressBar.value = progressValue;
					containingWindow.update();
				}
				var newZero = newZeros[i];
				//Link zero
				if (characterZeros[i].parent != null)
				{
					for (var j = 1 ; j <= comp.numLayers ; j++)
					{
						if (comp.layer(j).name == characterName + "_" + characterZeros[i].parent.name)
						{
							newZero.parent = comp.layer(j);
							break;
						}
					}
				}
				newZero.locked = true;
			}
              
			if (useProgressBar)
			{			  
				progressText.text = "Setting up master controller";
				containingWindow.update();
			}
				
			//And finally, a master ctrl to control them all!
			var masterC = Duik.addController(characterLayer,Duik.settings.controllerType,[1,1,1],false,true,true,true,true,false);
			masterC.layer.transform.position.setValue([masterC.layer.transform.position.value[0],comp.height-20]);
			masterC.layer.name = "MASTER_" + characterName;
			var flip = masterC.layer.effect.addProperty("ADBE Checkbox Control");
			flip.name = Duik.uiStrings.flip;
			masterC.layer.transform.scale.expression = "//Duik.importRig\n" + 
									"var flip = thisLayer.effect(\"" + flip.name + "\")(1).value\n" + 
									"if (flip) [-value[0],value[1]]\n" + 
									"else value";
			characterLayer.parent = masterC.layer;
			characterLayer.locked = true;
			
			containingWindow.hide();
			
			app.endSuppressDialogs(false);
		}
	}
	/* IMPORT RIG IN COMP - Duik.moveAway(layer);

	Rigs the position of the layer to be able to move it away from its parent with a simple slider.

	parameters
		layer | AVLayer
		
	returns
		void
	
	*/
	if (typeof Duik.moveAway !== 'function')
	{
		Duik.moveAway = function (layer)
		{
			if (layer == undefined) return;
			var effect = layer.Effects.addProperty("ADBE Slider Control");
			effect.name = Duik.uiStrings.moveAway;
						
			layer.transform.position.expression = "//Duik.moveAway\n" + 
												"if (thisLayer.hasParent)\n" + 
												"{\n" + 
												"thisWorldPos = thisLayer.toWorld(thisLayer.anchorPoint);\n" + 
												"parentWorldPos = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" + 
												"depl = effect(\"" + effect.name  + "\")(1)\n" + 
												"dist = length(parentWorldPos ,thisWorldPos )\n" + 
												"coef = (dist+depl)/dist\n" + 
												"newWorldPos = (thisWorldPos-parentWorldPos)*coef+parentWorldPos\n" + 
												"thisLayer.parent.fromWorld(newWorldPos)\n" + 
												"}\n" + 
												"else\n" + 
												"{\n" + 
												"value\n" + 
												"}\n";
		}
	}
}());

