/*
Duik - Duduf IK Tools
Copyright (c) 2008 - 2015 Nicolas Dufresne
http://www.duduf.net

Many thanks to :
Dan Ebberts - Writing the first IK Expressions
Eric Epstein - making the IK's work with 3D Layers
David Bau - JavaScript seedRandom function (MIT License)
All 258 indiegogo crowdfunders for making this libDuik possible!

This file is part of Duik.

Duik is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Duik is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Duik. If not, see <http://www.gnu.org/licenses/>.
*/

// =====================================================================
//                                   LibDuik
// =====================================================================
/* This file should not be edited,

If you need to change some settings, you should change them inside your own script.
Example:
Changing controllers size (in pixels):
Duik.settings.controllerSize = 50;

A complete list of settings is available in the developper's guide of libDuik on
http://www.duduf.net

If you need to change UI strings (for localization) you can access them in Duik.uiStrings
Example:
Duik.uiStrings.ikFkBox = "IK / FK"

A complete list of uiStrings is available in the developper's guide of libDuik on
http://www.duduf.net

However, if you're modifying this file, you may want to force reload the class for testing purposes.
Uncomment the first line of the script (FORCE RELOAD section)
if (typeof Duik === 'object') delete Duik;

*/

/////////////////////////////
// FORCE RELOAD
/////////////////////////////
//if (typeof Duik === 'object') delete Duik;

////////////////////////////
// DEFINITIONS
////////////////////////////
{
if (typeof Duik !== 'object')
{
Duik = {};
Duik.versionNumber = 0.0;
}
function KeySpatialProperties ()
{
this.inTangent = null;
this.outTangent = null;
this.continuous = true;
this.autoBezier = false;
this.roving = false;
}
function KeyFrame()
{
this.time = 0;
this.value = null;
this.inInterpolationType = KeyframeInterpolationType.LINEAR;
this.outInterpolationType = KeyframeInterpolationType.LINEAR;
this.spatial = false;
this.spatialProperties = new KeySpatialProperties();
this.inEase = 0;
this.outEase = 0;
this.continuous = false;
this.autoBezier = false;
}
function PropertyAnim()
{
this.name = "";
this.keys = [];
this.startValue = null;
}
function MaskAnim()
{
this.name = "";
this.anims = [];
}
function EffectAnim()
{
this.name = "";
this.matchName = "";
this.anims = [];
}
function LayerAnim()
{
this.name = "";
this.index = 0;
this.transformAnims = [];
this.masksAnims = [];
this.effectsAnims = [];
}
function IKRig()
{
this.type = 0;
this.layer1 = null; //root
this.layer2 = null; //middle
this.layer3 = null; //end
this.goal = null;
this.controller = null;
this.threeD = false;
this.frontFacing = false;
this.clockWise = false;
this.created = false;
}
IKRig.prototype.create = function ()
{
if (this.created) return null;
if (this.type == 1 && this.layer1 != null && this.controller != null)
{
this.created = Duik.oneLayerIK(this.controller,this.layer1);
if (!this.created) return;
if (this.goal != null)
{
if (this.layer1.parent == this.goal) this.layer1.parent = null;
this.goal.parent = this.layer1;
Duik.goal(this.goal,this.controller);
}
}
else if (this.type == 2 && this.layer1 != null && this.layer2 != null && this.controller != null)
{
//parents
if (this.layer1.parent == this.layer2) this.layer1.parent = null;
this.layer2.parent = this.layer1;
//3d
this.threeD = this.controller.threeDLayer && this.layer1.threeDLayer && this.layer2.threeDLayer;
//create
var zero = Duik.twoLayerIK(this.controller,this.layer1,this.layer2,this.clockWise,this.frontFacing);
this.created = true;
//goal
if (this.goal != null)
{
this.goal.parent = this.layer2;
Duik.goal(this.goal,this.controller);
if (zero) this.goal.transform.position.expression = "thisComp.layer('" + zero.name + "').position";
else this.goal.transform.position.expression = "thisComp.layer('" + this.layer2.name + "').effect('" + Duik.uiStrings.ikEnd + "')(1)";
}
}
else if (this.type == 3 && this.layer1 != null && this.layer2 != null && this.layer3 != null && this.controller != null)
{
//parents
if (this.layer2.parent == this.layer3) this.layer2.parent = null;
if (this.layer1.parent == this.layer2) this.layer1.parent = null;
this.layer3.parent = this.layer2;
this.layer2.parent = this.layer1;
//create
var zero = Duik.threeLayerIK(this.controller,this.layer1,this.layer2,this.layer3,this.clockWise);
this.created = true;
//goal
if (this.goal != null)
{
this.goal.parent = this.layer3;
Duik.goal(this.goal,this.controller);
if (zero) this.goal.transform.position.expression = "thisComp.layer('" + zero.name + "').position";
else this.goal.transform.position.expression = "thisComp.layer('" + this.layer3.name + "').effect('" + Duik.uiStrings.ikEnd + "')(1)";
}
}
//move the controller to avoid bugs
this.controller.transform.position.setValue(this.controller.transform.position.value);
}
function PropertyDescription()
{
this.isEffect = false;
this.index = 0;
this.depth = 0;
this.parentName = "";
this.dimensions = 0;
this.canSetExpression = false;
}
function Controller()
{
this.locked = false;
this.xPosition = false;
this.yPosition = false;
this.rotation = false;
this.scale = false;
this.arc = false;
this.eye = false;
this.camera = false;
this.size = 0;
this.color = [1,1,1,1];
this.layer = null;
this.type = Duik.layerTypes.VECTOR;
}
Controller.prototype.lock = function()
{
if (this.layer == null)
{
this.locked = false;
return;
}
//get value
var posValue = this.layer.transform.position.value;
var rotValue = this.layer.transform.rotation.value;
var scaValue = this.layer.transform.scale.value;
if (!this.xPosition && !this.yPosition && !this.eye && !this.camera)
{
if (this.layer.transform.position.canSetExpression)
{
this.layer.transform.position.expression = "[" + posValue[0] + "," + posValue[1] + "]";
}
else
{
this.layer.transform.xPosition.expression = posValue[0];
this.layer.transform.yPosition.expression = posValue[1];
}
}
else if (this.xPosition && !this.yPosition)
{
this.layer.transform.position.expression = "[value[0]," + posValue[1] + "]";
}
else if (this.yPosition && !this.xPosition)
{
this.layer.transform.position.expression = "[" + posValue[0] + ",value[1]]";
}
if (!this.rotation && !this.arc && !this.camera)
{
this.layer.transform.rotation.expression = rotValue;
}
if (!this.scale)
{
this.layer.transform.scale.expression = "[" + scaValue[0] + "," + scaValue[1] + "]";
}
this.locked = true;
}
Controller.prototype.unlock = function()
{
if (this.layer == null)
{
this.locked = false;
return;
}
//get value
var posValue = this.layer.transform.position.value;
var rotValue = this.layer.transform.rotation.value;
var scaValue = this.layer.transform.scale.value;
this.layer.transform.position.expression = "";
this.layer.transform.position.setValue(posValue);
this.layer.transform.rotation.expression = "";
this.layer.transform.rotation.setValue(rotValue);
this.layer.transform.scale.expression = "";
this.layer.transform.scale.setValue(scaValue);
this.locked = false;
}
Controller.prototype.update = function()
{
if (this.type != Duik.layerTypes.VECTOR || this.layer == null) return;

var iconGroup = this.layer.property("ADBE Root Vectors Group")("Icon");
if (iconGroup != null) iconGroup.remove();

//controller size
var controllerSize = this.size;
if (controllerSize == 0)
{
controllerSize = this.layer.containingComp.width/2 + this.layer.containingComp.height/2;
if (Duik.settings.controllerSizeHint == Duik.sizes.SMALL) controllerSize = Math.floor(controllerSize/40)*100/30;
else if (Duik.settings.controllerSizeHint == Duik.sizes.MEDIUM) controllerSize = Math.floor(controllerSize/20)*100/30;
else if (Duik.settings.controllerSizeHint == Duik.sizes.BIG) controllerSize = Math.floor(controllerSize/10)*100/30;
this.size = controllerSize;
}

if (this.arc || this.eye || this.camera)
{
this.xPosition = false;
this.yPosition = false;
this.rotation = false;
this.scale = false;
}

iconGroup = this.layer("ADBE Root Vectors Group").addProperty("ADBE Vector Group");
iconGroup.name = "Icon";
controllerSizeFactor = controllerSize;
iconGroup("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([controllerSizeFactor,controllerSizeFactor]);
if (this.rotation)
{
//draw
var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
group.name = "Rotation";
var groupContent = group.property("ADBE Vectors Group");
var ellipse = groupContent.addProperty("ADBE Vector Shape - Ellipse");
ellipse("ADBE Vector Ellipse Size").setValue([30,30]);
var trim = groupContent.addProperty("ADBE Vector Filter - Trim");
trim("ADBE Vector Trim End").setValue(85);
var arrowShape = new Shape();
arrowShape.vertices = [[0,-15], [10,-20]];
arrowShape.closed = false;
var arrow = groupContent.addProperty("ADBE Vector Shape - Group");
arrow("ADBE Vector Shape").setValue(arrowShape);
arrow("ADBE Vector Shape").expression = "value";
var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
stroke("ADBE Vector Stroke Color").setValue(this.color);
stroke("ADBE Vector Stroke Width").setValue(2);
group("ADBE Vector Transform Group")("ADBE Vector Rotation").setValue(-20);
}
if (this.xPosition)
{
var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
group.name = "xPosition";
var groupContent = group.property("ADBE Vectors Group");
var horizontalShape = new Shape();
horizontalShape.vertices = [[15,0], [-15,0]];
horizontalShape.closed = false;
var horizontal = groupContent.addProperty("ADBE Vector Shape - Group");
horizontal("ADBE Vector Shape").setValue(horizontalShape);
horizontal("ADBE Vector Shape").expression = "value";
var arrowShape1 = new Shape();
arrowShape1.vertices = [[10,-7],[15,0], [10,7]];
arrowShape1.closed = false;
var arrow1 = groupContent.addProperty("ADBE Vector Shape - Group");
arrow1("ADBE Vector Shape").setValue(arrowShape1);
arrow1("ADBE Vector Shape").expression = "value";
var arrowShape2 = new Shape();
arrowShape2.vertices = [[-10,7],[-15,0], [-10,-7]];
arrowShape2.closed = false;
var arrow2 = groupContent.addProperty("ADBE Vector Shape - Group");
arrow2("ADBE Vector Shape").setValue(arrowShape2);
arrow2("ADBE Vector Shape").expression = "value";
var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
stroke("ADBE Vector Stroke Color").setValue(this.color);
if (this.rotation) stroke("ADBE Vector Stroke Width").setValue(2);
else stroke("ADBE Vector Stroke Width").setValue(2);
if (this.rotation) group("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([70,70]);
}
if (this.yPosition)
{
var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
group.name = "yPosition";
var groupContent = group.property("ADBE Vectors Group");
var verticalShape = new Shape();
verticalShape.vertices = [[0,-15], [0,15]];
verticalShape.closed = false;
var vertical = groupContent.addProperty("ADBE Vector Shape - Group");
vertical("ADBE Vector Shape").setValue(verticalShape);
vertical("ADBE Vector Shape").expression = "value";
var arrowShape3 = new Shape();
arrowShape3.vertices = [[-7,10],[0,15], [7,10]];
arrowShape3.closed = false;
var arrow3 = groupContent.addProperty("ADBE Vector Shape - Group");
arrow3("ADBE Vector Shape").setValue(arrowShape3);
arrow3("ADBE Vector Shape").expression = "value";
var arrowShape4 = new Shape();
arrowShape4.vertices = [[-7,-10],[0,-15], [7,-10]];
arrowShape4.closed = false;
var arrow4 = groupContent.addProperty("ADBE Vector Shape - Group");
arrow4("ADBE Vector Shape").setValue(arrowShape4);
arrow4("ADBE Vector Shape").expression = "value";
var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
stroke("ADBE Vector Stroke Color").setValue(this.color);
if (this.rotation) stroke("ADBE Vector Stroke Width").setValue(2);
else stroke("ADBE Vector Stroke Width").setValue(2);
if (this.rotation) group("ADBE Vector Transform Group")("ADBE Vector Scale").setValue([70,70]);
}
if (this.scale)
{
var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
group.name = "Scale";
var groupContent = group.property("ADBE Vectors Group");
var cornerShape1 = new Shape();
cornerShape1.vertices = [[-10,-20],[-20,-20], [-20,-10]];
cornerShape1.closed = false;
var corner1 = groupContent.addProperty("ADBE Vector Shape - Group");
corner1("ADBE Vector Shape").setValue(cornerShape1);
corner1("ADBE Vector Shape").expression = "value";
var cornerShape2 = new Shape();
cornerShape2.vertices = [[10,-20],[20,-20], [20,-10]];
cornerShape2.closed = false;
var corner2 = groupContent.addProperty("ADBE Vector Shape - Group");
corner2("ADBE Vector Shape").setValue(cornerShape2);
corner2("ADBE Vector Shape").expression = "value";
var cornerShape3 = new Shape();
cornerShape3.vertices = [[10,20],[20,20], [20,10]];
cornerShape3.closed = false;
var corner3 = groupContent.addProperty("ADBE Vector Shape - Group");
corner3("ADBE Vector Shape").setValue(cornerShape3);
corner3("ADBE Vector Shape").expression = "value";
var cornerShape4 = new Shape();
cornerShape4.vertices = [[-10,20],[-20,20], [-20,10]];
cornerShape4.closed = false;
var corner4 = groupContent.addProperty("ADBE Vector Shape - Group");
corner4("ADBE Vector Shape").setValue(cornerShape4);
corner4("ADBE Vector Shape").expression = "value";
var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
stroke("ADBE Vector Stroke Color").setValue(this.color);
stroke("ADBE Vector Stroke Width").setValue(2);
}
if (this.arc)
{
var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
group.name = "Arc";
var groupContent = group.property("ADBE Vectors Group");
var ellipse = groupContent.addProperty("ADBE Vector Shape - Ellipse");
ellipse("ADBE Vector Ellipse Size").setValue([30,30]);
var trim = groupContent.addProperty("ADBE Vector Filter - Trim");
trim("ADBE Vector Trim End").setValue(35);
var arrowShape = new Shape();
arrowShape.vertices = [[0,-15], [10,-20]];
arrowShape.closed = false;
var arrow = groupContent.addProperty("ADBE Vector Shape - Group");
arrow("ADBE Vector Shape").setValue(arrowShape);
arrow("ADBE Vector Shape").expression = "value";
var stroke = groupContent.addProperty("ADBE Vector Graphic - Stroke");
stroke("ADBE Vector Stroke Color").setValue(this.color);
stroke("ADBE Vector Stroke Width").setValue(2);
group("ADBE Vector Transform Group")("ADBE Vector Rotation").setValue(-60);
}
if (this.eye)
{
var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
group.name = "Eye";
var groupContent = group.property("ADBE Vectors Group");

var eyeGroup = groupContent.addProperty("ADBE Vector Group");
eyeGroup.name = "eye";
var eyeGroupContent = eyeGroup.property("ADBE Vectors Group");
var eye = eyeGroupContent.addProperty("ADBE Vector Shape - Group");
var eyeShape = new Shape();
eyeShape.vertices = [[-12,0], [12,0]];
eyeShape.inTangents = [[0,0], [-12,12]];
eyeShape.outTangents = [[0,0], [-12,-12]];
eyeShape.closed = true;
eye("ADBE Vector Shape").setValue(eyeShape);
eye("ADBE Vector Shape").expression = "value";
var pupil = eyeGroupContent.addProperty("ADBE Vector Shape - Ellipse");
pupil("ADBE Vector Ellipse Size").setValue([7,7]);
var fill = eyeGroupContent.addProperty("ADBE Vector Graphic - Fill");
fill("ADBE Vector Fill Color").setValue(this.color);

var xGroup = groupContent.addProperty("ADBE Vector Group");
xGroup.name = "xPosition";
var xGroupContent = xGroup.property("ADBE Vectors Group");
var arrowShape1 = new Shape();
arrowShape1.vertices = [[10,-7],[15,0], [10,7]];
arrowShape1.closed = false;
var arrow1 = xGroupContent.addProperty("ADBE Vector Shape - Group");
arrow1("ADBE Vector Shape").setValue(arrowShape1);
arrow1("ADBE Vector Shape").expression = "value";
var arrowShape2 = new Shape();
arrowShape2.vertices = [[-10,7],[-15,0], [-10,-7]];
arrowShape2.closed = false;
var arrow2 = xGroupContent.addProperty("ADBE Vector Shape - Group");
arrow2("ADBE Vector Shape").setValue(arrowShape2);
arrow2("ADBE Vector Shape").expression = "value";
var stroke = xGroupContent.addProperty("ADBE Vector Graphic - Stroke");
stroke("ADBE Vector Stroke Color").setValue(this.color);
stroke("ADBE Vector Stroke Width").setValue(2);

var yGroup = groupContent.addProperty("ADBE Vector Group");
yGroup.name = "yPosition";
var yGroupContent = yGroup.property("ADBE Vectors Group");
var arrowShape3 = new Shape();
arrowShape3.vertices = [[-7,10],[0,15], [7,10]];
arrowShape3.closed = false;
var arrow3 = yGroupContent.addProperty("ADBE Vector Shape - Group");
arrow3("ADBE Vector Shape").setValue(arrowShape3);
arrow3("ADBE Vector Shape").expression = "value";
var arrowShape4 = new Shape();
arrowShape4.vertices = [[-7,-10],[0,-15], [7,-10]];
arrowShape4.closed = false;
var arrow4 = yGroupContent.addProperty("ADBE Vector Shape - Group");
arrow4("ADBE Vector Shape").setValue(arrowShape4);
arrow4("ADBE Vector Shape").expression = "value";
var stroke = yGroupContent.addProperty("ADBE Vector Graphic - Stroke");
stroke("ADBE Vector Stroke Color").setValue(this.color);
stroke("ADBE Vector Stroke Width").setValue(2);

}
if (this.camera)
{
var group = iconGroup("ADBE Vectors Group").addProperty("ADBE Vector Group");
group.name = "Camera";
var groupContent = group.property("ADBE Vectors Group");

var cam = groupContent.addProperty("ADBE Vector Shape - Group");
var camShape = new Shape();
camShape.vertices = [[-15,-7], [-5,-3], [-5,-7], [15,-7], [15,7], [-5,7], [-5,3], [-15,7]];
camShape.closed = true;
cam("ADBE Vector Shape").setValue(camShape);
cam("ADBE Vector Shape").expression = "value";
var reel1 = groupContent.addProperty("ADBE Vector Shape - Ellipse");
reel1("ADBE Vector Ellipse Size").setValue([15,15]);
reel1("ADBE Vector Ellipse Position").setValue([12,-10]);
var reel2 = groupContent.addProperty("ADBE Vector Shape - Ellipse");
reel2("ADBE Vector Ellipse Size").setValue([10,10]);
reel2("ADBE Vector Ellipse Position").setValue([-2,-10]);
var fill = groupContent.addProperty("ADBE Vector Graphic - Fill");
fill("ADBE Vector Fill Color").setValue(this.color);
}
}
function TVPCamera ()
{
this.points = [];
this.pointCout = 0;
this.profileprof = new TVPProfileprof();
}
function TVPCameraPoint ()
{
this.x = 0.0;
this.y = 0.0;
this.zoom = 1.0;
this.rotation = 0.0;
}
function TVPProfileprof ()
{
this.points = [];
this.linear = false;
this.pointCount = 0;
}
function TVPProfileprofPoint ()
{
this.u = 0.0;
this.v = 0.0;
}
TVPCamera.prototype.createNull = function(comp,link,useAnchorPoint)
{
var camLayer = comp.layers.addNull();
camLayer.name = "TVPaint Camera";
this.applyToLayer(camLayer,link,useAnchorPoint);
}
TVPCamera.prototype.precompose = function(comp,useAnchorPoint)
{
var tvpComp = app.project.items.addComp("TVPaint Camera",comp.width, comp.height, comp.pixelAspect, comp.duration, comp.frameRate)
var camLayer = tvpComp.layers.add(comp);
this.applyToLayer(camLayer,false,useAnchorPoint);
}
TVPCamera.prototype.applyToLayer = function(camLayer,link,useAnchorPoint)
{
var comp = camLayer.containingComp;
var numPoints = this.pointCount;

if (link == undefined) link = false;
if (useAnchorPoint == undefined) useAnchorPoint = false;

var moveProp = camLayer.transform.anchorPoint;
var rotationLayer = camLayer;

// Move
if (!useAnchorPoint)
{
moveProp = camLayer.transform.position;
rotationLayer = camLayer.containingComp.layers.addNull();
rotationLayer.name = "TVPaint Rotation & Scale";
}
var startPos = camLayer.transform.position.value;
var intialDif = [0,0];
for (var i = 0;i< numPoints;i++)
{
var point = this.points[i];
var time = (comp.duration-comp.frameDuration)/(numPoints-1)*i;

if (i == 0) initialDif = startPos - [point.x,point.y];
var val;
useAnchorPoint ? val = [point.x,point.y] : val = 2*startPos-[point.x,point.y]-initialDif;

moveProp.setValueAtTime(time,val);

if (i == 0 || i == numPoints-1)
{
moveProp.setSpatialTangentsAtKey(i+1,[0,0,0],[0,0,0]);
}
else
{
moveProp.setSpatialAutoBezierAtKey(i+1,true);
var inTangent = moveProp.keyInSpatialTangent(i+1);
var outTangent = moveProp.keyOutSpatialTangent(i+1);
}
}

//rotation & scale
for (var i =0; i < numPoints;i++)
{
var point = this.points[i];
moveProp.setRovingAtKey(i+1,true);
time = moveProp.keyTime(i+1);
rotationLayer.transform.rotation.setValueAtTime(time,point.rotation);
var zoom = (1+(1-point.zoom))*100;
rotationLayer.transform.scale.setValueAtTime(time,[zoom,zoom,zoom]);
}

//Morpher
var morpher = camLayer.Effects.addProperty("ADBE Slider Control");
morpher.name = "Morpher";

var exp = "valueAtTime((thisComp.layer(\"" + camLayer.name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
moveProp.expression = exp;
rotationLayer.transform.rotation.expression = exp;
rotationLayer.transform.scale.expression = exp;

//add morpher keys
var numProfPoints = this.profileprof.pointCount;
for (var i = 0;i<numProfPoints;i++)
{
var point = this.profileprof.points[i];
morpher(1).setValueAtTime((comp.duration-comp.frameDuration)*point.u,(comp.duration-comp.frameDuration)/comp.frameDuration*point.v);
}
//bezier
if (!this.profileprof.linear)
{
for (var i = 1;i<= morpher(1).numKeys;i++)
{
morpher(1).setInterpolationTypeAtKey(i,KeyframeInterpolationType.BEZIER);
if (i != 1 && i != morpher(1).numKeys)
{
morpher(1).setTemporalContinuousAtKey(i, true);
morpher(1).setTemporalAutoBezierAtKey(i, true);
}
else
{
var easeIn = new KeyframeEase(0,100/3);
morpher(1).setTemporalEaseAtKey(i,[easeIn]);
}
}
}

if (!useAnchorPoint) camLayer.parent = rotationLayer;

if (link)
{
for (var i = 1;i<=comp.numLayers;i++)
{
if (i == camLayer.index || i == rotationLayer.index) continue;
if (comp.layer(i).parent == null) comp.layer(i).parent = camLayer;
}
}
}
function OnionSkin()
{
this.activated = false;
this.duration = 5;
this.inOpacity = 0;
this.outOpacity = 50;
this.exposure = 2;
}
}

/////////////////////////////
// INITIALIZATION
/////////////////////////////
(function ()
{
if (Duik.versionNumber != 15.11)
{
delete Duik;
Duik = {};
Duik.version = "15.11";
Duik.versionNumber = 15.11;
Duik.usePresets = true;
Duik.presetPath = $.fileName.substring(0,$.fileName.lastIndexOf("/")) + "/";
Duik.presetEffectsInstalledVersion = 0.0;
Duik.copiedAnim = [];
Duik.detectedExposure = [];
Duik.sizes = {};
Duik.sizes.SMALL = 0;
Duik.sizes.MEDIUM = 1;
Duik.sizes.BIG = 2;
Duik.layerTypes = {};
Duik.layerTypes.VECTOR = 2;
Duik.layerTypes.NULL = 1;
Duik.layerTypes.SOLID = 0;
Duik.getLayers = {};
Duik.getLayers.INDEX = 0;
Duik.getLayers.NAME = 1;
Duik.getLayers.SELECTION_INDEX = 2;
Duik.placement = {};
Duik.placement.TOP = 0;
Duik.placement.BOTTOM = 1;
Duik.placement.OVER_LAYER = 2;
Duik.placement.UNDER_LAYER = 3;
Duik.colors = {};
Duik.colors.WHITE = [1,1,1,1];
Duik.colors.RED = [1,0,0,1];
Duik.colors.GREEN = [0,1,0,1];
Duik.colors.BLUE = [0,0,1,1];
Duik.colors.CYAN = [0,1,1,1];
Duik.colors.MAGENTA = [1,0,1,1];
Duik.colors.YELLOW = [1,1,0,1];
Duik.colors.BLACK = [0,0,0,1];
Duik.colors.LIGHT_GRAY = [0.75,0.75,0.75,1];
Duik.colors.DARK_GRAY = [0.25,0.25,0.25,1];
Duik.effects = {};
Duik.effects.One_Layer_IK = 'PSEUDO/DUIK_One_Layer_IK';
Duik.effects.One_Layer_IK.ffx = 'DUIK_One_Layer_IK';
Duik.effects.Two_Layer_IK = 'PSEUDO/DUIK_Two_Layer_IK_v2';
Duik.effects.Two_Layer_IK.ffx = 'DUIK_Two_Layer_IK_v2';
Duik.effects.Three_Layer_IK = 'PSEUDO/DUIK_Three_Layer_IK_v2';
Duik.effects.Three_Layer_IK.ffx = 'DUIK_Three_Layer_IK_v2';
Duik.effects.ThreeD_Wiggle = 'PSEUDO/DUIK_3D_Wiggle';
Duik.effects.ThreeD_Wiggle.ffx = 'DUIK_3D_Wiggle';
Duik.effects.TwoD_Wiggle = 'PSEUDO/DUIK_2D_Wiggle';
Duik.effects.TwoD_Wiggle.ffx = 'DUIK_2D_Wiggle';
Duik.effects.OneD_Wiggle = 'PSEUDO/DUIK_1D_Wiggle';
Duik.effects.OneD_Wiggle.ffx = 'DUIK_1D_Wiggle';
Duik.effects.Exposure = 'PSEUDO/DUIK_Exposure';
Duik.effects.Exposure.ffx = 'DUIK_Exposure';
Duik.effects.RotMorph = 'PSEUDO/DUIK_RotMorph';
Duik.effects.RotMorph.ffx = 'DUIK_RotMorph';
Duik.effects.Swing = 'PSEUDO/DUIK_Swing';
Duik.effects.Swing.ffx = 'DUIK_Swing';
Duik.effects.Wheel = 'PSEUDO/DUIK_Wheel';
Duik.effects.Wheel.ffx = 'DUIK_Wheel';
Duik.effects.LensFlare = 'PSEUDO/DUIK_LensFlare';
Duik.effects.LensFlare.ffx = 'DUIK_LensFlare';
Duik.effects.LensFlareDistance = 'PSEUDO/DUIK_LensFlareDistance';
Duik.effects.LensFlareDistance.ffx = 'DUIK_LensFlareDistance';
Duik.effects.DistanceLink = 'PSEUDO/DUIK_DistanceLink';
Duik.effects.DistanceLink.ffx = 'DUIK_DistanceLink';
Duik.effects.Spring = 'PSEUDO/DUIK_Spring';
Duik.effects.Spring.ffx = 'DUIK_Spring';
Duik.effects.Spring_Bounce = 'PSEUDO/DUIK_Spring_Bounce';
Duik.effects.Spring_Bounce.ffx = 'DUIK_Spring_Bounce';
Duik.effects.Paint_Rig = 'PSEUDO/DUIK_Paint_Rig';
Duik.effects.Paint_Rig.ffx = 'DUIK_Paint_Rig';
Duik.effects.Blink_1D = 'PSEUDO/DUIK_Blink_1D';
Duik.effects.Blink_1D.ffx = 'DUIK_Blink_1D';
Duik.effects.Blink_2D = 'PSEUDO/DUIK_Blink_2D';
Duik.effects.Blink_2D.ffx = 'DUIK_Blink_2D';
Duik.effects.Blink_3D = 'PSEUDO/DUIK_Blink_3D';
Duik.effects.Blink_3D.ffx = 'DUIK_Blink_3D';
Duik.effects.Multiplane = 'PSEUDO/DUIK_Multiplane';
Duik.effects.Multiplane.ffx = 'DUIK_Multiplane';
Duik.effects.Paint_Group = 'PSEUDO/DUIK_Paint_Group';
Duik.effects.Paint_Group.ffx = 'DUIK_Paint_Group';
Duik.effects.OneD_List = 'PSEUDO/DUIK_1D_List';
Duik.effects.OneD_List.ffx = 'DUIK_1D_List';
Duik.effects.TwoD_List = 'PSEUDO/DUIK_2D_List';
Duik.effects.TwoD_List.ffx = 'DUIK_2D_List';
Duik.effects.ThreeD_List = 'PSEUDO/DUIK_3D_List';
Duik.effects.ThreeD_List.ffx = 'DUIK_3D_List';
Duik.effects.Bezier_IK = 'PSEUDO/DUIK_Bezier_IK';
Duik.effects.Bezier_IK.ffx = 'DUIK_Bezier_IK';
Duik.effects.Foot_Roll = 'PSEUDO/DUIK_Foot_Roll';
Duik.effects.Foot_Roll.ffx = 'DUIK_Foot_Roll';
Duik.expressions = {};
// Associative array that converts property match names to their compact English expression statements.
// For simple conversions, quote the result!
Duik.expressions.compactExpressions =
	{
		"ADBE Transform Group":"'transform'",
		// Handle camera/light vs. AV layers
		"ADBE Anchor Point":"((prop.propertyGroup(prop.propertyDepth).property('intensity')!=null) || (prop.propertyGroup(prop.propertyDepth).property('zoom')!=null)) ? '.pointOfInterest' : '.anchorPoint'",
		"ADBE Position":"'.position'",
		"ADBE Scale":"'.scale'",
		"ADBE Orientation":"'.orientation'",
		"ADBE Rotate X":"'.xRotation'",
		"ADBE Rotate Y":"'.yRotation'",
		// Handle 3D vs. 2D layers
		"ADBE Rotate Z":"(prop.propertyGroup(prop.propertyDepth).threeDLayer || (prop.propertyGroup(prop.propertyDepth).property('intensity')!=null) || (prop.propertyGroup(prop.propertyDepth).property('zoom')!=null)) ? '.zRotation' : '.rotation'",
		"ADBE Opacity":"'.opacity'",
		"ADBE Material Options Group":"'materialOption'",
		"ADBE Casts Shadows":"'.castsShadows'",
		"ADBE Light Transmission":"'.lightTransmission'",
		"ADBE Accepts Shadows":"'.acceptsShadows'",
		"ADBE Accepts Lights":"'.acceptsLights'",
		"ADBE Ambient Coefficient":"'.ambient'",
		"ADBE Diffuse Coefficient":"'.diffuse'",
		"ADBE Specular Coefficient":"'.specular'",
		"ADBE Shininess Coefficient":"'.shininess'",
		"ADBE Metal Coefficient":"'.metal'",
		"ADBE Light Options Group":"'lightOption'",
		"ADBE Light Intensity":"'.intensity'",
		"ADBE Light Color":"'.color'",
		"ADBE Light Cone Angle":"'.coneAngle'",
		"ADBE Light Cone Feather 2":"'.coneFeather'",
		"ADBE Light Shadow Darkness":"'.shadowDarkness'",
		"ADBE Light Shadow Diffusion":"'.shadowDiffusion'",
		"ADBE Camera Options Group":"'cameraOption'",
		"ADBE Camera Zoom":"'.zoom'",
		"ADBE Camera Depth of Field":"'.depthOfField'",
		"ADBE Camera Focus Distance":"'.focusDistance'",
		"ADBE Camera Aperture":"'.aperture'",
		"ADBE Camera Blur Level":"'.blurLevel'",
		"ADBE Text Properties":"'text'",
		"ADBE Text Document":"'.sourceText'",
		"ADBE Text Path Options":"'.pathOption'",
		"ADBE Text Path":"'.path'",
		"ADBE Text Reverse Path":"'.reversePath'",
		"ADBE Text Perpendicular To Path":"'.perpendicularToPath'",
		"ADBE Text Force Align Path":"'.forceAlignment'",
		"ADBE Text First Margin":"'.firstMargin'",
		"ADBE Text Last Margin":"'.lastMargin'",
		"ADBE Text More Options":"'.moreOption'",
		"ADBE Text Anchor Point Option":"'.anchorPointGrouping'",
		"ADBE Text Anchor Point Align":"'.groupingAlignment'",
		"ADBE Text Render Order":"'.fillANdStroke'",
		"ADBE Text Character Blend Mode":"'.interCharacterBlending'",
		"ADBE Text Animators":"'.animator'",
		"ADBE Text Selectors":"'.selector'",
		"ADBE Text Percent Start":"'.start'",
		"ADBE Text Percent End":"'.end'",
		"ADBE Text Percent Offset":"'.offset'",
		"ADBE Text Index Start":"'.start'",
		"ADBE Text Index End":"'.end'",
		"ADBE Text Index Offset":"'.offset'",
		"ADBE Text Range Advanced":"'.advanced'",
		"ADBE Text Range Units":"'.units'",
		"ADBE Text Range Type2":"'.basedOn'",
		"ADBE Text Selector Mode":"'.mode'",
		"ADBE Text Selector Max Amount":"'.amount'",
		"ADBE Text Range Shape":"'.shape'",
		"ADBE Text Selector Smoothness":"'.smoothness'",
		"ADBE Text Levels Max Ease":"'.easeHigh'",
		"ADBE Text Levels Min Ease":"'.easeLow'",
		"ADBE Text Randomize Order":"'.randomizeOrder'",
		"ADBE Text Random Seed":"'.randomSeed'",
		"ADBE Text Selector Mode":"'.mode'",
		"ADBE Text Wiggly Max Amount":"'.maxAmount'",
		"ADBE Text Wiggly Min Amount":"'.minAmount'",
		"ADBE Text Range Type2":"'.basedOn'",
		"ADBE Text Temporal Freq":"'.wigglesSecond'",
		"ADBE Text Character Correlation":"'.correlation'",
		"ADBE Text Temporal Phase":"'.temporalPhase'",
		"ADBE Text Spatial Phase":"'.spatialPhase'",
		"ADBE Text Wiggly Lock Dim":"'.lockDimensions'",
		"ADBE Text Wiggly Random Seed":"'.randomSeed'",
		"ADBE Text Range Type2":"'.basedOn'",
		"ADBE Text Expressible Amount":"'.amount'",
		"ADBE Text Animator Properties":"'.property'",
		"ADBE Text Anchor Point 3D":"'.anchorPoint'",
		"ADBE Text Position 3D":"'.position'",
		"ADBE Text Scale 3D":"'.scale'",
		"ADBE Text Skew":"'.skew'",
		"ADBE Text Skew Axis":"'.skewAxis'",
		"ADBE Text Rotation X":"'.xRotation'",
		"ADBE Text Rotation Y":"'.yRotation'",
		"ADBE Text Rotation":"'.zRotation'",
		"ADBE Text Opacity":"'.opacity'",
		"ADBE Text Fill Opacity":"'.fillOpacity'",
		"ADBE Text Fill Color":"'.fillColor'",
		"ADBE Text Fill Hue":"'.fillHue'",
		"ADBE Text Fill Saturation":"'.fillSaturation'",
		"ADBE Text Fill Brightness":"'.fillBrightness'",
		"ADBE Text Stroke Opacity":"'.strokeOpacity'",
		"ADBE Text Stroke Color":"'.strokeColor'",
		"ADBE Text Stroke Hue":"'.strokeHue'",
		"ADBE Text Stroke Saturation":"'.strokeSaturation'",
		"ADBE Text Stroke Brightness":"'.strokeBrightness'",
		"ADBE Text Stroke Width":"'.strokeWidth'",
		"ADBE Text Line Anchor":"'.lineAnchor'",
		"ADBE Text Line Spacing":"'.lineSpacing'",
		"ADBE Text Track Type":"'.trackingType'",
		"ADBE Text Tracking Amount":"'.trackingAmount'",
		"ADBE Text Character Change Type":"'.characterAlignment'",
		"ADBE Text Character Range":"'.characterRange'",
		"ADBE Text Character Replace":"'.characterValue'",
		"ADBE Text Character Offset":"'.characterOffset'",
		"ADBE Text Blur":"'.blur'",
		"ADBE Mask Parade":"'mask'",
		"ADBE Mask Shape":"'.maskPath'",
		"ADBE Mask Feather":"'.maskFeather'",
		"ADBE Mask Opacity":"'.maskOpacity'",
		"ADBE Mask Offset":"'.maskExpansion'",
		"ADBE Effect Parade":"'effect'",
		"ADBE Paint Group":"'.stroke'",
		"ADBE Paint Shape":"'.path'",
		"ADBE Paint Properties":"'.strokeOption'",
		"ADBE Paint Begin":"'.start'",
		"ADBE Paint End":"'.end'",
		"ADBE Paint Color":"'.color'",
		"ADBE Paint Diameter":"'.diameter'",
		"ADBE Paint Angle":"'.angle'",
		"ADBE Paint Hardness":"'.hardness'",
		"ADBE Paint Roundness":"'.roundness'",
		"ADBE Paint Tip Spacing":"'.spacing'",
		"ADBE Paint Target Channels":"'.channels'",
		"ADBE Paint Opacity":"'.opacity'",
		"ADBE Paint Flow":"'.flow'",
		"ADBE Paint Clone Layer":"'.cloneSource'",
		"ADBE Paint Clone Position":"'.clonePosition'",
		"ADBE Paint Clone Time":"'.cloneTime'",
		"ADBE Paint Clone Time Shift":"'.cloneTimeShift'",
		"ADBE Paint Transform":"'.transform'",
		"ADBE Paint Anchor Point":"'.anchorPoint'",
		"ADBE Paint Position":"'.position'",
		"ADBE Paint Scale":"'.scale'",
		"ADBE Paint Rotation":"'.rotation'",		
		"ADBE MTrackers":"'motionTracker'",
		"ADBE MTracker Pt Feature Center":"'.featureCenter'",
		"ADBE MTracker Pt Feature Size":"'.featureSize'",
		"ADBE MTracker Pt Search Ofst":"'.searchOffset'",
		"ADBE MTracker Pt Search Size":"'.searchSize'",
		"ADBE MTracker Pt Confidence":"'.confidence'",
		"ADBE MTracker Pt Attach Pt":"'.attachPoint'",
		"ADBE MTracker Pt Attach Pt Ofst":"'.attachPointOffset'",
		"ADBE Audio Group":"'audio'",
		"ADBE Audio Levels":"'.audioLevels'",
		"ADBE Time Remapping":"'timeRemap'",
		"ADBE Layer Styles":"'layerStyle'",
		"ADBE Blend Options Group":"'.blendingOption'",
			"ADBE Global Angle2":"'.globalLightAngle'",
			"ADBE Global Altitude2":"'.globalLightAltitude'",
			"ADBE Adv Blend Group":"'.advancedBlending'",
			"ADBE Layer Fill Opacity2":"'.fillOpacity'",
			"ADBE R Channel Blend":"'.red'",
			"ADBE G Channel Blend":"'.green'",
			"ADBE B Channel Blend":"'.blue'",
			"ADBE Blend Interior":"'.blendInteriorStylesAsGroup'",
			"ADBE Blend Ranges":"'.useBlendRangesFromSource'",
		"dropShadow/enabled":"'.dropShadow'",
			"dropShadow/mode2":"'.blendMode'",
			"dropShadow/color":"'.color'",
			"dropShadow/opacity":"'.opacity'",
			"dropShadow/useGlobalAngle":"'.useGlobalLight'",
			"dropShadow/localLightingAngle":"'.angle'",
			"dropShadow/distance":"'.distance'",
			"dropShadow/chokeMatte":"'.spread'",
			"dropShadow/blur":"'.size'",
			"dropShadow/noise":"'.noise'",
			"dropShadow/layerConceals":"'.layerKnocksOutDropShadow'",
		"innerShadow/enabled":"'.innerShadow'",
			"innerShadow/mode2":"'.blendMode'",
			"innerShadow/color":"'.color'",
			"innerShadow/opacity":"'.opacity'",
			"innerShadow/useGlobalAngle":"'.useGlobalLight'",
			"innerShadow/localLightingAngle":"'.angle'",
			"innerShadow/distance":"'.distance'",
			"innerShadow/chokeMatte":"'.choke'",
			"innerShadow/blur":"'.size'",
			"innerShadow/noise":"'.noise'",
		"outerGlow/enabled":"'.outerGlow'",
			"outerGlow/mode2":"'.blendMode'",
			"outerGlow/opacity":"'.opacity'",
			"outerGlow/noise":"'.noise'",
			"outerGlow/AEColorChoice":"'.colorType'",
			"outerGlow/color":"'.color'",
			"outerGlow/gradientSmoothness":"'.gradientSmoothness'",
			"outerGlow/glowTechnique":"'.technique'",
			"outerGlow/chokeMatte":"'.spread'",
			"outerGlow/blur":"'.size'",
			"outerGlow/inputRange":"'.range'",
			"outerGlow/shadingNoise":"'.jitter'",
		"innerGlow/enabled":"'.innerGlow'",
			"innerGlow/mode2":"'.blendMode'",
			"innerGlow/opacity":"'.opacity'",
			"innerGlow/noise":"'.noise'",
			"innerGlow/AEColorChoice":"'.colorType'",
			"innerGlow/color":"'.color'",
			"innerGlow/gradientSmoothness":"'.gradientSmoothness'",
			"innerGlow/glowTechnique":"'.technique'",
			"innerGlow/innerGlowSource":"'.source'",
			"innerGlow/chokeMatte":"'.choke'",
			"innerGlow/blur":"'.size'",
			"innerGlow/inputRange":"'.range'",
			"innerGlow/shadingNoise":"'.jitter'",
		"bevelEmboss/enabled":"'.bevelAndEmboss'",
			"bevelEmboss/bevelStyle":"'.style'",
			"bevelEmboss/bevelTechnique":"'.technique'",
			"bevelEmboss/strengthRatio":"'.depth'",
			"bevelEmboss/bevelDirection":"'.direction'",
			"bevelEmboss/blur":"'.size'",
			"bevelEmboss/softness":"'.soften'",
			"bevelEmboss/useGlobalAngle":"'.useGlobalLight'",
			"bevelEmboss/localLightingAngle":"'.angle'",
			"bevelEmboss/localLightingAltitude":"'.altitude'",
			"bevelEmboss/highlightMode":"'.highlightMode'",
			"bevelEmboss/highlightColor":"'.highlightColor'",
			"bevelEmboss/highlightOpacity":"'.highlightOpacity'",
			"bevelEmboss/shadowMode":"'.shadowMode'",
			"bevelEmboss/shadowColor":"'.shadowColor'",
			"bevelEmboss/shadowOpacity":"'.shadowOpacity'",
		"chromeFX/enabled":"'.satin'",
			"chromeFX/mode2":"'.blendMode'",
			"chromeFX/color":"'.color'",
			"chromeFX/opacity":"'.opacity'",
			"chromeFX/localLightingAngle":"'.angle'",
			"chromeFX/distance":"'.distance'",
			"chromeFX/blur":"'.size'",
			"chromeFX/invert":"'.invert'",
		"solidFill/enabled":"'.colorOverlay'",
			"solidFill/mode2":"'.blendMode'",
			"solidFill/color":"'.color'",
			"solidFill/opacity":"'.opacity'",
		"gradientFill/enabled":"'.gradientOverlay'",
			"gradientFill/mode2":"'.blendMode'",
			"gradientFill/opacity":"'.opacity'",
			"gradientFill/gradientSmoothness":"'.gradientSmoothness'",
			"gradientFill/angle":"'.angle'",
			"gradientFill/type":"'.style'",
			"gradientFill/reverse":"'.reverse'",
			"gradientFill/align":"'.alignWithLayer'",
			"gradientFill/scale":"'.scale'",
			"gradientFill/offset":"'.offset'",
		"patternFill/enabled":"'.patternOverlay'",
			"patternFill/mode2":"'.blendMode'",
			"patternFill/opacity":"'.opacity'",
			"patternFill/align":"'.linkWithLayer'",
			"patternFill/scale":"'.scale'",
			"patternFill/phase":"'.offset'",
		"frameFX/enabled":"'.stroke'",
			"frameFX/mode2":"'.blendMode'",
			"frameFX/color":"'.color'",
			"frameFX/size":"'.size'",
			"frameFX/opacity":"'.opacity'",
			"frameFX/style":"'.position'",
	};

//detect AE Version
var reV = /^(\d+\.?\d*)/i;
var v = app.version.match(reV);
Duik.aeVersion = parseFloat(v[1]);
delete reV;
delete v;
}
}());

/////////////////////////////
// INSTALLATION CHECKS
/////////////////////////////
(function ()
{
//=======================
//===== METHODS =========
//=======================
if (typeof Duik.setup !== 'object')
{
Duik.setup = {};
//Duik.setup.presetEffects String
{
Duik.setup.presetEffects = "<!-- BEGIN DUIK PSEUDO EFFECTS v15.11 -->\r\n" +
"<Effect matchname='PSEUDO/DUIK_One_Layer_IK' name='$$$/AE/Preset/1ik=DUIK_One_Layer_IK'>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikWeight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"    <Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='true'/>\r\n" +
"    <Angle name='$$$/AE/Preset/DuikFK=FK' default='0'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Two_Layer_IK_v2' name='$$$/AE/Preset/2ik=DUIK_Two_Layer_IK'>\r\n" +
"    <Checkbox name='$$$/AE/Preset/DuikClockwise=Clockwise' default='false'/>\r\n" +
"    <Group name='$$$/AE/Preset/DuikFK=FK'>\r\n" +
"        <Checkbox name='$$$/AE/Preset/DuikDisableIK=Disable IK' default='false'/>\r\n" +
"        <Angle name='$$$/AE/Preset/DuikUpperFK=Upper FK' default='0'/>\r\n" +
"        <Angle name='$$$/AE/Preset/DuikLowerFK=Lower FK' default='0'/>\r\n" +
"    </Group>\r\n" +
"    <Group name='$$$/AE/Preset/Stretch=Stretch'>\r\n" +
"        <Checkbox name='$$$/AE/Preset/DuikAuto-Stretch=Auto-Stretch' default='true'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikStretch=Stretch' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1'/>\r\n" +
"		<Slider name='$$$/AE/Preset/DuikAuto-Shrink=Auto-Shrink' default='10' valid_min='-150' valid_max='100' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"    </Group>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Three_Layer_IK_v2' name='$$$/AE/Preset/2ik=DUIK_Three_Layer_IK'>\r\n" +
"    <Checkbox name='$$$/AE/Preset/DuikClockwise=Clockwise' default='false'/>\r\n" +
"    <Group name='$$$/AE/Preset/DuikFK=FK'>\r\n" +
"        <Checkbox name='$$$/AE/Preset/DuikDisableIK=Disable IK' default='false'/>\r\n" +
"        <Angle name='$$$/AE/Preset/DuikUpperFK=Upper FK' default='0'/>\r\n" +
"        <Angle name='$$$/AE/Preset/DuikMiddleFK=Middle FK' default='0'/>\r\n" +
"        <Angle name='$$$/AE/Preset/DuikLowerFK=Lower FK' default='0'/>\r\n" +
"    </Group>\r\n" +
"    <Group name='$$$/AE/Preset/Stretch=Stretch'>\r\n" +
"        <Checkbox name='$$$/AE/Preset/DuikAuto-Stretch=Auto-Stretch' default='true'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikStretch=Stretch' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1'/>\r\n" +
"		<Slider name='$$$/AE/Preset/DuikAuto-Shrink=Auto-Shrink' default='10' valid_min='-150' valid_max='100' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"    </Group>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_3D_Wiggle' name='$$$/AE/Preset/3dwiggle=DUIK_3D_Wiggle'>\r\n" +
"    <Group name='$$$/AE/Preset/DuikAmplitudes=Amplitudes'>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikXAmp=X Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikYAmp=Y Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikZAmp=Z Amp.' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
"    </Group>\r\n" +
"    <Group name='$$$/AE/Preset/DuikFrequencies=Frequencies'>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikXFrequ=X Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikYFreq=Y Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikZFreq=Z Freq' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"    </Group>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_2D_Wiggle' name='$$$/AE/Preset/2dwiggle=DUIK_2D_Wiggle'>\r\n" +
"    <Group name='$$$/AE/Preset/DuikAmplitudes=Amplitudes'>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikXAmp=X Amp.' default='0' valid_min='0' valid_max='10000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikYAmp=Y Amp.' default='0' valid_min='0' valid_max='10000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
"    </Group>\r\n" +
"    <Group name='$$$/AE/Preset/DuikFrequencies=Frequencies'>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikXFreq=X Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikYFreq=Y Freq.' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"    </Group>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_1D_Wiggle' name='$$$/AE/Preset/1dwiggle=DUIK_1D_Wiggle'>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikAmplitude=Amplitude' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikFrequency=Frequency' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikLoopDuration=Loop Duration (s)' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Exposure' name='$$$/AE/Preset/exposure=DUIK_Exposure'>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikExposure=Exposure (frames)' default='1' valid_min='1' valid_max='1000' slider_min='1' slider_max='30' precision='1'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_RotMorph' name='$$$/AE/Preset/rotmorph=DUIK_RotMorph'>\r\n" +
"    <Layer name='$$$/AE/Preset/DuikReferenceLayer=Reference Layer' default_self='true'/>\r\n" +
"    <Angle name='$$$/AE/Preset/DuikMin.Angle=Min. Angle' default='0'/>\r\n" +
"    <Angle name='$$$/AE/Preset/DuikMax.Angle=Max. Angle' default='0'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Swing' name='$$$/AE/Preset/swing=DUIK_Swing'>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikAmplitude=Amplitude' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikFrequency=Frequency' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='50' precision='1'/>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikOffset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='1'/>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikDamping=Damping' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Wheel' name='$$$/AE/Preset/wheel=DUIK_Wheel'>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikRadius=Radius' default='100' valid_min='1' valid_max='10000' slider_min='1' slider_max='1000' precision='1'/>\r\n" +
"    <Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='false'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_LensFlare' name='$$$/AE/Preset/lensflare=DUIK_LensFlare'>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikIntensity=Intensity' default='100' valid_min='0' valid_max='1000' slider_min='0' slider_max='200' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikScale=Scale' default='100' valid_min='0' valid_max='1000' slider_min='0' slider_max='200' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_LensFlareDistance' name='$$$/AE/Preset/lensflaredistance=DUIK_LensFlareDistance'>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikDistance=Distance' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_DistanceLink' name='$$$/AE/Preset/distancelink=DUIK_DistanceLink'>\r\n" +
"    <Group name='$$$/AE/Preset/DuikRange=Range'>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikMinimumDistance=Minimum Distance' default='0' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
"        <Slider name='$$$/AE/Preset/DuikMaximumDistance=Maximum Distance' default='500' valid_min='0' valid_max='10000' slider_min='0' slider_max='1000' precision='1'/>\r\n" +
"    </Group>\r\n" +
"    <Checkbox name='$$$/AE/Preset/DuikReverse=Reverse' default='false'/>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikFalloff=Falloff' default='10' valid_min='0' valid_max='1000' slider_min='0' slider_max='100' precision='1'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Spring' name='$$$/AE/Preset/spring=DUIK_Spring'>\r\n" +
"   <Slider name='$$$/AE/Preset/DuikElasticity=Elasticity' default='10' valid_min='0' valid_max='100' slider_min='0' slider_max='25' precision='1'/>\r\n" +
"   <Slider name='$$$/AE/Preset/DuikDamping=Damping' default='5' valid_min='0' valid_max='100' slider_min='0' slider_max='20' precision='1'/>\r\n" +
"	<Slider name='$$$/AE/Preset/DuikSpeedLimit=Trigger speed' default='0.1' valid_min='0' valid_max='1000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Spring_Bounce' name='$$$/AE/Preset/springbounce=DUIK_Spring_Bounce'>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikElasticity=Elasticity' default='10' valid_min='0' valid_max='100' slider_min='0' slider_max='25' precision='1'/>\r\n" +
"    <Slider name='$$$/AE/Preset/DuikDamping=Damping' default='5' valid_min='0' valid_max='100' slider_min='0' slider_max='20' precision='1'/>\r\n" +
"    <Checkbox name='$$$/AE/Preset/DuikBounce=Bounce' default='false'/>\r\n" +
"	<Slider name='$$$/AE/Preset/DuikSpeedLimit=Trigger speed' default='0.1' valid_min='0' valid_max='1000' slider_min='0' slider_max='10' precision='2'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Paint_Rig' name='$$$/AE/Preset/DUIK_Paint_Rig=DUIK_Paint_Rig'>\r\n" +
"	<Slider name='$$$/AE/Preset/Start=Start' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"	<Slider name='$$$/AE/Preset/End=End' default='100' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Diameter=Diameter' default='0' valid_min='-1000' valid_max='10000' slider_min='-100' slider_max='100' precision='0'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Blink_1D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_1D'>\r\n" +
"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Offvalue=Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Blink_2D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_2D'>\r\n" +
"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/xOffvalue=X Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/yOffvalue=Y Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Blink_3D' name='$$$/AE/Preset/DUIK_Blink_1D=DUIK_Blink_3D'>\r\n" +
"	<Slider name='$$$/AE/Preset/Frequency=Frequency' default='1' valid_min='0' valid_max='50' slider_min='0' slider_max='15' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Timeon=Time on' default='50' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='0' DISPLAY_PERCENT='true'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-100' valid_max='100' slider_min='-10' slider_max='10' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/xOffvalue=X Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/yOffvalue=Y Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/zOffvalue=Z Off value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Multiplane\' name='$$$/AE/Preset/DUIK_Multiplane=DUIK_Multiplane'>\r\n" +
"	<Point name='$$$/AE/Preset/Pan=Pan' default_x='0.5' default_y='0.5'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Zoom=Zoom' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"	<Slider name='$$$/AE/Preset/TruckInOut=Truck In Out' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"	<Angle name='$$$/AE/Preset/Tilt=Tilt' default='0.0'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Paint_Group' name='$$$/AE/Preset/DUIK_Paint_Group=DUIK_Paint_Group'>\r\n" +
"<Group name='$$$/AE/Preset/StrokeOptions=Stroke Options'>\r\n" +
"	<Slider name='$$$/AE/Preset/Start=Start' default='0' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"	<Slider name='$$$/AE/Preset/End=End' default='100' valid_min='0' valid_max='100' slider_min='0' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"	<Color name='$$$/AE/Preset/Color=Color' default_red='255' default_green='0' default_blue='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Diameter=Diameter' default='0' valid_min='-32000' valid_max='32000' slider_min='-100' slider_max='100' precision='1'/>\r\n" +
"</Group>\r\n" +
"<Group name='$$$/AE/Preset/Transform=Transform'>\r\n" +
"	<Point name='$$$/AE/Preset/AnchorPoint=Anchor Point' default_x='0.5' default_y='0.5'/>\r\n" +
"	<Point name='$$$/AE/Preset/Position=Position' default_x='0.5' default_y='0.5'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Scale=Scale' default='100' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"	<Angle name='$$$/AE/Preset/Rotation=Rotation' default='0.0'/>\r\n" +
"</Group>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_1D_List' name='$$$/AE/Preset/DUIK_1D_List=DUIK_1D_List'>\r\n" +
"<Group name='$$$/AE/Preset/1=1'>\r\n" +
"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"	<Group name='$$$/AE/Preset/2=2'>\r\n" +
"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"	<Group name='$$$/AE/Preset/3=3'>\r\n" +
"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"	<Group name='$$$/AE/Preset/4=4'>\r\n" +
"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"	<Group name='$$$/AE/Preset/5=5'>\r\n" +
"	<Slider name='$$$/AE/Preset/Value=Value' default='0' valid_min='-10000' valid_max='10000' slider_min='-100' slider_max='100' precision='2'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_2D_List' name='$$$/AE/Preset/DUIK_2D_List=DUIK_2D_List'>\r\n" +
"<Group name='$$$/AE/Preset/1=1'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"<Group name='$$$/AE/Preset/2=2'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"<Group name='$$$/AE/Preset/3=3'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"<Group name='$$$/AE/Preset/4=4'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"<Group name='$$$/AE/Preset/5=5'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_3D_List' name='$$$/AE/Preset/DUIK_3D_List=DUIK_3D_List'>\r\n" +
"<Group name='$$$/AE/Preset/1=1'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"	<Group name='$$$/AE/Preset/2=2'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"	<Group name='$$$/AE/Preset/3=3'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"	<Group name='$$$/AE/Preset/4=4'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"	<Group name='$$$/AE/Preset/5=5'>\r\n" +
"	<Point name='$$$/AE/Preset/Value=Value' default_x='0' default_y='0'/>\r\n" +
"	<Slider name='$$$/AE/Preset/ZValue=Z Value' default='0' valid_min='-30000' valid_max='30000' slider_min='-1000' slider_max='1000' precision='1'/>\r\n" +
"	<Slider name='$$$/AE/Preset/Weight=Weight' default='100' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='200' precision='2' DISPLAY_PERCENT='true'/>\r\n" +
"</Group>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Bezier_IK' name='$$$/AE/Preset/DUIK_Bezier_IK=DUIK_Bezier_IK'>\r\n" +
"	<Slider name='$$$/AE/Preset/Offset=Offset' default='0' valid_min='-1000' valid_max='1000' slider_min='-100' slider_max='100' precision='1' DISPLAY_PERCENT='true'/>\r\n" +
"	<Checkbox name='$$$/AE/Preset/AutoOrientation=Auto Orientation' default='true'/>\r\n" +
"</Effect>\r\n" +
"<Effect matchname='PSEUDO/DUIK_Foot_Roll' name='$$$/AE/Preset/DUIK_Foot_Roll=DUIK_Foot_Roll'>\r\n" +
"	<Angle name='$$$/AE/Preset/Tiptoe=Tiptoe' default='0.0'/>\r\n" +
"	<Angle name='$$$/AE/Preset/Heel=Heel' default='0.0'/>\r\n" +
"	<Angle name='$$$/AE/Preset/FootRoll=Foot roll' default='0.0'/>\r\n" +
"</Effect>\r\n" +
"<!-- END DUIK PSEUDO EFFECTS -->\r\n";
}
// INSTALL PSEUDO EFFECTS - Duik.setup.installCustomEffects();
Duik.setup.installPseudoEffects = function ()
{
//-------------------------------------------------------------
//------ Edit presetEffects.xml to add Duik Effects -----------
//-------------------------------------------------------------
if (Duik.allowedToWriteFiles && Duik.presetEffectsInstalledVersion < Duik.versionNumber)
{
var appPath = Folder.appPackage.fsName;
var presetEffectsFile = new File(appPath + "\\PresetEffects.xml");
if ($.os.toLowerCase().indexOf("mac") >= 0) presetEffectsFile = new File(appPath + "/Contents/Resources/PresetEffects.xml");
if (presetEffectsFile.exists)
{
presetEffectsFile.open("r","TEXT");
var presetEffectsString = presetEffectsFile.read();
presetEffectsFile.close();
//update
var startIndex = presetEffectsString.indexOf("<!-- BEGIN DUIK PSEUDO EFFECTS v");
var endIndex = presetEffectsString.indexOf("<!-- END DUIK PSEUDO EFFECTS -->") + 32;
if (startIndex >= 0)
{
var stringToRemove = presetEffectsString.substring(startIndex,endIndex);
presetEffectsString = presetEffectsString.replace(stringToRemove,Duik.setup.presetEffects);
}
else
{
presetEffectsString = presetEffectsString.replace("</Effects>",Duik.setup.presetEffects + "\r\n</Effects>");
}
//gets write access
if ($.os.toLowerCase().indexOf("mac") >= 0)
{
var cmd = "chmod u+rw  " + "\"" + appPath + "/PresetEffects.xml\"";
system.callSystem(cmd);
}
else
{
var cmd = "cmd /c attrib -r /S /D \"" + appPath + "\"";
system.callSystem(cmd);
cmd = "cmd /c attrib -r /S /D \"" + appPath + "\\PresetEffects.xml\"";
system.callSystem(cmd);
}
//backup file
presetEffectsFile.copy(presetEffectsFile.fullName + ".bak");
//write the new file
var isReadOnly = presetEffectsFile.readonly;
presetEffectsFile.readonly = false;
presetEffectsFile.open("w","TEXT");
presetEffectsFile.write(presetEffectsString);
presetEffectsFile.close();
presetEffectsFile.readonly = isReadOnly;
}
Duik.setup.checkPresetEffectsVersion();
}
}
Duik.setup.checkPresetEffectsVersion = function ()
{
var presetEffectsFile = new File(Folder.appPackage.absoluteURI + "/PresetEffects.xml");
if ($.os.toLowerCase().indexOf("mac") >= 0) presetEffectsFile = new File(Folder.appPackage.absoluteURI + "/Contents/Resources/PresetEffects.xml");
Duik.presetEffectsInstalledVersion = 0;
if (presetEffectsFile.exists)
{
presetEffectsFile.open("r","TEXT");
var presetEffectsString = presetEffectsFile.read();
presetEffectsFile.close();
//find version
var startIndex = presetEffectsString.indexOf("<!-- BEGIN DUIK PSEUDO EFFECTS v");
if (startIndex >= 0)
{
startIndex += 32 ;
Duik.presetEffectsInstalledVersion = parseFloat(presetEffectsString.substr(startIndex,7));
}
}
}

}

//-----------------------------------------------------------------
//--------- Check if presetEffects.xml is up-to-date --------------
//-----------------------------------------------------------------
Duik.setup.checkPresetEffectsVersion();
if (Duik.presetEffectsInstalledVersion == Duik.versionNumber)
{
Duik.usePresets = false;
}

//-----------------------------------------------------------------
//--------- Check if scripts are allowed to write files -----------
//-----------------------------------------------------------------
Duik.allowedToWriteFiles = app.preferences.getPrefAsLong("Main Pref Section","Pref_SCRIPTING_FILE_NETWORK_SECURITY") == 1;

//-----------------------------------------------------------------
//------------------------------ INSTALL --------------------------
//-----------------------------------------------------------------
if (Duik.usePresets)
{
Duik.setup.installPseudoEffects();
}
}());

/////////////////////////////
// MAIN
/////////////////////////////
(function ()
{
//================================
//============== UI ==============
//================================

if (typeof Duik.ui !== 'object')
{
Duik.ui = {};
Duik.ui.progressPanel = new Window("window","Duik",undefined);
Duik.ui.progressPanel.size = [350,70];
Duik.ui.progressPanel.alignChildren = ["fill","top"];
Duik.ui.progressPanel.margins = 7;
Duik.ui.progressPanel.spacing = 2;
Duik.ui.progressPanel.orientation = "column";
Duik.ui.progressPanel.add("statictext",undefined,"Please be patient while Duik is doing its magic.");
Duik.ui.progressGroup = Duik.ui.progressPanel.add("group");
Duik.ui.progressGroup.alignChildren = ["fill","top"];
Duik.ui.progressGroup.margins = 0;
Duik.ui.progressGroup.spacing = 2;
Duik.ui.progressBar = Duik.ui.progressGroup.add("progressbar",undefined);
Duik.ui.etr = Duik.ui.progressGroup.add("statictext",undefined," 00:00 " + "remaining");
Duik.ui.etr.alignment = ["right","top"];
Duik.ui.progressStatus = Duik.ui.progressPanel.add("statictext",undefined,"Can you feel the magic?");
Duik.ui.progressStartTime = new Date();
Duik.ui.updateProgressPanel = function (val,status)
{
var currentDate = new Date();
var timeElapsed = currentDate.getTime() - Duik.ui.progressStartTime.getTime();
var iTime = timeElapsed/val;

var remainingIterations = Duik.ui.progressBar.maxvalue-val;
var remainingTime = iTime*remainingIterations;
var remainingSeconds = parseInt(remainingTime/1000);
var minutes = parseInt(remainingSeconds/60);
var seconds = remainingSeconds - minutes*60;
if (minutes == 0) minutes = "00";
else if (minutes < 10) minutes = "0" + minutes;
if (seconds == 0) seconds = "00";
else if (seconds < 10) seconds = "0" + seconds;

Duik.ui.etr.text = minutes + ":" + seconds + " remaining";

Duik.ui.progressBar.value = val;
if (status != undefined) Duik.ui.progressStatus.text = status;
if (Duik.aeVersion > 9) Duik.ui.progressPanel.update();
};
Duik.ui.showProgressPanel = function (maxVal,status)
{
Duik.ui.progressStartTime = new Date();
Duik.ui.progressBar.maxvalue = maxVal;
Duik.ui.progressBar.value = 0;
Duik.ui.progressStatus.text = status;
Duik.ui.progressPanel.show();
if (Duik.aeVersion > 9) Duik.ui.progressPanel.update();
};
Duik.ui.hideProgressPanel = function ()
{
Duik.ui.progressIterationDuration = 0;
Duik.ui.progressPanel.hide();
};
}

//================================
//========= UI Strings ===========
//================================

/* UI Strings
class Duik.uiStrings
containing all needed uiString (localizable strings)
*/
if (typeof Duik.uiStrings !== 'object')
{
Duik.uiStrings = {};

Duik.uiStrings.ik = "IK";
Duik.uiStrings.ikDirection = "IK Direction";
Duik.uiStrings.ikLimit = "IK Limit"
Duik.uiStrings.ikEnd = "IK End";
Duik.uiStrings.wiggle = "Wiggle";
Duik.uiStrings.exposure = "Exposure";
Duik.uiStrings.rotMorph = "Rotation Morph";
Duik.uiStrings.swing = "Swing";
Duik.uiStrings.wheel = "Wheel";
Duik.uiStrings.lensFlare = "Lens Flare";
Duik.uiStrings.distanceLink = "Distance Link";
Duik.uiStrings.spring = "Spring";
Duik.uiStrings.paintRig = "Paint Rig";
Duik.uiStrings.paintGroup = "Paint Group";
Duik.uiStrings.blink = "Blink";
Duik.uiStrings.scale = "Scale";
Duik.uiStrings.flip = "Flip";
Duik.uiStrings.moveAway = "Distance from parent";
Duik.uiStrings.multiplane = "Multiplane";
Duik.uiStrings.camInfluence = "Camera Influence";
Duik.uiStrings.morpher = "Morpher";
Duik.uiStrings.list = "List";
Duik.uiStrings.bezierIKOffset = "Bezier IK Offset";
Duik.uiStrings.bezierIK = "Bezier IK";
Duik.uiStrings.controllers = "Controllers";
Duik.uiStrings.bones = "Bones";
Duik.uiStrings.zeroes = "Zeroes";
}

//================================
//========= SETTINGS =============
//================================

/* Duik Settings

*/
if (typeof Duik.settings !== 'object')
{
Duik.settings = {};
if (! app.settings.haveSetting("duik", "boneType")){app.settings.saveSetting("duik","boneType",Duik.layerTypes.SOLID);}
if (! app.settings.haveSetting("duik", "controllerType")){app.settings.saveSetting("duik","controllerType",Duik.layerTypes.VECTOR);}
if (! app.settings.haveSetting("duik", "boneSize")){app.settings.saveSetting("duik","boneSize",20);}
if (! app.settings.haveSetting("duik", "ctrlSize")){app.settings.saveSetting("duik","ctrlSize",100);}
if (! app.settings.haveSetting("duik", "ctrlSizeAuto")){app.settings.saveSetting("duik","ctrlSizeAuto",true);}
if (! app.settings.haveSetting("duik", "boneSizeAuto")){app.settings.saveSetting("duik","boneSizeAuto",true);}
if (! app.settings.haveSetting("duik", "boneSizeAutoValue")){app.settings.saveSetting("duik","boneSizeAutoValue",Duik.sizes.MEDIUM);}
if (! app.settings.haveSetting("duik", "ctrlSizeAutoValue")){app.settings.saveSetting("duik","ctrlSizeAutoValue",Duik.sizes.MEDIUM);}
if (! app.settings.haveSetting("duik", "boneColor")){app.settings.saveSetting("duik","boneColor","FF0000");}
if (! app.settings.haveSetting("duik", "morpherKeyframes")){app.settings.saveSetting("duik","morpherKeyframes",true);}
if (! app.settings.haveSetting("duik", "getLayersMethod")){app.settings.saveSetting("duik","getLayersMethod",Duik.getLayers.NAME);}
if (! app.settings.haveSetting("duik", "bonePlacement")){app.settings.saveSetting("duik","bonePlacement",Duik.placement.OVER_LAYER);}
if (! app.settings.haveSetting("duik", "ctrlPlacement")){app.settings.saveSetting("duik","ctrlPlacement",Duik.placement.TOP);}
if (! app.settings.haveSetting("duik", "displayProgressPanel")){app.settings.saveSetting("duik","displayProgressPanel",true);}
if (! app.settings.haveSetting("duik", "controllerColor")){app.settings.saveSetting("duik","controllerColor",Duik.colors.WHITE.toSource());}

Duik.settings.save = function ()
{
app.settings.saveSetting("duik","boneType",Duik.settings.boneType);
app.settings.saveSetting("duik","controllerType",Duik.settings.controllerType);
app.settings.saveSetting("duik","boneSize",Duik.settings.boneSize);
app.settings.saveSetting("duik","ctrlSize",Duik.settings.controllerSize);
app.settings.saveSetting("duik","ctrlSizeAuto",Duik.settings.controllerSizeAuto);
app.settings.saveSetting("duik","boneSizeAuto",Duik.settings.boneSizeAuto);
app.settings.saveSetting("duik","boneSizeAutoValue",Duik.settings.boneSizeHint);
app.settings.saveSetting("duik","ctrlSizeAutoValue",Duik.settings.controllerSizeHint);
app.settings.saveSetting("duik","boneColor",Duik.settings.boneColor);
app.settings.saveSetting("duik","morpherKey",Duik.settings.morpherCreatesKeyframes);
app.settings.saveSetting("duik","getLayersMethod",Duik.settings.getLayersMethod);
app.settings.saveSetting("duik","bonePlacement",Duik.settings.bonePlacement);
app.settings.saveSetting("duik","ctrlPlacement",Duik.settings.ctrlPlacement);
app.settings.saveSetting("duik","displayProgressPanel",Duik.settings.displayProgressPanel);
app.settings.saveSetting("duik","controllerColor",Duik.settings.controllerColor.toSource());
}

Duik.settings.load = function ()
{
Duik.settings.controllerSize = eval(app.settings.getSetting("duik","ctrlSize"));
Duik.settings.controllerType = eval(app.settings.getSetting("duik","controllerType"));
Duik.settings.controllerSizeAuto = eval(app.settings.getSetting("duik","ctrlSizeAuto"));
Duik.settings.controllerSizeHint = eval(app.settings.getSetting("duik","ctrlSizeAutoValue"));
Duik.settings.boneType = eval(app.settings.getSetting("duik","boneType"));
Duik.settings.boneSize = eval(app.settings.getSetting("duik","boneSize"));
Duik.settings.boneSizeAuto = eval(app.settings.getSetting("duik","boneSizeAuto"));
Duik.settings.boneSizeHint = eval(app.settings.getSetting("duik","boneSizeAutoValue"));
Duik.settings.boneColor = app.settings.getSetting("duik","boneColor");
Duik.settings.morpherCreatesKeyframes = eval(app.settings.getSetting("duik","morpherKeyframes"));
Duik.settings.getLayersMethod = eval(app.settings.getSetting("duik","getLayersMethod"));
Duik.settings.bonePlacement = eval(app.settings.getSetting("duik","bonePlacement"));
Duik.settings.ctrlPlacement = eval(app.settings.getSetting("duik","ctrlPlacement"));
Duik.settings.displayProgressPanel = eval(app.settings.getSetting("duik","displayProgressPanel"));
Duik.settings.controllerColor = eval(app.settings.getSetting("duik","controllerColor"));
}

Duik.settings.restoreDefaults = function ()
{
Duik.settings.controllerSize = 100;
Duik.settings.controllerType = Duik.layerTypes.VECTOR;
Duik.settings.controllerSizeAuto = true;
Duik.settings.controllerSizeHint = Duik.sizes.MEDIUM;
Duik.settings.boneType = Duik.layerTypes.SOLID;
Duik.settings.boneSize = 20;
Duik.settings.boneSizeAuto = true;
Duik.settings.boneSizeHint = Duik.sizes.MEDIUM;
Duik.settings.boneColor = "FF0000";
Duik.settings.morpherCreatesKeyframes = true;
Duik.settings.getLayersMethod = Duik.getLayers.NAME;
Duik.settings.bonePlacement = Duik.placement.OVER_LAYER;
Duik.settings.ctrlPlacement = Duik.placement.TOP;
Duik.settings.displayProgressPanel = true;
Duik.settings.controllerColor = Duik.colors.WHITE;

Duik.settings.save();
}

Duik.settings.load();
}

//================================
//========== JS TOOLS ============
//================================

if (typeof Duik.js !== 'object')
{
	Duik.js = {};
	// ESCAPE REGEXP
	if (typeof Duik.js.escapeRegExp !== 'function')
	{
	Duik.js.escapeRegExp = function (string)
	{
	return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
	}
	}
	// REPLACE TEXT
	if (typeof Duik.js.replaceAll !== 'function')
	{
	Duik.js.replaceAll = function (string, find, replace, caseSensitive)
	{
	if (caseSensitive == undefined) caseSensitive = true;
	var re = new RegExp(Duik.js.escapeRegExp(find),caseSensitive ? 'g' : 'gi');
	return string.replace(re, replace);
	}
	}
	// RANDOM
	
	!function(a,b){function c(c,j,k){var n=[];j=1==j?{entropy:!0}:j||{};var s=g(f(j.entropy?[c,i(a)]:null==c?h():c,3),n),t=new d(n),u=function(){for(var a=t.g(m),b=p,c=0;q>a;)a=(a+c)*l,b*=l,c=t.g(1);for(;a>=r;)a/=2,b/=2,c>>>=1;return(a+c)/b};return u.int32=function(){return 0|t.g(4)},u.quick=function(){return t.g(4)/4294967296},u["double"]=u,g(i(t.S),a),(j.pass||k||function(a,c,d,f){return f&&(f.S&&e(f,t),a.state=function(){return e(t,{})}),d?(b[o]=a,c):a})(u,s,"global"in j?j.global:this==b,j.state)}function d(a){var b,c=a.length,d=this,e=0,f=d.i=d.j=0,g=d.S=[];for(c||(a=[c++]);l>e;)g[e]=e++;for(e=0;l>e;e++)g[e]=g[f=s&f+a[e%c]+(b=g[e])],g[f]=b;(d.g=function(a){for(var b,c=0,e=d.i,f=d.j,g=d.S;a--;)b=g[e=s&e+1],c=c*l+g[s&(g[e]=g[f=s&f+b])+(g[f]=b)];return d.i=e,d.j=f,c})(l)}function e(a,b){return b.i=a.i,b.j=a.j,b.S=a.S.slice(),b}function f(a,b){var c,d=[],e=typeof a;if(b&&"object"==e)for(c in a)try{d.push(f(a[c],b-1))}catch(g){}return d.length?d:"string"==e?a:a+"\0"}function g(a,b){for(var c,d=a+"",e=0;e<d.length;)b[s&e]=s&(c^=19*b[s&e])+d.charCodeAt(e++);return i(b)}function h(){try{if(j)return i(j.randomBytes(l));var b=new Uint8Array(l);return(k.crypto||k.msCrypto).getRandomValues(b),i(b)}catch(c){var d=k.navigator,e=d&&d.plugins;return[+new Date,k,e,k.screen,i(a)]}}function i(a){return String.fromCharCode.apply(0,a)}var j,k=this,l=256,m=6,n=52,o="random",p=b.pow(l,m),q=b.pow(2,n),r=2*q,s=l-1;if(b["seed"+o]=c,g(b.random(),a),"object"==typeof module&&module.exports){module.exports=c;try{j=require("crypto")}catch(t){}}else"function"==typeof define&&define.amd&&define(function(){return c})}([],Math);
		
	if (typeof Duik.js.random !== 'function')
	{
		Duik.js.random = function (min, max)
		{
			var rng = null;
			$.sleep(1);
			var date = new Date();
			var rng = new Math.seedrandom(date.getTime())();
			//rng = Math.random();
			
			if (!rng) return 0;
			return rng * (max - min) + min;
		}
	}

	if (typeof Duik.js.arrayIndexOf !== 'function')
	{
	Duik.js.arrayIndexOf = function (arr,value)
	{
	if (value == undefined) throw "Value can not be undefined";

	for (var i = 0;i<arr.length;i++)
	{
	if (arr[i] == value) return i;
	}
	return -1;
	}
	}
	if (typeof Duik.js.arrayHasDuplicates !== 'function')
	{
	Duik.js.arrayHasDuplicates = function (arr)
	{
	for (var i = 0;i<arr.length-1;i++) {
	for (var j=i+1;j<arr.length;j++) {
	if (arr[i] === arr[j]) return true;
	}
	}
	return false;
	}
	}
	if (typeof Duik.js.arrayGetDuplicates !== 'function')
	{
	Duik.js.arrayGetDuplicates = function (arr)
	{
	var duplicates = [];
	for (var i = 0;i<arr.length-1;i++) {
	for (var j=i+1;j<arr.length;j++) {
	if (arr[i] === arr[j]) duplicates.push(arr[j]);
	}
	}
	Duik.js.arrayRemoveDuplicates(duplicates);
	return duplicates;
	}
	}
	if (typeof Duik.js.arrayRemoveDuplicates !== 'function')
	{
	Duik.js.arrayRemoveDuplicates = function (arr)
	{
	var removed = [];
	for (var i = 0;i<arr.length-1;i++) {
	for (var j=i+1;j<arr.length;j++) {
	if (arr[i] === arr[j]) {
	removed = removed.concat(arr.splice(j,1));
	}
	}
	}
	return removed;
	}
	}

}

//================================
//===== IMPORT EXPORT TOOLS ======
//================================

if (typeof Duik.bridge !== 'object')
{
Duik.bridge = {};
Duik.bridge.tvPaint = {};
//PARSE TVPCamera
if (typeof Duik.bridge.tvPaint.parseCam !== 'function')
{
Duik.bridge.tvPaint.parseCam = function (camString)
{
var camera = new TVPCamera();

var lines = camString.split("\n");

var reXPoint = /point\.(\d+)\.x=(-?\d+\.?\d*)/i;
var reYPoint = /point\.(\d+)\.y=(-?\d+\.?\d*)/i;
var reZPoint = /point\.(\d+)\.zoom=(\d+\.?\d*)/i;
var reRPoint = /point\.(\d+)\.rotation=(-?\d+\.?\d*)/i;
var reLinear = /profileprof_linear=([01])/i;
var reProfPoint = /profileprof\_point(\d+)=(\d+.?\d*) (\d+.?\d*)/i;
var rePointCout = /pointcount=(\d+)/i;
var reProfPointCount = /profileprof_numpoint=(\d+)/i;
for (var i=0;i<lines.length;i++ )
{
var line = lines[i];
var count = line.match(rePointCout);
if (count != null)
{
camera.pointCount = parseInt(count[1]);
}
var xPoint = line.match(reXPoint);
if (xPoint != null)
{
var index = parseInt(xPoint[1]);
var value = parseFloat(xPoint[2]);
var point = camera.points[index];
if (point == undefined) point = new TVPCameraPoint();
point.x = value ;
camera.points[index] = point;
}
var yPoint = line.match(reYPoint);
if (yPoint != null)
{
var index = parseInt(yPoint[1]);
var value = parseFloat(yPoint[2]);
var point = camera.points[index];
if (point == undefined) point = new TVPCameraPoint();
point.y = value ;
camera.points[index] = point;
}
var zPoint = line.match(reZPoint);
if (zPoint != null)
{
var index = parseInt(zPoint[1]);
var value = parseFloat(zPoint[2]);
var point = camera.points[index];
if (point == undefined) point = new TVPCameraPoint();
point.zoom = value ;
camera.points[index] = point;
}
var rPoint = line.match(reRPoint);
if (rPoint != null)
{
var index = parseInt(rPoint[1]);
var value = parseFloat(rPoint[2]);
var point = camera.points[index];
if (point == undefined) point = new TVPCameraPoint();
point.rotation = value ;
camera.points[index] = point;
}
var linear = line.match(reLinear);
if (linear != null)
{
var lin = parseInt(linear[1]);
camera.profileprof.linear = (lin == 1);
}
var profPoint = line.match(reProfPoint);
if (profPoint != null)
{
var index = parseInt(profPoint[1]);
var u = parseFloat(profPoint[2]);
var v = parseFloat(profPoint[3]);
var point = new TVPProfileprofPoint();
point.u = u;
point.v = v;
camera.profileprof.points[index] = point;
}
var profCount = line.match(reProfPointCount);
if (profCount != null)
{
camera.profileprof.pointCount = parseInt(profCount[1]);
}
}

return camera;
}
}
//PARSE TVPCamera
if (typeof Duik.bridge.tvPaint.loadCamFile !== 'function')
{
Duik.bridge.tvPaint.loadCamFile = function (camFile)
{
camFile.open("r");
var camString = camFile.read();
camFile.close();
var tvpCam = Duik.bridge.tvPaint.parseCam(camString);
return tvpCam;
}
}
}

//================================
//========== UTILS ===============
//================================

if (typeof Duik.utils !== 'object')
{
Duik.utils = {};
// RIG PROPERTY - Duik.utils.rigProperty(layer,prop,duikEffect)
if (typeof Duik.utils.addEffect !== 'function')
{
Duik.utils.addEffect = function (layer,duikEffect)
{
if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(layer,duikEffect.ffx);
else effect = layer.effect.addProperty(duikEffect);
return effect;
}
}
// RIG PROPERTY - Duik.utils.rigProperty(layer,prop,duikEffect)
if (typeof Duik.utils.rigProperty !== 'function')
{
Duik.utils.rigProperty = function (layer,prop,duikEffect)
{
//if prop is an effect, need a way to recover it
var propDescription = Duik.utils.prepareProperty(prop);
if (!propDescription.canSetExpression) return null;
//pseudo effect
var effect = null;
if (Duik.usePresets) effect = Duik.utils.addPseudoEffect(layer,duikEffect);
else effect = layer.effect.addProperty(duikEffect);
if (propDescription.isEffect){ prop = layer.effect(propDescription.parentName)(propDescription.index); }
return [effect,prop];
}
}
// PREPARE PROPERTY - Duik.utils.prepareProperty(prop,isFX,ind,prof,parentName,dimensions)
if (typeof Duik.utils.prepareProperty !== 'function')
{
Duik.utils.prepareProperty = function (prop)
{
var propDescr = new PropertyDescription();
propDescr.canSetExpression = prop.canSetExpression;
propDescr.isEffect = prop.parentProperty.isEffect;
propDescr.index = prop.propertyIndex;
propDescr.depth = prop.propertyDepth;
propDescr.parentName = prop.parentProperty.name;
propDescr.dimensions = Duik.utils.getPropertyDimensions(prop);

return propDescr;
}
}
// GET DIMENSIONS - Duik.utils.getPropertyDimensions(property)
if (typeof Duik.utils.getPropertyDimensions !== 'function')
{
Duik.utils.getPropertyDimensions = function (prop)
{
var dimensions = 1;
if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
{
//if this is a position or scale and the layer is not 3D, AFX uses a 3D value in the position (with 0 as Z position), but the expression must return a 2D value.......
if ((prop.matchName == "ADBE Scale" || prop.matchName == "ADBE Position") && !app.project.activeItem.selectedLayers[0].threeDLayer)
{
dimensions = 2;
}
else
{
dimensions = 3;
}
}
else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
{
dimensions = 2;
}
return dimensions;
}
}
// GET LENGTH - Duik.utils.getLength(value1,value2)
if (typeof Duik.utils.getLength !== 'function')
{
Duik.utils.getLength = function (value1,value2)
{
if (typeof value1 !== typeof value2)
{
return null;
}
if (value1.length > 0)
{
var result = 0;
for (var dim = 0;dim<value1.length;dim++)
{
result += (value1[dim]-value2[dim])*(value1[dim]-value2[dim]);
}
result = Math.sqrt(result);
return result;
}
else return Math.abs(value1 - value2) ;
}
}
// GET AVERAGE SPEED - Duik.utils.getAverageSpeed(layer,property)
if (typeof Duik.utils.getAverageSpeed !== 'function')
{
Duik.utils.getAverageSpeed = function (layer,prop)
{
if (prop.numKeys < 1) return 0;
//for each frame of the comp
var frames = layer.containingComp.duration / layer.containingComp.frameDuration ;
var lastTime = prop.keyTime(prop.numKeys);
var firstTime = prop.keyTime(1);
var lastFrame = lastTime/layer.containingComp.frameDuration ;
var firstFrame = firstTime/layer.containingComp.frameDuration ;
if (lastFrame > frames) lastFrames = frames;
if (firstFrame < 1) firstFrame = 1;
var sum = 0;
for (var frame = firstFrame ; frame < lastFrame ; frame++)
{
var time = frame*app.project.activeItem.frameDuration;
sum += Duik.utils.getLength(prop.valueAtTime(time,false),prop.valueAtTime(time-layer.containingComp.frameDuration,false));
}
return sum/(lastFrame-firstFrame);
}
}
// GET AVERAGE SPEEDS - Duik.utils.getAverageSpeeds(layers)
if (typeof Duik.utils.getAverageSpeeds !== 'function')
{
Duik.utils.getAverageSpeeds = function (layers)
{
var averageSpeed = 0;
var count = 0;
for (var i = 0 ; i < layers.length ; i++)
{
var layer = Duik.utils.getItem(layers,i);
for (var j = 0 ; j < layer.selectedProperties.length ; j++)
{
var prop = layer.selectedProperties[j];
if (prop.propertyType != PropertyType.PROPERTY) continue;
if (prop.numKeys < 1) continue;
var newSpeed = Duik.utils.getAverageSpeed(layer,prop);
if (newSpeed > 0)
{
averageSpeed += newSpeed;
count++;
}
}
}
averageSpeed = averageSpeed/count;
return averageSpeed;
}
}
// ADD PSEUDO EFFECT - Duik.utils.addPseudoEffect(layer,duikEffect)
if (typeof Duik.utils.addPseudoEffect !== 'function')
{
Duik.utils.addPseudoEffect = function (layer,preset)
{
//applyPreset is bugged and always applies presets on selected layers instead of the given one,
//first deselect everything and select the wanted layer
var selection = app.project.activeItem.selectedLayers;
Duik.utils.deselectLayers();
layer.selected = true;

var presetFile = new File(Duik.presetPath + preset + ".ffx");
layer.applyPreset(presetFile);

var newEffect = null;

for (var fx = 1;fx <= layer("Effects").numProperties;fx++)
{
if (layer.effect(fx).name == preset )
{
newEffect = layer.effect(fx);
break;
}
}

//restore selection...
layer.selected = false;
for (var selectedLayerIndex=0;selectedLayerIndex<selection.length;selectedLayerIndex++)
{
selection[selectedLayerIndex].selected = true;
}

return newEffect;
}
}
// GET ALL PUPPET PINS FROM A LAYER - Duik.utils.getPuppetPins(prop)
if (typeof Duik.utils.getPuppetPins !== 'function')
{
Duik.utils.getPuppetPins = function (prop) {
var coins = [];
if (prop != null)
{
if (prop.matchName == "ADBE FreePin3 PosPin Atom")
{
coins.push(prop);
}
else if (prop.numProperties > 0)
{
//contournement de bug...
//d'abord recup les proprietes dans un tableau avant de les parcourir
//sinon l'increment fonctionne pas dans la boucle, allez savoir pourquoi

var proprietes = [];
for (var p=1;p<=prop.numProperties;p++)
{
proprietes.push(prop.property(p));
}

for (var pi = 0;pi < proprietes.length;pi++)
{
var newCoins = Duik.utils.getPuppetPins(proprietes[pi]);
if (newCoins.length > 0)
{
coins = coins.concat(newCoins);
}
}
}
}

return coins;
}
}
// MEASURE DISTANCE BETWEEN TWO LAYERS - Duik.utils.getDistance(layer1,layer2)
if (typeof Duik.utils.getDistance !== 'function')
{
Duik.utils.getDistance = function (layer1,layer2)
{
//parents
var layer1Parent = layer1.parent;
var layer2Parent = layer2.parent;
//unlink
layer1.parent = null;
layer2.parent = null;
var O = layer1.transform.position.value;
var A = layer2.transform.position.value;
var OA = Duik.utils.getLength(O,A);
//re-link
layer1.parent = layer1Parent;
layer2.parent = layer2Parent;
return Math.round(OA);
}
}
// DESELECT ALL LAYERS - Duik.utils.deselectLayers()
if (typeof Duik.utils.deselectLayers !== 'function')
{
Duik.utils.deselectLayers = function ()
{
var sel = app.project.activeItem.selectedLayers;
for (var selectedLayerIndex=0;selectedLayerIndex<sel.length;selectedLayerIndex++)
{
sel[selectedLayerIndex].selected = false;
}
}
}
// CHECK NAMES - Duik.utils.checkNames(comp)
if (typeof Duik.utils.checkNames !== 'function')
{
Duik.utils.checkNames = function (comp)
{
if (comp == undefined) comp = app.project.activeItem;
if (comp == undefined) return false;

var layers = comp.layers;
var numLayers = comp.numLayers;
var renamed = false;

var counts = {};
// first pass, assign the counts
for (var layerI = 1; layerI <= numLayers; layerI++)
{
var layer = layers[layerI];
var name = layer.name;

if (counts[name] == undefined)
{
counts[name] = 1;
}
else
{
counts[name]++;
}

if (counts[name] > 1)
{
var l = layer.locked;
layer.locked = false;
layer.name = name + " " + counts[name];
layer.locked = l;
renamed = true;
}
}

return renamed;
}
}
// GET ITEM from Array or Collection
if (typeof Duik.utils.getItem !== 'function')
{
Duik.utils.getItem = function (items,itemIndex)
{
if (items instanceof ItemCollection || items instanceof LayerCollection || items instanceof OMCollection || items instanceof RQItemCollection) return items[itemIndex+1];
else return items[itemIndex];
}
}
// GET KEY at index from property
//return KeyFrame
if (typeof Duik.utils.getKey !== 'function')
{
Duik.utils.getKey = function (prop,keyIndex)
{
if (Math.abs(keyIndex) > prop.numKeys || keyIndex == 0)
{
return null;
}
if (keyIndex < 0)
{
keyIndex = prop.numKeys - keyIndex + 1;
}

var key = new KeyFrame();
key.time = prop.keyTime(keyIndex);
key.value = prop.keyValue(keyIndex);
key.inInterpolationType = prop.keyInInterpolationType(keyIndex);
key.outInterpolationType = prop.keyOutInterpolationType(keyIndex);
if ( prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL )
{
key.spatial = true;
key.spatialProperties.inTangent = prop.keyInSpatialTangent(keyIndex);
key.spatialProperties.outTangent  = prop.keyOutSpatialTangent(keyIndex);
key.spatialProperties.continuous = prop.keySpatialContinuous(keyIndex);
key.spatialProperties.autoBezier = prop.keySpatialAutoBezier(keyIndex);
key.spatialProperties.roving = prop.keyRoving(keyIndex);
}
key.inEase = prop.keyInTemporalEase(keyIndex);
key.outEase = prop.keyOutTemporalEase(keyIndex);
key.continuous = prop.keyTemporalContinuous(keyIndex);
key.autoBezier = prop.keyTemporalAutoBezier(keyIndex);

return key;
}
}
// GET PROPERTY ANIMS between startTime and Endtime (if propertyGroup, recursive)
//return Array of PropertyAnim
if (typeof Duik.utils.getPropertyAnims !== 'function')
{
Duik.utils.getPropertyAnims = function (prop,selectedKeysOnly,allKeys,startTime,endTime)
{
var anims = [];
if (prop.propertyType == PropertyType.PROPERTY)
{
if (prop.PropertyValueType != PropertyValueType.NO_VALUE)
{
var anim = Duik.utils.getPropertyAnim(prop,selectedKeysOnly,allKeys,startTime,endTime);
if (anim != null)
{
if (selectedKeysOnly && anim.keys.length >= 1) anims.push(anim);
else if (!selectedKeysOnly) anims.push(anim);
}
}
}
else if (prop.numProperties > 0)
{
for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
{
var newAnims = Duik.utils.getPropertyAnims(prop.property(propIndex),selectedKeysOnly,allKeys,startTime,endTime);
if (newAnims.length > 0)
{
anims = anims.concat(newAnims);
}
}
}
return anims;
}
}
// GET PROPERTY ANIM between startTime and Endtime (not for PropertyGroup)
//return PropertyAnim
if (typeof Duik.utils.getPropertyAnim !== 'function')
{
Duik.utils.getPropertyAnim = function (prop,selectedKeysOnly,allKeys,startTime,endTime)
{
if (prop.propertyValueType == PropertyValueType.NO_VALUE) return null;

if (startTime == undefined) startTime = 0;
if (endTime == undefined) endTime = 23000;

var anim = new PropertyAnim();
anim.name = prop.name;

anim.startValue = prop.valueAtTime(startTime,true);

if (prop.elided) return anim;

if (prop.isTimeVarying)
{
if (selectedKeysOnly)
{
for (var keyIndex = 0; keyIndex < prop.selectedKeys.length ; keyIndex++)
{
var key = Duik.utils.getKey(prop,prop.selectedKeys[keyIndex]);
if (key.time >= startTime && key.time <= endTime)
{
key.time = key.time - startTime;
anim.keys.push(key);
}
}
}
else if (prop.numKeys > 0)
{
for (var keyIndex = 1; keyIndex <= prop.numKeys ; keyIndex++)
{
var time = prop.keyTime(keyIndex);
if (time >= startTime && time <= endTime || allKeys)
{
var key = Duik.utils.getKey(prop,keyIndex);
if (!allKeys) key.time = key.time - startTime;
anim.keys.push(key);
}
}
}
}
return anim;
}
}
// SET PROPERTY ANIM
//return boolean
if (typeof Duik.utils.setPropertyAnim !== 'function')
{
Duik.utils.setPropertyAnim = function (prop,propAnim,startTime,ignoreName)
{
if (startTime == undefined) startTime = 0;
if (ignoreName == undefined) ignoreName = false;

var name = propAnim.name;
//trouver la propriete portant ce nom dans la prop demandee
if (prop.propertyType == PropertyType.PROPERTY && !prop.elided && prop.canVaryOverTime)
{
if (!ignoreName && prop.name == name || ignoreName)
{
//if there are keys, paste them
if (propAnim.keys.length > 0)
{
for (var iclef = 0; iclef < propAnim.keys.length;iclef++)
{
Duik.utils.addKey(prop,propAnim.keys[iclef],startTime);
}
}
else //set the start value
{
try { prop.setValue(propAnim.startValue); } catch (err) {};
}
return true;
}
}
else if (prop.numProperties != undefined)
{
if (prop.numProperties > 0)
{
for (var pi = 1;pi <= prop.numProperties;pi++)
{
if (Duik.utils.setPropertyAnim(prop.property(pi),propAnim,startTime)) return true;
}
}
}
return false;
}
}
// ADD KEY
//return void
if (typeof Duik.utils.addKey !== 'function')
{
Duik.utils.addKey = function (prop,key,startTime)
{
if (prop.elided) return;
if (startTime == undefined) startTime = 0;
var time = startTime+key.time;
try //au cas ou on est sur du XPosition alors que le calque est 2D, par exemple
{
var val = key.value;
var dimensions = val.length;

if (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.ThreeD)
{
if (dimensions == 2) val = [val[0],val[1],0];
if (dimensions == 1) val = [val[0],0,0];
}
else if (prop.propertyValueType == PropertyValueType.TwoD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD)
{
if (dimensions == 3) val = [val[0],val[1]];
if (dimensions == 1) val = [val[0],0];
}
else
{
if (dimensions > 1) val = val[0];
}


prop.setValueAtTime(time,val);
//get the index of the created key
var index = prop.nearestKeyIndex(time);
if (key.spatial && (prop.propertyValueType == PropertyValueType.ThreeD_SPATIAL || prop.propertyValueType == PropertyValueType.TwoD_SPATIAL))
{
prop.setSpatialContinuousAtKey(index,key.spatialProperties.continuous);
prop.setSpatialAutoBezierAtKey(index,key.spatialProperties.autoBezier);
prop.setRovingAtKey(index,key.spatialProperties.roving);
prop.setSpatialTangentsAtKey(index,key.spatialProperties.inTangent,key.spatialProperties.outTangent);
}
try {
prop.setTemporalContinuousAtKey(index,key.continuous);
prop.setTemporalAutoBezierAtKey(index,key.autoBezier);
prop.setTemporalEaseAtKey(index,key.inEase,key.outEase);
prop.setInterpolationTypeAtKey(index,key.inInterpolationType,key.outInterpolationType);
}
catch(err){}

}
catch (err)
{}
}
}
// GET FIRST KEYTIME in PropertyGroup (recursive)
//return int
if (typeof Duik.utils.getFirstKeyTime !== 'function')
{
Duik.utils.getFirstKeyTime = function (prop)
{
var firstKeyTime = 86339;

if (prop.propertyType == PropertyType.PROPERTY)
{
if (prop.selectedKeys.length > 0)
{
for (var key = 0;key<prop.selectedKeys.length;key++)
{
if (prop.keyTime(prop.selectedKeys[key]) < firstKeyTime)
{
firstKeyTime = prop.keyTime(prop.selectedKeys[key]);
}
}
}
}
else if (prop.numProperties > 0)
{
for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
{
testKeyTime = Duik.utils.getFirstKeyTime(prop.property(propIndex));
if (testKeyTime < firstKeyTime) firstKeyTime = testKeyTime;
}
}

return firstKeyTime;
}
}
// ARE THERE SELECTED KEYS in PropertyGroup
//return boolean
if (typeof Duik.utils.hasSelectedKeys !== 'function')
{
Duik.utils.hasSelectedKeys = function (prop)
{
var yes = false;

if (prop.propertyType == PropertyType.PROPERTY)
{
if (prop.selectedKeys.length >0)
{
yes = true;
}
}
else if (prop.numProperties > 0)
{
for (var propIndex = 1;propIndex <= prop.numProperties;propIndex++)
{
yes = Duik.utils.hasSelectedKeys(prop.property(propIndex));
if (yes) break;
}
}
return yes;
}
}
// ARE THERE SELECTED KEYS in Layers
//return boolean
if (typeof Duik.utils.layersHaveSelectedKeys !== 'function')
{
Duik.utils.layersHaveSelectedKeys = function (layrs)
{
var layers = Duik.utils.convertCollectionToArray(layrs);
for (var i = 0 ; i < layers.length ; i++)
{
if (Duik.utils.hasSelectedKeys(layers[i]))
{
return true;
}
}
return false;
}
}
// CONVERT COLLECTION TO Array
//return array
if (typeof Duik.utils.convertCollectionToArray !== 'function')
{
Duik.utils.convertCollectionToArray = function (collection)
{
var arr = [];
if (collection instanceof ItemCollection || collection instanceof LayerCollection || collection instanceof OMCollection || collection instanceof RQItemCollection)
{
for (var i = 1;i<=collection.length;i++)
{
arr.push(collection[i]);
}
}
else
{
arr = collection;
}
return arr;
}
}
// PREP LAYERS FOR IK
//return IKRig
if (typeof Duik.utils.prepIK !== 'function')
{
Duik.utils.prepIK = function (layrs)
{
rig = new IKRig();
if (layrs.length < 2) return rig;
if (layrs.length > 5) return rig;

var layers = Duik.utils.convertCollectionToArray(layrs);


if (layers.length == 2)
{
rig.type = 1;
rig.layer1 = layers[0];
rig.controller = layers[1];
}
else
{
//find controller
var found = false;
var ctrl = null;
for (var i = 0;i<layers.length;i++)
{
var l = layers[i];
var ok = true;
for (var j = 0;j<layers.length;j++)
{
if (i == j) continue;
var ll = layers[j];
if (l.parent != null)
{
if (l.parent == ll)
{
ok = false;
break;
}
}
if (ll.parent != null)
{
if (ll.parent == l)
{
ok = false;
break;
}
}
}
if (ok && found)
{
ctrl = null;
break;
}
else if (ok)
{
found = true;
ctrl = l;
}
}

var valid = true;
if (ctrl == null) valid = false;
var sortedLayers = [];
if (valid)
{
//sort layers
//find the one which has no parents, will be the root (first)
var first = null;
for (var i = 0;i<layers.length;i++)
{
var l = layers[i];
if (l == ctrl) continue;
var ok = true;
//search if l has a parent
for (var j = 0;j<layers.length;j++)
{
if (l.parent == layers[j])
{
ok = false;
break;
}
}
//if a parent is found, skip
if (!ok) continue;
//if we haven't found it already
if (first == null)
{
first = l;
}
//else break
else
{
first = null;
break;
}
}

if (first != null)
{
sortedLayers.push(first);
//find children
while (sortedLayers.length < layers.length-1)
{
var found = false;
var ok = true;
for (var i = 0;i<layers.length;i++)
{
var l = layers[i];
if (l == ctrl) continue;
if (l.parent != null)
{
if (l.parent == sortedLayers[sortedLayers.length-1])
{
if (found)
{
ok = false;
break;
}
else
{
sortedLayers.push(l);
}
}
}
}
if (!ok) break;
}
}
}
if (sortedLayers.length != layers.length-1) valid = false;

if (layers.length == 3)
{
if (valid)
{
rig.layer1 = sortedLayers[0];
rig.layer2 = sortedLayers[1];
rig.controller = ctrl;
}
else
{
rig.layer1 = layers[1];
rig.layer2 = layers[0];
rig.controller = layers[2];
}
//2 layer or 1+goal ?
if (Duik.utils.getDistance(rig.layer2,rig.controller) < 10)
{
rig.goal = rig.layer2;
rig.layer2 = null;
rig.type = 1;
}
else
{
rig.type = 2;
}
}
else if (layers.length == 4)
{
if (valid)
{
rig.layer1 = sortedLayers[0];
rig.layer2 = sortedLayers[1];
rig.layer3 = sortedLayers[2];
rig.controller = ctrl;
}
else
{
rig.layer1 = layers[2];
rig.layer2 = layers[1];
rig.layer3 = layers[0];
rig.controller = layers[3];
}
//3 layer or 2+goal ?
if (Duik.utils.getDistance(rig.layer3,rig.controller) < 10)
{
rig.goal = rig.layer3;
rig.layer3 = null;
rig.type = 2;
}
else
{
rig.type = 3;
}
}
else if (layers.length == 5)
{
if (valid)
{
rig.layer1 = sortedLayers[0];
rig.layer2 = sortedLayers[1];
rig.layer3 = sortedLayers[2];
rig.goal = sortedLayers[3];
rig.controller = ctrl;
rig.type = 3;
}
else
{
rig.layer1 = layers[3];
rig.layer2 = layers[2];
rig.layer3 = layers[1];
rig.goal = layers[0];
rig.controller = layers[4];
rig.type = 3;
}
}
}

//detect 3d
var threeD = true;
for (var i = 0 ; i < layers.length ; i++)
{
if (!layers[i].threeDLayer)
{
threeD = false;
break;
}
}
rig.threeD = threeD;

//Detect frontFacing if 3D
//add a point effect on the layer to get values with expressions
if (threeD)
{
var tempEffect = rig.layer1.effect.addProperty("ADBE Point3D Control");
tempEffect(1).expression = "C = thisComp.layer(\"" + rig.layer1.name + "\");\n" +
"u = C.toWorldVec([1,0,0]);\n" +
"v = C.toWorldVec([0,1,0]);\n" +
"w = C.toWorldVec([0,0,1]);\n" +
"sinb = clamp(w[0],-1,1);\n" +
"b = Math.asin(sinb);\n" +
"cosb = Math.cos(b);\n" +
"if (Math.abs(cosb) > .0005){\n" +
"c = -Math.atan2(v[0],u[0]);\n" +
"a = -Math.atan2(w[1],w[2]);\n" +
"}else{\n" +
"a = Math.atan2(u[1],v[1]);\n" +
"c = 0;\n" +
"}\n" +
"xValue=Math.round(radiansToDegrees(a));\n" +
"yValue=Math.round(radiansToDegrees(b));\n" +
"zValue=Math.round(radiansToDegrees(c));\n" +
"[(xValue),(yValue),(zValue)]\n";
var orientation = tempEffect(1).value;
rig.frontFacing = false;
if (orientation[0]%180 > 10 || orientation[1]%90 >10) rig.threeD = false;
else if (orientation[1]%180 < 10) rig.frontFacing = true;
tempEffect.remove();
}

//Detect clockwise if IK is of type 2
if (rig.type == 2 || rig.type == 3)
{
rig.clockWise = Duik.utils.isIKClockwise(rig.layer1,rig.layer2,rig.controller);
}

return rig;
}
}
// GET CONTROLLERS
//return Array of Controllers
if (typeof Duik.utils.getControllers !== 'function')
{
Duik.utils.getControllers = function (layrs)
{
if (layrs == undefined) layrs = app.project.activeItem.layers;
else if (layrs.length == 0) layrs = app.project.activeItem.layers;
var layers = Duik.utils.convertCollectionToArray(layrs);

var controllers = [];

for (var i = 0 ; i< layers.length; i++)
{
var l = layers[i];
if (l instanceof ShapeLayer)
{
var iconGroup = l.property("ADBE Root Vectors Group")("Icon");
if (iconGroup == null) continue;
var controller = new Controller();
controller.type = Duik.layerTypes.VECTOR;
controller.layer = l;
controller.size = iconGroup("ADBE Vector Transform Group")("ADBE Vector Scale").value[0];
//check properties
for (var j = 1 ; j <= iconGroup("ADBE Vectors Group").numProperties ; j++)
{
if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "rotation")
{
controller.rotation = true;
controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
}
else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "xposition")
{
controller.xPosition = true;
controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
}
else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "yposition")
{
controller.yPosition = true;
controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
}
else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "scale")
{
controller.scale = true;
controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
}
else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "arc")
{
controller.arc = true;
controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
}
else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "eye")
{
controller.eye = true;
controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")(2)("ADBE Vectors Group")("ADBE Vector Graphic - Stroke")("ADBE Vector Stroke Color").value;
}
else if (iconGroup("ADBE Vectors Group")(j).name.toLowerCase() == "camera")
{
controller.camera = true;
controller.color = iconGroup("ADBE Vectors Group")(j)("ADBE Vectors Group")("ADBE Vector Graphic - Fill")("ADBE Vector Fill Color").value;
}
}
controllers.push(controller);
}
else if (l instanceof AVLayer && l.name.indexOf("C_") == 0)
{
var controller = new Controller();
controller.type = Duik.layerTypes.NULL;
controller.layer = l;
controllers.push(controller);
}
}
return controllers;
}
}
// GET EXPRESSION LINK
//returns string
if (typeof Duik.utils.getExpressionLink !== 'function')
{
	Duik.utils.getExpressionLink = function (prop)
	{
		//get compact expression from matchName, if available
		function getCompactExpression(prop, matchName, name)
		{
			var translatedName = Duik.expressions.compactExpressions[matchName];
			
			if (translatedName !== undefined)
				return eval(translatedName);
			else
				return ("(" + name + ")");
		}
		
		var exprCode = "";
		var name;
		while (prop.parentProperty !== null)
		{			
			if (prop.propertyType == PropertyType.PROPERTY ) name = prop.propertyIndex;
			else name = "\"" + prop.name + "\"";
			compactName = getCompactExpression(prop, prop.matchName, name);
			exprCode = compactName + exprCode;

			// Traverse up the property tree
			prop = prop.parentProperty;
		}
		
		var comp = prop.containingComp;
		// Prefix the layer reference
		name = "\"" + prop.name + "\"";
		exprCode = "layer(" + name + ")." + exprCode;
		// Prefix the comp reference
		exprCode = "comp(\"" + comp.name + "\")." + exprCode;
		
		return exprCode;
	}
}
// PICKWHIP
//returns void
if (typeof Duik.utils.pickWhip !== 'function')
{
	Duik.utils.pickWhip = function (childProp,parentProp)
	{
		if (!childProp.canSetExpression) return;

		childProp.expression = Duik.utils.getExpressionLink(parentProp);
	}
}
// LINK PROPERTIES
//returns void
if (typeof Duik.utils.linkProperties !== 'function')
{
Duik.utils.linkProperties = function (childProp,parentProp)
{
for (var p = 1 ; p <= childProp.numProperties ; p++)
{
if (childProp(p).propertyType == PropertyType.PROPERTY && !childProp(p).elided)
{
//copy paste the animation / value
var anim = Duik.utils.getPropertyAnim(childProp(p),false,true);
if (anim != null) Duik.utils.setPropertyAnim(parentProp(p),anim,0,true);
//get the expression
if (parentProp(p).canSetExpression && childProp(p).expression != "")
{
try { parentProp(p).expression = childProp(p).expression; }
catch (err) {};
}
//set the link
Duik.utils.pickWhip(childProp(p),parentProp(p));
}
else
{
Duik.utils.linkProperties(childProp(p),parentProp(p));
}
}
}
}
// SMART COMP DUPLICATE: DUPLICATE COMP
//returns void
if (typeof Duik.utils.duplicateComp !== 'function')
{
Duik.utils.duplicateComp = function (comp,prefix)
{

if (Duik.settings.displayProgressPanel) Duik.ui.showProgressPanel(100,"Duplicating " + comp.name);

var previousComps = [];

//NEEDED FUNCTIONS

//gets an item with its ID
function getItemWithID(id)
{
for (var x=1; x<=app.project.numItems; x++)
{
if (app.project.item(x).id == id)
{
return app.project.item(x);
}
}
return null;
}

//duplicates a comp (recursive through precomps)
function duplicateStructure(comp,parentFolder,prefix) {
// Duplicate the incoming comp
var newCompName = prefix + comp.name;
var comp = comp.duplicate();
comp.name = newCompName;

// For each layer in the comp, check for subcomps
for (var i=1; i<=comp.numLayers; i++)
{
var layer = comp.layer(i);
//Check if layer has a source and that its type is a composition
if (layer.source)
{
if (layer.source instanceof CompItem)
{
// Check if this comp has already been duplicated
var check = null;
if (previousComps[layer.source.id])
{
check = getItemWithID(previousComps[layer.source.id]);
}

if (check == null)
{
// The subcomp hasn't been duplicated before

// Store the original comp id to remember the correlation
var sourceID = layer.source.id;
// Replace the source of the layer, and recursively check in that subcomp for sub-subcomps
layer.replaceSource(duplicateStructure(layer.source, parentFolder,prefix), false);
// Store the new comp id to remember the correlation
var destID = layer.source.id;
//Add the correlation to an array
previousComps[sourceID] = destID;
} else
{
// Replace the source with the already duplicated comp
layer.replaceSource(check, false);
}
}

}
}

//Move the comp to the folder
comp.parentFolder = parentFolder;

// For the recursion, return the duplicated comp
return comp;
}

//LET's GO

//create a new folder
var parentFolder = app.project.items.addFolder(prefix + comp.name);

// If the mainComp is not in the root of the project, then put the new folder on the same hierarchy level as the original parent folder
if (comp.parentFolder.parentFolder)
{
parentFolder.parentFolder = comp.parentFolder.parentFolder;
} else
{
parentFolder.parentFolder = comp.parentFolder;
}

if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(1,"Duplicating precomps");

//go
var newMainComp = duplicateStructure(comp, parentFolder,prefix);

//add the main comp to the comps duplicated
previousComps[comp.id] = newMainComp.id;

if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(2,"Updating expressions");

//update expressions
for (var i=0;i<previousComps.length;i++ )
{
//for each comp, get the new name
var oldComp = getItemWithID(i);
if (!oldComp) continue;
var newComp = getItemWithID(previousComps[i]);
if (!newComp) continue;
var oldName = oldComp.name;
var newName = newComp.name;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(Duik.ui.progressBar.value + 1,"Updating expressions: " + newName);
//in all comps, update the name in the expressions
for (var j=0;j<previousComps.length;j++ )
{
var oldComp2 = getItemWithID(j);
if (!oldComp2) continue;
var newComp2 = getItemWithID(previousComps[j]);
if (!newComp2) continue;
//double quotes
var old = "comp(\"" + oldName + "\"";
var newExpr = "comp(\"" + newName + "\"";
Duik.utils.replaceInLayersExpressions(newComp2.layers,old,newExpr);
//single quotes
var old = "comp('" + oldName + "'";
var newExpr = "comp('" + newName + "'";
Duik.utils.replaceInLayersExpressions(newComp2.layers,old,newExpr);
}
}

if (Duik.settings.displayProgressPanel) Duik.ui.hideProgressPanel();

return newMainComp;
}
}
// REPLACE IN EXPRESSIONS - Duik.utils.replaceInExpressions(prop,oldString,newString,caseSensitive)
if (typeof Duik.utils.replaceInExpressions !== 'function')
{
Duik.utils.replaceInExpressions = function (prop,oldString,newString,caseSensitive)
{
if (prop.propertyType == PropertyType.PROPERTY)
{
if (prop.canSetExpression)
{
var expr = prop.expression;
expr = Duik.js.replaceAll(expr,oldString,newString,caseSensitive);
try { prop.expression = expr; }
catch(err){};
delete expr;
}
}
else if (prop.numProperties > 0)
{
for (var propertyIndex = 1;propertyIndex <= prop.numProperties;propertyIndex++)
{
Duik.utils.replaceInExpressions(prop.property(propertyIndex),oldString,newString);
}
}
}
}
/* REPLACE IN LAYERS EXPRESSIONS - Duik.utils.replaceInLayersExpressions(layers,oldString,newString,caseSensitive);

Replaces all occurences of oldString by newString in all the expressions of all the layers.

parameters
layers | Array of AVLayers or LayerCollection
oldString | string
newString | string

returns
void

*/
if (typeof Duik.utils.replaceInLayersExpressions !== 'function')
{
	Duik.utils.replaceInLayersExpressions = function (layrs,oldString,newString,caseSensitive)
	{
		if (caseSensitive == undefined) caseSensitive = true;
		var layers = Duik.utils.convertCollectionToArray(layrs);
		for (var layerIndex = 0 ; layerIndex<layers.length ; layerIndex++)
		{
			var l = layers[layerIndex];
			var locked = l.locked;
			l.locked = false;
			Duik.utils.replaceInExpressions(l,oldString,newString,caseSensitive);
			l.locked = locked;
			delete l;
			delete locked;
		}
	}
}
// RENAME LAYER
if (typeof Duik.utils.renameLayer !== 'function')
{
Duik.utils.renameLayer = function (layer,newName,updateExpressions,currentComp)
{
if (layer == undefined) return;
if (newName == undefined) return;
if (newName == "") return;
if (updateExpressions == undefined) updateExpressions = true;

app.beginSuppressDialogs();

var oldName = layer.name;
layer.name = newName;

var compName = layer.containingComp.name;
//update expressions
if (updateExpressions)
{

//all items
if (!currentComp)
{
for (var j = 1;j<=app.project.items.length;j++)
{
var comp = app.project.item(j);
if (comp instanceof CompItem)
{
try
{
//double quotes
var old = "comp(\"" + compName + "\").layer(\"" + oldName + "\"";
var newExpr = "comp(\"" + compName + "\").layer(\"" + newName + "\"";
Duik.utils.replaceInLayersExpressions(comp.layers,old,newExpr);
//single quotes
var old = "comp('" + compName + "').layer('" + oldName + "'";
var newExpr = "comp('" + compName + "').layer('" + newName + "'";
Duik.utils.replaceInLayersExpressions(comp.layers,old,newExpr);
}
catch (err) {};
}
}
}

//containing comp (thisComp)
try
{
//double quotes
var old = "layer(\"" + oldName + "\"";
var newExpr = "layer(\"" + newName + "\"";
Duik.utils.replaceInLayersExpressions(app.project.activeItem.layers,old,newExpr);
//single quotes
var old = "layer('" + oldName + "'";
var newExpr = "layer('" + newName + "'";
Duik.utils.replaceInLayersExpressions(app.project.activeItem.layers,old,newExpr);
}
catch (err) {};
}

app.endSuppressDialogs(false);
}
}
// RENAME ITEM
if (typeof Duik.utils.renameItem !== 'function')
{
Duik.utils.renameItem = function (item,newName,updateExpressions)
{
if (item == undefined) return;
if (newName == undefined) return;
if (newName == "") return;
if (updateExpressions == undefined) updateExpressions = true;

var oldName = item.name;
item.name = newName;


app.beginSuppressDialogs();

//update expressions
if (updateExpressions && item instanceof CompItem)
{
for (var j = 1;j<=app.project.items.length;j++)
{
var comp = app.project.item(j);
if (comp instanceof CompItem)
{
try
{
//double quotes
var old = "comp(\"" + oldName + "\"";
var newExpr = "comp(\"" + newName + "\"";
Duik.utils.replaceInLayersExpressions(comp.layers,old,newExpr);
//single quotes
var old = "comp('" + oldName + "'";
var newExpr = "comp('" + newName + "'";
Duik.utils.replaceInLayersExpressions(comp.layers,old,newExpr);
}
catch (err) {};
}
}
}

app.endSuppressDialogs(false);
}
}
// GET PROP LAYER
if (typeof Duik.utils.getPropertyLayer !== 'function')
{
Duik.utils.getPropertyLayer = function (prop)
{
if (prop == undefined) return null;
var parentProp = prop;
while (parentProp.parentProperty !== null)
{
// Traverse up the property tree
parentProp = parentProp.parentProperty;
}
return parentProp;
}
}
// GET PROP COMP
if (typeof Duik.utils.getPropertyComp !== 'function')
{
Duik.utils.getPropertyComp = function (prop)
{
var layer = Duik.utils.getPropertyLayer(prop);
return layer.containingComp;
}
}
// AUTO RENAME EFFECT
if (typeof Duik.utils.renameEffect !== 'function')
{
Duik.utils.renameEffect = function (effect,name)
{
var layer = Duik.utils.getPropertyLayer(effect);
var ok = false;
var num = 1;
while(!ok)
{
ok = true;
for (var i = 1;i<=layer.effect.numProperties;i++)
{
if (layer.effect(i).name == name)
{
if (num == 1)
{
name = name + "_";
}
num++;
name = name.substr(0,name.lastIndexOf("_")+1) + num;
ok = false;
break;
}
}
}
effect.name = name;
}
}
// GET FOOTAGE EXPOSURE
if (typeof Duik.utils.getFootageExposure !== 'function')
{
Duik.utils.getFootageExposure = function (layer,accuracy,tolerance,r,g,b,a)
{
if (layer == undefined) return [];
var comp = layer.containingComp;
if (accuracy == undefined) accuracy = 50;
precision = accuracy / 100;
if (tolerance == undefined) tolerance = 10;
tolerance = tolerance/1000;
if (r == undefined) r = true;
if (g == undefined) g = true;
if (b == undefined) b = true;
if (a == undefined) a = false;

var numSamplesX = 10;
var numSamplesY = numSamplesX;

//detected expo
var detectedExposure = [];

//Expression to get samples

exp = "var numSamplesX = " + numSamplesX + ";\n" +
"var numSamplesY = " + numSamplesY + ";\n" +
"var precision = " + precision + ";\n" +
"var result = [0,0,0,0];\n" +
"for ( i = 1 ; i <= numSamplesX ; i++)\n" +
"for (j = 1 ; j <= numSamplesY ; j++)\n" +
"result = result + sampleImage([i*(width/numSamplesX)-(width/numSamplesX/2),j*(height/numSamplesY)-(height/numSamplesY/2)],[width/2/numSamplesX*precision,height/2/numSamplesY*precision]);\n" +
"result = result/(numSamplesX+numSamplesY);"
"result;";

//color
var color = layer.Effects.addProperty("ADBE Color Control");
var colorProp = color(1);
colorProp.expression = exp;

//add keyframes
var frames = comp.duration / comp.frameDuration;
var inFrame = layer.inPoint / comp.frameDuration;
var outFrame = layer.outPoint / comp.frameDuration;
if (inFrame < 0) inFrame = 0;
if (outFrame > (comp.duration/comp.frameDuration)) outFrame = comp.duration /comp.frameDuration;

if (Duik.settings.displayProgressPanel) Duik.ui.showProgressPanel(outFrame-inFrame,"Exposure detection from layer " + layer.name);

var prevColor = colorProp.valueAtTime(layer.inPoint,false);

detectedExposure.push(layer.inPoint);

var progressValue = 0;
for (var frame = inFrame ; frame < outFrame ; frame++)
{
progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Exposure detection: " + layer.name + " - Frame: " + frame);
var time = frame*comp.frameDuration;
comp.time = time;
if (Duik.aeVersion >= 13.5)
{
$.sleep(500);
}
var hasChanged = false;
var currentColor = colorProp.valueAtTime(time,false);
var rVariation = Math.abs(prevColor[0] - currentColor[0]);
var gVariation = Math.abs(prevColor[1] - currentColor[1]);
var bVariation = Math.abs(prevColor[2] - currentColor[2]);
var aVariation = Math.abs(prevColor[3] - currentColor[3]);
if (r && rVariation > tolerance )
{
hasChanged = true;
}
else if (g && gVariation > tolerance )
{
hasChanged = true;
}
else if (b && bVariation > tolerance )
{
hasChanged = true;
}
else if (a && aVariation > tolerance )
{
hasChanged = true;
}

if (hasChanged)
{
detectedExposure.push(time);
prevColor = currentColor;
}
}

if (Duik.settings.displayProgressPanel) Duik.ui.hideProgressPanel();

color.remove();

if (Duik.settings.displayProgressPanel) Duik.ui.hideProgressPanel();

Duik.detectedExposure = detectedExposure;

return detectedExposure;
}
}
// STEP SELECTED PROPERTIES
if (typeof Duik.utils.stepSelectedProperties !== 'function')
{
Duik.utils.stepSelectedProperties = function (layrs)
{
var layers = Duik.utils.convertCollectionToArray(layrs);
for (var i = 0 ; i < layers.length ; i++)
{
var layer = layers[i];
if (layer.selectedProperties.length == 0) continue;
for (var j = 0 ; j < layer.selectedProperties.length ; j++)
{
var prop = layer.selectedProperties[j];
if (prop.propertyType != PropertyType.PROPERTY) continue;
if (prop.numKeys == 0) continue;
for (var keyIndex = 1;keyIndex <= prop.numKeys;keyIndex++)
{
prop.setInterpolationTypeAtKey(keyIndex,KeyframeInterpolationType.HOLD,KeyframeInterpolationType.HOLD);
}
}
}
}
}
// ADD NULL ON LAYER
if (typeof Duik.utils.addNullOnLayer !== 'function')
{
Duik.utils.addNullOnLayer = function (layer)
{
if (layer == undefined) return null;
layerParent = layer.parent;
layer.parent = null;
var nullLayer = layer.containingComp.layers.addNull();
nullLayer.transform.position.setValue(layer.transform.position.value);
layer.parent = layerParent;
nullLayer.moveBefore(layer);
nullLayer.name = "N_" + layer.name;
return nullLayer;
}
}
// IS IK Clockwise
if (typeof Duik.utils.isIKClockwise !== 'function')
{
Duik.utils.isIKClockwise = function (root,middle,end)
{
if (root == undefined) return false;
if (middle == undefined) return false;
if (end == undefined) return false;

//unparent
var rootParent = root.parent;
root.parent = null;
var middleParent = middle.parent;
middle.parent = null;
var endParent = end.parent;
end.parent = null;

var endPos = end.transform.position.value - root.transform.position.value;
var middlePos = middle.transform.position.value - root.transform.position.value;
var coef = endPos[1]/endPos[0];

var clockwise = false;

if (middlePos[1] < middlePos[0]*coef && endPos[0] > 0) clockwise = true;
if (middlePos[1] > middlePos[0]*coef && endPos[0] < 0) clockwise = true;

//reparent
root.parent = rootParent;
middle.parent = middleParent;
end.parent = endParent;

return clockwise;
}
}
// GET LAYER BY PARTIAL NAME
if (typeof Duik.utils.getLayerByName !== 'function')
{
Duik.utils.getLayerByName = function (layrs,name)
{
if (layrs == undefined) return null;
if (name == undefined) return null;

var layers = Duik.utils.convertCollectionToArray(layrs);

var layer = null;

for (var i = 0; i < layers.length ; i++)
{
if (layers[i].name.toLowerCase().indexOf(name.toLowerCase()) >= 0 )
{
layer = layers[i];
break;
}
}

return layer;
}
}
// GET LAYER BY PARTIAL NAMES
if (typeof Duik.utils.getLayerByNames !== 'function')
{
Duik.utils.getLayerByNames = function (layrs,names)
{
if (layrs == undefined) return null;
if (names == undefined) return null;

var layers = Duik.utils.convertCollectionToArray(layrs);

var layer = null;

for (var i = 0 ; i < names.length ; i++)
{
layer = Duik.utils.getLayerByName(layers,names[i]);
if (layer) break;
}

return layer;
}
}
// GET LAYERS BY PARTIAL NAME
if (typeof Duik.utils.getLayersByName !== 'function')
{
Duik.utils.getLayersByName = function (layrs,name)
{
if (layrs == undefined) return null;
if (name == undefined) return null;

var layers = Duik.utils.convertCollectionToArray(layrs);

var results = [];

for (var i = 0; i < layers.length ; i++)
{
if (layers[i].name.toLowerCase().indexOf(name.toLowerCase()) >= 0 )
{
results.push(layers[i]);
}
}

return results;
}
}
// GET LAYERS BY PARTIAL NAMES
if (typeof Duik.utils.getLayersByNames !== 'function')
{
Duik.utils.getLayersByNames = function (layrs,names)
{
if (layrs == undefined) return null;
if (names == undefined) return null;

var layers = Duik.utils.convertCollectionToArray(layrs);

var results = [];

for (var i = 0 ; i < names.length ; i++)
{
results = results.concat(Duik.utils.getLayersByName(layers,names[i]));
}

return results;
}
}
// GET LAYER READABLE LIST: Index - Name
if (typeof Duik.utils.getLayersReadableList !== 'function')
{
Duik.utils.getLayersReadableList = function (layrs)
{
var list = [];

if (layrs == undefined) return list;

var layers = Duik.utils.convertCollectionToArray(layrs);

for (var i = 0 ; i < layers.length ; i++)
{
list.push(layers[i].index + " - " + layers[i].name);
}

return list;
}
}
// SORT LAYERS BY DISTANCE FROM REF
if (typeof Duik.utils.sortByDistance !== 'function')
{
Duik.utils.sortByDistance = function (layrs,from)
{
if (layrs == undefined) return layrs;

var layers = Duik.utils.convertCollectionToArray(layrs);

var fromPos = Duik.utils.getWorldPos(from);

function sorter(l1,l2)
{
var l1Pos = Duik.utils.getWorldPos(l1);
var l2Pos = Duik.utils.getWorldPos(l2);

var l1d = Duik.utils.getLength(l1Pos,fromPos);
var l2d = Duik.utils.getLength(l2Pos,fromPos);

return l1d-l2d;
}

if (layers.length >= 2) layers.sort(sorter);

return layers;
}
}
// GET WORLD POSITION
if (typeof Duik.utils.getWorldPos !== 'function')
{
Duik.utils.getWorldPos = function (l)
{
if (!l) return [];
var p = l.parent;
l.parent = null;
var pos = l.transform.position.value;
l.parent = p;
return pos;
}
}
//SORT LAYERS BY INDEX
if (typeof Duik.utils.sortLayersByIndex !== 'function')
{
Duik.utils.sortLayersByIndex = function (layrs)
{
var layers = Duik.utils.convertCollectionToArray(layrs);
function compareLayerIndexes(lay1,lay2)
{
return lay1.index-lay2.index;
}
return layers.sort(compareLayerIndexes);
}
}
//CONVERT HEX COLOR TO RVB
if (typeof Duik.utils.hexColorToRVB !== 'function')
{
Duik.utils.hexColorToRVB = function (hexColor,isString)
{
if (isString == undefined) isString = true;
if (isString)
{
if (hexColor.indexOf("#") == 0) hexColor = hexColor.replace("#","");
var red = parseInt(hexColor.substr(0,2),16)/255.0;
var green = parseInt(hexColor.substr(2,2),16)/255.0;
var blue = parseInt(hexColor.substr(4,2),16)/255.0;
return [red,green,blue];
}
else
{
var r = hexColor >> 16;
var g = (hexColor & 0x00ff00) >> 8;
var b = hexColor & 0xff;
return [r/255,g/255,b/255,1];
}
}
}
//CONVERT RVB COLOR TO HEX
if (typeof Duik.utils.rvbColorToHex !== 'function')
{
Duik.utils.rvbColorToHex = function (rvbColor)
{
var red = rvbColor[0]*255;
var green = rvbColor[1]*255;
var blue = rvbColor[2]*255;
var hexR = red.toString(16)
var hexG = green.toString(16)
var hexB = blue.toString(16);
if (hexR.length == 1) hexR = "0" + hexR;
if (hexG.length == 1) hexG = "0" + hexG;
if (hexB.length == 1) hexB = "0" + hexB;
var hex = hexR+hexG+hexB;
return hex;
}
}
//ADD LAYER TO DUGROUP
if (typeof Duik.utils.addLayerToDuGroup !== 'function')
{
Duik.utils.addLayerToDuGroup = function (layer,group)
{
var groupComment = '|' + group + '| ';
if (layer.comment.indexOf(groupComment) < 0)
{
layer.comment = layer.comment + groupComment;
}
}
}
//RANDOM COLOR
if (typeof Duik.utils.randomColor !== 'function')
{
Duik.utils.randomColor = function ()
{
	var color = [0,0,0,1];
	for (var i = 0 ; i < 3 ; i++)
	{
		color[i] = Math.random();
		$.sleep(10);
	}
	return color;
}
}
}

//================================
//========== AUTORIG =============
//================================

if (typeof Duik.autorig !== 'object')
{
Duik.autorig = {};

//VERTEBRATE
if (typeof Duik.autorig.vertebrate !== 'object')
{
Duik.autorig.vertebrate = {};
Duik.autorig.vertebrate.digitigrade = {};
Duik.autorig.vertebrate.plantigrade = {};
Duik.autorig.vertebrate.ungulate = {};

//SPINE
Duik.autorig.vertebrate.spine = function (hips,back,neck,head) {
if (!head) return null;
if (!hips && !back) return null;

if (neck) if (neck.length == 0) neck = null;
if (back) if (back.length == 0) back = null;

//unparent
var hipsParent = null;
if (hips) {
hipsParent = hips.parent;
hips.parent = null;
}
if (back) for (var i=0;i<back.length;i++ ) back[i].parent = null;
if (neck) for (var i=0;i<neck.length;i++ ) neck[i].parent = null;
if (head) head.parent = null;

var controllers = [];

//controllers
var hipsCtrl = null;
var bigHipsCtrl = null;
var shoulderCtrl = null;
var headCtrl = null;
if (hips) {
bigHipsCtrl = Duik.addController(hips,true,true,true,true,false);
hipsCtrl = Duik.addController(bigHipsCtrl.layer,true,true,true,true,false);
bigHipsCtrl.size = bigHipsCtrl.size*1.5;
bigHipsCtrl.color = bigHipsCtrl.color *0.5;
bigHipsCtrl.update();

}
else if (back) {
bigHipsCtrl = Duik.addController(back[back.length-1],true,true,true,true,false);
hipsCtrl = Duik.addController(bigHipsCtrl.layer,true,true,true,true,false);
bigHipsCtrl.size = bigHipsCtrl.size*1.5;
bigHipsCtrl.color = bigHipsCtrl.color *0.5;
bigHipsCtrl.update();
}
controllers.push(bigHipsCtrl);
controllers.push(hipsCtrl);
if (neck) {
shoulderCtrl = Duik.addController(neck[neck.length-1],true,true,true,true,false);
shoulderCtrl.layer.name = "C_Shoulders";
controllers.push(shoulderCtrl);
headCtrl = Duik.addController(head,false,true,false,false,false);
}
else
{
	headCtrl = Duik.addController(head,false,true,true,true,false);
}
controllers.push(headCtrl);

//parent
//bones
if (hips) {
hips.parent = hipsCtrl.layer;
}
if (back) {
if (!hips) back[back.length-1].parent = hipsCtrl.layer;
else back[back.length-1].parent = hips;
}
if (neck) {
if (back) neck[neck.length-1].parent = back[0];
else neck[neck.length-1].parent = hips;
for (var i = 0;i<neck.length-1;i++) {
neck[i].parent = neck[i+1];
}
}
if (head) {
if (neck) head.parent = neck[0];
else if (back) head.parent = back[0];
else if (hips) head.parent = hips;
}
//controllers
bigHipsCtrl.layer.parent = hipsParent;
hipsCtrl.layer.parent = bigHipsCtrl.layer;
if (shoulderCtrl) {
shoulderCtrl.layer.parent = bigHipsCtrl.layer;
headCtrl.layer.parent = shoulderCtrl.layer;
}
else {
headCtrl.layer.parent = bigHipsCtrl.layer;
}
headCtrl.lock();

//IK
if (hips && !back) {
if (shoulderCtrl) Duik.autoIK([hips,shoulderCtrl.layer]);
else Duik.autoIK([hips,headCtrl.layer]);
}
else if (back.length == 1) {
if (shoulderCtrl) Duik.autoIK([back[0],shoulderCtrl.layer]);
else Duik.autoIK([back[0],headCtrl.layer]);
}
else {
var bezLayers = back;
var rootNull = Duik.utils.addNullOnLayer(back[back.length-1]);
rootNull.parent = hipsCtrl.layer;
rootNull.name = "IK " + back[back.length-1].name;
if (shoulderCtrl) bezLayers.push(shoulderCtrl.layer);
else bezLayers.push(headCtrl.layer);
bezLayers.push(rootNull);
var backCurveCtrl = Duik.bezierIK(bezLayers);
backCurveCtrl.layer.parent = bigHipsCtrl.layer;
controllers.push(backCurveCtrl);
rootNull.shy = true;
rootNull.enabled = false;
rootNull.locked = true;
delete bezLayers;
}

//controls
//neck
if (neck) {
var goalCtrl;
var goalCtrlLayerName = "";
if (shoulderCtrl) {
goalCtrl = shoulderCtrl.layer.effect.addProperty("ADBE Checkbox Control");
goalCtrlLayerName = shoulderCtrl.layer.name;
}
else {
goalCtrl = headCtrl.layer.effect.addProperty("ADBE Checkbox Control");
goalCtrlLayerName = headCtrl.layer.name;
}
goalCtrl.name = neck[neck.length-1].name + " goal";
goalCtrl(1).setValue(1);

for (var i=0;i<neck.length;i++ )
{
	var l = neck[i];
	var torsoName = "";
	var torsoRot = 0;
	var torsoCount = 1;
	if (back)
	{
		torsoName = back[0].name;
		torsoRot = back[0].transform.rotation.value;
		torsoCount = back.length;
	}
	else
	{
		torsoName = hips.name;
		torsoRot = hips.transform.rotation.value;
	}
	var hipsName = hipsCtrl.layer.name;
	var exp = "//Duik.neck\n" +
	"var goal = thisComp.layer(\"" + goalCtrlLayerName + "\").effect(\"" + goalCtrl.name + "\")(1) == 1;\n" +
	"var torso = thisComp.layer(\"" + torsoName + "\").rotation;\n" +
	"var hips = thisComp.layer(\"" + hipsName + "\").rotation;\n" +
	"var ctrl = thisComp.layer(\"" + shoulderCtrl.layer.name + "\").rotation;\n" +
	"var numNeckLayers = " + neck.length + ";\n" +
	"var numTorsoLayers = " + torsoCount + ";\n" +
	"var result = value;\n" +
	"result = result + ctrl/numNeckLayers;\n" +
	"if (numTorsoLayers == 1) torso = torso + hips;\n" + 
	"if (torso < 180+" + torsoRot + ") torso += 360;\n" +
	"goal ? result-torso/numNeckLayers+(360+" + torsoRot + ")/numNeckLayers : result;";

	l.transform.rotation.expression = exp;
}
}

//head
Duik.goal(head,headCtrl.layer);

return controllers;

}

//TAIL
Duik.autorig.vertebrate.tail = function (hips,tail,cubic) {
if (!hips) return;
if (!tail) return;
if (!tail.length) return;

if (cubic == undefined) cubic = false;

//unparent
for (var i=0;i<tail.length;i++ ) tail[i].parent = null;

var controllers = [];

//controllers
var tailCtrl = Duik.addController(tail[0],false,false,true,true,false);
controllers.push(tailCtrl);

var tailCtrlPos = [0,0,0];
var endPos = tail[tail.length-1].transform.position.value;
var prevPos = tail.length > 1 ? tail[tail.length-2].transform.position.value : hips.transform.position.value;

tailCtrlPos = endPos + [endPos[0]-prevPos[0],endPos[1]-prevPos[1],0];

tailCtrl.layer.transform.position.setValue(tailCtrlPos);

//IK
var numCtrl = cubic ? 2 : 1;
var rootNull = Duik.utils.addNullOnLayer(tail[0]);
rootNull.parent = hips;
rootNull.name = "IK " + tail[0].name;
var bezLayers = tail.reverse();
bezLayers.push(tailCtrl.layer);
bezLayers.push(rootNull);
var curveCtrls = Duik.bezierIK(bezLayers,numCtrl);

rootNull.shy = true;
rootNull.enabled = false;
rootNull.locked = true;

controllers = controllers.concat(curveCtrls);

tailDialog.hide();
return controllers;
}

//-------DIGITIGRADE---------

//FRONT LEG
Duik.autorig.vertebrate.digitigrade.frontLeg = function (shoulder,humerus,radius,carpus,claws,tiptoe)
{
//checks
if (claws && !humerus) return null;
if (claws && !radius) return null;
if ( !carpus) return null;

//unparent
if (radius && humerus) radius.parent = null;
if (carpus && (humerus || tibia)) carpus.parent = null;
if (claws) claws.parent = null;
if (tiptoe) tiptoe.parent = null;


//add nulls and controllers
var clawsNull, handNull;
if (claws)
{
//claws
clawsNull = Duik.utils.addNullOnLayer(claws);
clawsNull.name = "IK " + claws.name

var handSize = claws.transform.position.value[0] - carpus.transform.position.value[0];
//tiptoe
if (!tiptoe)
{
tiptoe = Duik.utils.addNullOnLayer(claws);
tiptoe.name = "IK tiptoe " + claws.name
tiptoe.transform.position.setValue([clawsNull.transform.position.value[0] + handSize,clawsNull.transform.position.value[1]]);
}

//foot
handNull = Duik.utils.addNullOnLayer(carpus);
handNull.name = "IK  " + carpus.name;

if (handSize < 0) clockwise = true;
}
//Controller
var ctrl = Duik.addController(carpus,true,true,true,true,false);
Duik.addZero(ctrl.layer);

//parent
if (claws) claws.parent = carpus;
if (radius) {
carpus.parent = radius;
if (humerus) radius.parent = humerus;
}
else if (humerus) carpus.parent = humerus;
if (claws) {
handNull.parent = clawsNull;
clawsNull.parent = tiptoe;
tiptoe.parent =  ctrl.layer;
}
if (shoulder) {
if (humerus) humerus.parent = shoulder;
else if (radius) radius.parent = shoulder;
else carpus.parent = shoulder;
}



//IKs
if (claws) {
//claws
Duik.autoIK([claws,tiptoe]);
//leg
Duik.autoIK([carpus,radius,humerus,handNull]);
//foot
Duik.autoIK([carpus,clawsNull]);
}
else {
if (humerus && radius) Duik.autoIK([carpus,radius,humerus,ctrl.layer]);
else if (radius) Duik.autoIK([carpus,radius,ctrl.layer]);
else if (humerus) Duik.autoIK([carpus,humerus,ctrl.layer]);
}
if (shoulder) {

Duik.addZero(shoulder);
Duik.autoIK([shoulder,ctrl.layer]);
var ikShoulderCtrl = ctrl.layer.effect(Duik.effects.One_Layer_IK);
ikShoulderCtrl(1).setValue(50);
ikShoulderCtrl(3).setValue(-shoulder.transform.rotation.value);
}

//Controls
if (claws) {
//add an IK effect on the controller
var ikCtrl = Duik.utils.addEffect(ctrl.layer,Duik.effects.Two_Layer_IK);
//the effect on the null of the foot
var ikEffect = handNull.effect(Duik.effects.Two_Layer_IK);
ikCtrl.name = ikEffect.name;
//link the properties
Duik.utils.linkProperties(ikEffect,ikCtrl);

//tiptoe, heel and footroll
var handCtrl = Duik.utils.addEffect(ctrl.layer,Duik.effects.Foot_Roll);
handCtrl.name = carpus.name + " Foot roll";
tiptoe.transform.rotation.expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(1);";
clawsNull.transform.rotation.expression = "//Duik.footRoll\n" +
"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(3);\n" +
"var tiptoe = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(1);\n" +
"ctrl-tiptoe;";
tiptoe.effect(Duik.effects.One_Layer_IK)(3).expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(2);";
}
if (shoulder) {
var shoulderCtrl = ctrl.layer.effect.addProperty("ADBE Slider Control");
shoulderCtrl.name = shoulder.name + " auto-position %";
shoulderCtrl(1).setValue(10);

//get Ctrl position
var parent = ctrl.layer.parent;
ctrl.layer.parent = null;
var posC = ctrl.layer.transform.position.value;
ctrl.layer.parent = parent;

//get shoulder position
parent = shoulder.parent;
shoulder.parent = null;
var posS = shoulder.transform.position.value;
shoulder.parent = parent;

delete parent;

var pos = posS-posC;

shoulder.transform.position.expression = "//Duik.shoulder\n" +
"var w = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + shoulderCtrl.name + "\")(1);\n" +
"var z = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
"var p = thisComp.layer(\"" + ctrl.layer.name + "\").toWorld(thisComp.layer(\"" + ctrl.layer.name + "\").anchorPoint);\n" +
"((p-z)+" + pos.toSource() + ")* w/100 + value;";
}

//hide and lock
if (claws){
tiptoe.enabled = false;
tiptoe.shy = true;
tiptoe.locked = true;
clawsNull.enabled = false;
clawsNull.shy = true;
clawsNull.locked = true;
handNull.enabled = false;
handNull.shy = true;
handNull.locked = true;
}

//select controller
Duik.utils.deselectLayers();
ctrl.layer.selected = true;
return ctrl;
}

//BACK LEG
Duik.autorig.vertebrate.digitigrade.backLeg = function (femur,tibia,tarsus,claws,tiptoe)
{
//checks
if (claws && !femur) return null;
if (claws && !tibia) return null;
if ( !tarsus) return null;

//unparent
if (tibia && femur) tibia.parent = null;
if (tarsus && (tibia || femur)) tarsus.parent = null;
if (claws) claws.parent = null;
if (tiptoe) tiptoe.parent = null;

//add nulls and controllers
var clawsNull, footNull;
if (claws)
{
//claws
clawsNull = Duik.utils.addNullOnLayer(claws);
clawsNull.name = "IK " + claws.name

var footSize = claws.transform.position.value[0] - tarsus.transform.position.value[0];
//tiptoe
if (!tiptoe)
{
tiptoe = Duik.utils.addNullOnLayer(claws);
tiptoe.name = "IK tiptoe " + claws.name
tiptoe.transform.position.setValue([clawsNull.transform.position.value[0] + footSize,clawsNull.transform.position.value[1]]);
}

//foot
footNull = Duik.utils.addNullOnLayer(tarsus);
footNull.name = "IK  " + tarsus.name;

if (footSize > 0) clockwise = true;
}
//Controller
var ctrl = Duik.addController(tarsus,true,true,true,true,false);
Duik.addZero(ctrl.layer);

//parent
if (claws) claws.parent = tarsus;
if (tibia) {
tarsus.parent = tibia;
if (femur) tibia.parent = femur;
}
else if (femur) tarsus.parent = femur;
if (claws) {
footNull.parent = clawsNull;
clawsNull.parent = tiptoe;
tiptoe.parent = ctrl.layer
}



//IKs
if (claws) {
//claws
Duik.autoIK([claws,tiptoe]);
//leg
Duik.autoIK([tarsus,tibia,femur,footNull]);
//foot
Duik.autoIK([tarsus,clawsNull]);
}
else {
if (femur && tibia) Duik.autoIK([tarsus,tibia,femur,ctrl.layer]);
else if (tibia) Duik.autoIK([tarsus,tibia,ctrl.layer]);
else if (femur) Duik.autoIK([tarsus,femur,ctrl.layer]);
}

//Controls
if (claws) {
//add an IK effect on the controller
var ikCtrl = Duik.utils.addEffect(ctrl.layer,Duik.effects.Two_Layer_IK);
//the effect on the null of the foot
var ikEffect = footNull.effect(Duik.effects.Two_Layer_IK);
ikCtrl.name = ikEffect.name;
//link the properties
Duik.utils.linkProperties(ikEffect,ikCtrl);

//tiptoe, heel and footroll
var footCtrl = Duik.utils.addEffect(ctrl.layer,Duik.effects.Foot_Roll);
footCtrl.name = tarsus.name + " Foot roll";
tiptoe.transform.rotation.expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(1);";
clawsNull.transform.rotation.expression = "//Duik.footRoll\n" +
"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(3);\n" +
"var tiptoe = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(1);\n" +
"ctrl-tiptoe;";
tiptoe.effect(Duik.effects.One_Layer_IK)(3).expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(2);";
}

//hide and lock
if (claws){
tiptoe.enabled = false;
tiptoe.shy = true;
tiptoe.locked = true;
clawsNull.enabled = false;
clawsNull.shy = true;
clawsNull.locked = true;
footNull.enabled = false;
footNull.shy = true;
footNull.locked = true;
}

//select controller
Duik.utils.deselectLayers();
ctrl.layer.selected = true;
return ctrl;
}

Duik.autorig.vertebrate.digitigrade.spine = Duik.autorig.vertebrate.spine;
Duik.autorig.vertebrate.digitigrade.tail = Duik.autorig.vertebrate.tail;

//---------PLANTIGRADE------------

//FRONT LEG
Duik.autorig.vertebrate.plantigrade.frontLeg = function (shoulder,humerus,radius,carpus,claws,tiptoe,palm)
{

//checks
if (claws && !humerus) return null;
if (claws && !radius) return null;
if ( !carpus) return null;


//unparent
if (radius && humerus) radius.parent = null;
if (carpus && (humerus || radius)) carpus.parent = null;
if (claws) claws.parent = null;
if (tiptoe) tiptoe.parent = null;
if (palm) palm.parent = null;

//orientation
var right = false;
if (claws) {
var clawsPos = Duik.utils.getWorldPos(claws);
var carpusPos = Duik.utils.getWorldPos(carpus);
right = clawsPos[0] - carpusPos[0] > 0;
}

//add nulls and controllers
var clawsNull, handNull;
if (claws)
{
//claws
clawsNull = Duik.utils.addNullOnLayer(claws);
clawsNull.name = "IK " + claws.name

var handSize = claws.transform.position.value[0] - carpus.transform.position.value[0];
//tiptoe
if (!tiptoe)
{
tiptoe = Duik.utils.addNullOnLayer(claws);
tiptoe.name = "IK tiptoe " + claws.name
tiptoe.transform.position.setValue([clawsNull.transform.position.value[0] + handSize,clawsNull.transform.position.value[1]]);
}

if (!palm)
{
palm = Duik.utils.addNullOnLayer(claws);
palm.name = "IK heel " + carpus.name
palm.transform.position.setValue([carpus.transform.position.value[0],clawsNull.transform.position.value[1]]);
}

//foot
handNull = Duik.utils.addNullOnLayer(carpus);
handNull.name = "IK  " + carpus.name;

if (handSize < 0) clockwise = true;
}
//Controller
var ctrl = Duik.addController(carpus,true,true,true,true,false);
Duik.addZero(ctrl.layer);

//parent
if (claws) claws.parent = carpus;
if (radius) {
carpus.parent = radius;
if (humerus) radius.parent = humerus;
}
else if (humerus) carpus.parent = humerus;
if (claws) {
handNull.parent = clawsNull;
clawsNull.parent = tiptoe;
tiptoe.parent = palm;
palm.parent = ctrl.layer;
}
if (shoulder) {
if (humerus) humerus.parent = shoulder;
else if (radius) radius.parent = shoulder;
else carpus.parent = shoulder;
}



//IKs
if (claws) {
//claws
Duik.autoIK([claws,tiptoe]);
//leg
Duik.autoIK([carpus,radius,humerus,handNull]);
//foot
Duik.autoIK([carpus,clawsNull]);
}
else {
if (humerus && radius) Duik.autoIK([carpus,radius,humerus,ctrl.layer]);
else if (radius) Duik.autoIK([carpus,radius,ctrl.layer]);
else if (humerus) Duik.autoIK([carpus,humerus,ctrl.layer]);
}
if (shoulder) {

Duik.addZero(shoulder);
Duik.autoIK([shoulder,ctrl.layer]);
var ikShoulderCtrl = ctrl.layer.effect(Duik.effects.One_Layer_IK);
ikShoulderCtrl(1).setValue(50);
ikShoulderCtrl(3).setValue(-shoulder.transform.rotation.value);
}

//Controls
if (claws) {

//add an IK effect on the controller
var ikCtrl = Duik.utils.addEffect(ctrl.layer,Duik.effects.Two_Layer_IK);
//the effect on the null of the foot
var ikEffect = handNull.effect(Duik.effects.Two_Layer_IK);
ikCtrl.name = ikEffect.name;
//link the properties
Duik.utils.linkProperties(ikEffect,ikCtrl);

//tiptoe, heel and footroll
var handCtrl = Duik.utils.addEffect(ctrl.layer,Duik.effects.Foot_Roll);
handCtrl.name = carpus.name + " Foot roll";
tiptoe.transform.rotation.expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(1);";
var op  = right ? "<" : ">";
palm.transform.rotation.expression = "//Duik.footRoll\n" +
"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(2);\n" +
"var roll = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(3);\n" +
"roll " + op + " 0 ? roll+ctrl : ctrl;";
op = right ? ">" : "<";
clawsNull.transform.rotation.expression = "//Duik.footRoll\n" +
"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + handCtrl.name + "\")(3);\n" +
"ctrl " + op + " 0 ? ctrl : 0;";
}
if (shoulder) {
var shoulderCtrl = ctrl.layer.effect.addProperty("ADBE Slider Control");
shoulderCtrl.name = shoulder.name + " auto-position %";
shoulderCtrl(1).setValue(0);

//get Ctrl position
var parent = ctrl.layer.parent;
ctrl.layer.parent = null;
var posC = ctrl.layer.transform.position.value;
ctrl.layer.parent = parent;

//get shoulder position
parent = shoulder.parent;
shoulder.parent = null;
var posS = shoulder.transform.position.value;
shoulder.parent = parent;

delete parent;

var pos = posS-posC;

shoulder.transform.position.expression = "//Duik.shoulder\n" +
"var w = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + shoulderCtrl.name + "\")(1);\n" +
"var z = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
"var p = thisComp.layer(\"" + ctrl.layer.name + "\").toWorld(thisComp.layer(\"" + ctrl.layer.name + "\").anchorPoint);\n" +
"((p-z)+" + pos.toSource() + ")* w/100 + value;";
}

//hide and lock
if (claws){
tiptoe.enabled = false;
tiptoe.shy = true;
tiptoe.locked = true;
palm.enabled = false;
palm.shy = true;
palm.locked = true;
clawsNull.enabled = false;
clawsNull.shy = true;
clawsNull.locked = true;
handNull.enabled = false;
handNull.shy = true;
handNull.locked = true;
}

//select controller
Duik.utils.deselectLayers();
ctrl.layer.selected = true;
return ctrl;
}

//BACK LEG
Duik.autorig.vertebrate.plantigrade.backLeg = function (femur,tibia,tarsus,claws,tiptoe,heel)
{

//checks
if (claws && !femur) return null;
if (claws && !tibia) return null;
if ( !tarsus) return null;

//unparent
if (tibia && femur) tibia.parent = null;
if (tarsus && (tibia || femur)) tarsus.parent = null;
if (claws) claws.parent = null;
if (tiptoe) tiptoe.parent = null;
if (heel) heel.parent = null;

//detect right or left
var right = false;
if (claws)
{
var clawsPos = Duik.utils.getWorldPos(claws);
var tarsusPos = Duik.utils.getWorldPos(tarsus);
right = (clawsPos[0] - tarsusPos[0]) > 0;
}




//add nulls and controllers
var clawsNull, footNull;
if (claws)
{
//claws
clawsNull = Duik.utils.addNullOnLayer(claws);
clawsNull.name = "IK " + claws.name

var footSize = claws.transform.position.value[0] - tarsus.transform.position.value[0];
//tiptoe
if (!tiptoe)
{
tiptoe = Duik.utils.addNullOnLayer(claws);
tiptoe.name = "IK tiptoe " + claws.name
tiptoe.transform.position.setValue([clawsNull.transform.position.value[0] + footSize,clawsNull.transform.position.value[1]]);
}

if (!heel)
{
heel = Duik.utils.addNullOnLayer(claws);
heel.name = "IK heel " + tarsus.name
heel.transform.position.setValue([tarsus.transform.position.value[0],clawsNull.transform.position.value[1]]);
}

//foot
footNull = Duik.utils.addNullOnLayer(tarsus);
footNull.name = "IK  " + tarsus.name;

if (footSize > 0) clockwise = true;
}
//Controller
var ctrl = Duik.addController(tarsus,true,true,true,true,false);
Duik.addZero(ctrl.layer);

//parent
if (claws) claws.parent = tarsus;
if (tibia) {
tarsus.parent = tibia;
if (femur) tibia.parent = femur;
}
else if (femur) tarsus.parent = femur;
if (claws) {
footNull.parent = clawsNull;
clawsNull.parent = tiptoe;
tiptoe.parent = heel;
heel.parent = ctrl.layer;
}



//IKs
if (claws) {
//claws
Duik.autoIK([claws,tiptoe]);
//leg
Duik.autoIK([tarsus,tibia,femur,footNull]);
//foot
Duik.autoIK([tarsus,clawsNull]);
}
else {
if (femur && tibia) Duik.autoIK([tarsus,tibia,femur,ctrl.layer]);
else if (tibia) Duik.autoIK([tarsus,tibia,ctrl.layer]);
else if (femur) Duik.autoIK([tarsus,femur,ctrl.layer]);
}

//Controls
if (claws) {

//add an IK effect on the controller
var ikCtrl = Duik.utils.addEffect(ctrl.layer,Duik.effects.Two_Layer_IK);
//the effect on the null of the foot
var ikEffect = footNull.effect(Duik.effects.Two_Layer_IK);
ikCtrl.name = ikEffect.name;
//link the properties
Duik.utils.linkProperties(ikEffect,ikCtrl);

//tiptoe, heel and footroll
var footCtrl = Duik.utils.addEffect(ctrl.layer,Duik.effects.Foot_Roll);
footCtrl.name = tarsus.name + " Foot roll";
tiptoe.transform.rotation.expression = "//Duik.footRoll\nthisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(1);";
var op  = right ? "<" : ">";
heel.transform.rotation.expression = "//Duik.footRoll\n" +
"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(2);\n" +
"var roll = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(3);\n" +
"roll " + op + " 0 ? roll+ctrl : ctrl;";
op  = right ? ">" : "<";
clawsNull.transform.rotation.expression = "//Duik.footRoll\n" +
"var ctrl = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + footCtrl.name + "\")(3);\n" +
"ctrl " + op + " 0 ? ctrl : 0;";
}

//hide and lock
if (claws){
tiptoe.enabled = false;
tiptoe.shy = true;
tiptoe.locked = true;
heel.enabled = false;
heel.shy = true;
heel.locked = true;
clawsNull.enabled = false;
clawsNull.shy = true;
clawsNull.locked = true;
footNull.enabled = false;
footNull.shy = true;
footNull.locked = true;
}

//select controller
Duik.utils.deselectLayers();
ctrl.layer.selected = true;
return ctrl;
}

Duik.autorig.vertebrate.plantigrade.spine = Duik.autorig.vertebrate.spine;
Duik.autorig.vertebrate.plantigrade.tail = Duik.autorig.vertebrate.tail;

//----------UNGULATE------------

//FRONT LEG
Duik.autorig.vertebrate.ungulate.frontLeg = function (shoulder,humerus,radius,carpus,claws)
{
//checks
if (claws && !humerus) return null;
if (claws && !radius) return null;
if ( !carpus) return null;

//unparent
if (radius && humerus) radius.parent = null;
if (carpus && (humerus || tibia)) carpus.parent = null;
if (claws) claws.parent = null;

//Controller
var ctrl;
if (claws)  ctrl = Duik.addController(claws,true,true,true,true,false);
else ctrl = Duik.addController(carpus,true,true,true,true,false);
Duik.addZero(ctrl.layer);

//parent
if (claws) claws.parent = carpus;
if (radius) {
carpus.parent = radius;
if (humerus) radius.parent = humerus;
}
else if (humerus) radius.parent = humerus;
if (shoulder) {
if (humerus) humerus.parent = shoulder;
else if (radius) radius.parent = shoulder;
else carpus.parent = shoulder;
}


//IKs
if (claws) {
//claws
Duik.autoIK([claws,carpus,radius,ctrl.layer]);
//leg
Duik.autoIK([humerus,ctrl.layer]);
}
else {
if (humerus && radius) Duik.autoIK([carpus,radius,humerus,ctrl.layer]);
else if (radius) Duik.autoIK([carpus,radius,ctrl.layer]);
else if (humerus) Duik.autoIK([carpus,humerus,ctrl.layer]);
}
if (shoulder) {

Duik.addZero(shoulder);
Duik.autoIK([shoulder,ctrl.layer]);
var ikShoulderCtrl = ctrl.layer.effect(Duik.uiStrings.ik + " "  + shoulder.name);
ikShoulderCtrl(1).setValue(50);
ikShoulderCtrl(3).setValue(-shoulder.transform.rotation.value);
}

//Controls
if (shoulder) {
var shoulderCtrl = ctrl.layer.effect.addProperty("ADBE Slider Control");
shoulderCtrl.name = shoulder.name + " auto-position %";
shoulderCtrl(1).setValue(10);

//get Ctrl position
var parent = ctrl.layer.parent;
ctrl.layer.parent = null;
var posC = ctrl.layer.transform.position.value;
ctrl.layer.parent = parent;

//get shoulder position
parent = shoulder.parent;
shoulder.parent = null;
var posS = shoulder.transform.position.value;
shoulder.parent = parent;

delete parent;

var pos = posS-posC;

shoulder.transform.position.expression = "//Duik.shoulder\n" +
"var w = thisComp.layer(\"" + ctrl.layer.name + "\").effect(\"" + shoulderCtrl.name + "\")(1);\n" +
"var z = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
"var p = thisComp.layer(\"" + ctrl.layer.name + "\").toWorld(thisComp.layer(\"" + ctrl.layer.name + "\").anchorPoint);\n" +
"((p-z)+" + pos.toSource() + ")* w/100 + value;";
}

//select controller
Duik.utils.deselectLayers();
ctrl.layer.selected = true;
return ctrl;
}

//BACK LEG
Duik.autorig.vertebrate.ungulate.backLeg = function (femur,tibia,tarsus,claws)
{
//checks
if (claws && !femur) return null;
if (claws && !tibia) return null;
if ( !tarsus) return null;

//unparent
if (tibia && femur) tibia.parent = null;
if (tarsus && (tibia || femur)) tarsus.parent = null;
if (claws) claws.parent = null;

//Controller
var ctrl;
if (claws)  ctrl = Duik.addController(claws,true,true,true,true,false);
else ctrl = Duik.addController(tarsus,true,true,true,true,false);
Duik.addZero(ctrl.layer);

//parent
if (claws) claws.parent = tarsus;
if (tibia) {
tarsus.parent = tibia;
if (femur) tibia.parent = femur;
}
else if (femur) tarsus.parent = femur;

//IKs
if (claws) {
//claws
Duik.autoIK([claws,tarsus,tibia,ctrl.layer]);
//leg
Duik.autoIK([femur,ctrl.layer]);
}
else {
if (femur && tibia) Duik.autoIK([tarsus,tibia,femur,ctrl.layer],clockwise);
else if (tibia) Duik.autoIK([tarsus,tibia,ctrl.layer]);
else if (femur) Duik.autoIK([tarsus,femur,ctrl.layer]);
}

//select controller
Duik.utils.deselectLayers();
ctrl.layer.selected = true;
return ctrl;
}

Duik.autorig.vertebrate.ungulate.spine = Duik.autorig.vertebrate.spine;
Duik.autorig.vertebrate.ungulate.tail = Duik.autorig.vertebrate.tail;

//----------Aliases---------
Duik.autorig.digitigrade = Duik.autorig.vertebrate.digitigrade;
Duik.autorig.plantigrade = Duik.autorig.vertebrate.plantigrade;
Duik.autorig.ungulate = Duik.autorig.vertebrate.ungulate;

}
}

//================================
//========= METHODS ==============
//================================

//TODO, instead of returning true or false, functions should return the effect created

/*	ADD IK - Duik.autoIK(layers,frontFacing)
adds an IK to the layers

parameters:
layers | Array of AVLayers or LayerCollection
clockWise | boolean, used only with two-layer and three-layer IK, default: false
frontFacing | boolean, default: false

returns
IKRig object
*/
if (typeof Duik.autoIK !== 'function')
{
Duik.autoIK = function (layers,frontFacing)
{
if (frontFacing == undefined) frontFacing = false;

var ik = Duik.utils.prepIK(layers);
ik.frontFacing = frontFacing;
ik.create();

return ik;
}
}
/*	BEZIER IK - Duik.bezierIK(layers,numControllers)
adds a Bezier IK to the layers
the Array layers is sorted as:
[end,middle1,...,middleN,root,endCtrl,rootCtrl]

parameters:
layers | Array of AVLayers or LayerCollection
numControllers | integer, 1 or 2, number of controllers to control the curvature, default:1

returns
void
*/
if (typeof Duik.bezierIK !== 'function')
{
Duik.bezierIK = function (layers,numControllers)
{
if (layers == undefined) return;
if (layers.length < 3) return;
if (numControllers == undefined) numControllers = 1;

var endController = layers[layers.length-2];
var rootController = layers[layers.length-1];

var endParent = endController.parent;
var rootParent = rootController.parent;

//get controller positions
endController.parent = null;
rootController.parent = null;
var endPosition = endController.transform.position.value;
var rootPosition = rootController.transform.position.value;
endController.parent = endParent;
rootController.parent = rootParent;

Duik.utils.checkNames(endController.containingComp);

//create curvature controllers
var curveCtrl1 = Duik.addController(endController,false,false,true,true,false);
curveCtrl1.layer.name = endController.name + "_curve";


if (numControllers == 1)
{
curveCtrl1.layer.transform.position.setValue((endPosition+rootPosition)/2);
}
else
{
var curveCtrl2 = Duik.addController(rootController,false,false,true,true,false);
curveCtrl2.layer.name = rootController.name + "_curve";
curveCtrl1.layer.transform.position.setValue((2*endPosition+rootPosition)/3);
curveCtrl2.layer.transform.position.setValue((endPosition+2*rootPosition)/3);
}

//pseudo effect
var effect;
effect = Duik.utils.addEffect(endController,Duik.effects.Bezier_IK);
effect.name = Duik.uiStrings.bezierIK + " "  + endController.name;

//create expressions
var prevLayerName = "";
for (var i = 0 ; i<layers.length-2;i++)
{
var layer = layers[i];
layer.parent = null;
if (i == 0) prevLayerName = endController.name;
//offset cursor
var offsetEffect = layer.Effects.addProperty("ADBE Slider Control");
offsetEffect.name = Duik.uiStrings.bezierIKOffset;
//index
var index = i/(layers.length-2)+1.5/layers.length;

//position
var opos = layer.transform.position.value;
if (numControllers == 1)
{
layer.transform.position.expression = "//Duik.bezierIK\n" +
"var end = thisComp.layer(\"" + endController.name + "\");\n" +
"var root = thisComp.layer(\"" + rootController.name + "\");\n" +
"var curve = thisComp.layer(\"" + curveCtrl1.layer.name + "\");\n" +
"var ind = " + index + ";\n" +
"var offset = effect(\"" + offsetEffect.name + "\")(1)/100;\n" +
"var generalOffset = end.effect(\"" + effect.name + "\")(1)/100;\n" +
"var endPosition = end.toComp(end.anchorPoint);\n" +
"var rootPosition = root.toComp(root.anchorPoint);\n" +
"var curvePosition = curve.toComp(curve.anchorPoint);\n" +
"var t = ind + generalOffset + offset;\n" +
"result = ((1-t)*(1-t))*endPosition+2*t*(1-t)*curvePosition+t*t*rootPosition;\n" +
"result + value - " + layer.transform.position.value.toSource() + ";";
}
else
{
layer.transform.position.expression = "//Duik.bezierIK\n" +
"var end = thisComp.layer(\"" + endController.name + "\");\n" +
"var root = thisComp.layer(\"" + rootController.name + "\");\n" +
"var curve1 = thisComp.layer(\"" + curveCtrl1.layer.name + "\");\n" +
"var curve2 = thisComp.layer(\"" + curveCtrl2.layer.name + "\");\n" +
"var ind = " + index + ";\n" +
"var offset = effect(\"" + offsetEffect.name + "\")(1)/100;\n" +
"var generalOffset = end.effect(\"" + effect.name + "\")(1)/100;\n" +
"var endPosition = end.toComp(end.anchorPoint);\n" +
"var rootPosition = root.toComp(root.anchorPoint);\n" +
"var curvePosition1 = curve1.toComp(curve1.anchorPoint);\n" +
"var curvePosition2 = curve2.toComp(curve2.anchorPoint);\n" +
"var t = ind + generalOffset + offset;\n" +
"var c = 3*(curvePosition1 - endPosition);\n" +
"var b = 3*(curvePosition2 - curvePosition1) - c;\n" +
"var a = rootPosition - endPosition - c - b;\n" +
"result = ((a*t +b )*t + c)*t + endPosition ;\n" +
"result + value - " + layer.transform.position.value.toSource() + ";";
}

var npos = layer.transform.position.value;
layer.transform.position.setValue(-npos+2*opos);

//rotation
var orot = layer.transform.rotation.value;
layer.transform.rotation.expression = "//Duik.bezierIK\n" +
"var CName = \"" + prevLayerName + "\";\n" +
"var autoOrient = thisComp.layer(\"" + endController.name + "\").effect(\"" + effect.name + "\")(2);\n" +
"var C = thisComp.layer(CName).toWorld(thisComp.layer(CName).anchorPoint);\n" +
"var O =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
"var angle = lookAt(C,O);\n" +
"var ik;\n" +
"angle[0] > 0 ? ik = angle[0]+angle[1] : ik = angle[0]-angle[1];\n" +
"if (angle[1]==-90 || angle[1]==90) result-=90;\n" +
"var layer = thisLayer;\n" +
"while (layer.hasParent)\n" +
"{\n" +
"layer = layer.parent;\n" +
"result = result - layer.rotation;\n" +
"}\n" +
"var result = value;\n" +
"if (autoOrient==1) result += ik;\n" +
"result;";
var nrot = layer.transform.rotation.value;
layer.transform.rotation.setValue(-nrot+2*orot);

prevLayerName = layer.name;
}

if (numControllers == 1) return curveCtrl1;
else return [curveCtrl1,curveCtrl2];
}
}
// ADD ONE-LAYER IK - Duik.oneLayerIK(controller,layer)
if (typeof Duik.oneLayerIK !== 'function')
{
Duik.oneLayerIK = function (ctrl,layer1)
{
//if there's not at least one controller and one layer, abort creation
if (ctrl == undefined || layer1 == undefined) return false;

//check names
Duik.utils.checkNames(ctrl.containingComp);

var controllerName = ctrl.name;

//is right ?
var ctrlPos = Duik.utils.getWorldPos(ctrl);
var bonePos = Duik.utils.getWorldPos(layer1);

var right = (ctrlPos[0] - bonePos[0]) < 0;

//pseudo effect
var effect;
effect = Duik.utils.addEffect(ctrl,Duik.effects.One_Layer_IK);
effect.name = Duik.uiStrings.ik + " "  + layer1.name;

if (right) effect(2).setValue(1);
else effect(2).setValue(0);

//rotation d'origine
var orot = layer1.transform.rotation.value;
//remove expression
layer1.transform.rotation.expression = "";
layer1.transform.rotation.setValue(orot);

//=========================================================
//EXPRESSION TO INSERT
var expression = "//Duik.oneLayerIK\r\n" +
"CName = \"" + controllerName + "\";\r\n" +
"C = thisComp.layer(CName).toWorld(thisComp.layer(CName).anchorPoint);\r\n" +
"O =  thisLayer.toWorld(thisLayer.anchorPoint);\r\n" +
"W = thisComp.layer(CName).effect(\"" + effect.name + "\")(1)/100;\r\n" +
"FK = thisComp.layer(CName).effect(\"" + effect.name + "\")(3);\r\n" +
"R = thisComp.layer(CName).effect(\"" + effect.name + "\")(2);\r\n" +
"angle = lookAt(C,O);\r\n" +
"angle = angle*W;\r\n" +
"R == 1 ? angle = -angle : angle;\r\n" +
"var result;\r\n" +
"angle[0] > 0 ? result = angle[0]+angle[1]+FK+value : result = angle[0]-angle[1]+FK+value;\r\n" +
"if (angle[1]==-90 || angle[1]==90) result-=90;\n" +
"var layer = thisLayer;\r\n" +
"while (layer.hasParent)\r\n" +
"{\r\n" +
"layer = layer.parent;\r\n" +
"result = result - layer.rotation;\r\n" +
"}\r\n" +
"result;";
//=========================================================

layer1.transform.rotation.expression = expression;

//nouvelle rotation
var nrot = layer1.transform.rotation.value;

layer1.transform.rotation.setValue(-nrot+2*orot);

//select controller
Duik.utils.deselectLayers();
ctrl.selected = true;

return true;
}
}
// ADD TWO-LAYER IK - Duik.twoLayerIK(controller,root,end,clockwise,frontFacing)
if (typeof Duik.twoLayerIK !== 'function')
{
Duik.twoLayerIK = function (controller,root,end,clockWise,frontFacing)
{
//if there's not at least one controller and two layers, abort creation
if (controller == undefined) throw "A controller is needed for the IK";
if (root == undefined) throw "The first layer of the IK is missing";
if (end == undefined) throw "The second layer of the IK is missing";
if (frontFacing == undefined) frontFacing = false;
threeD = controller.threeDLayer && root.threeDLayer && end.threeDLayer;

//detect if shape layers are used
var shapeLayer = false;
if (root instanceof ShapeLayer || end instanceof ShapeLayer) shapeLayer = true;

//check names
Duik.utils.checkNames(controller.containingComp);

//Names
var endName = end.name;
var rootName = root.name;
var controllerName = controller.name;

//pseudo effect
var effect;
effect = Duik.utils.addEffect(controller,Duik.effects.Two_Layer_IK);
effectName = Duik.uiStrings.ik + " "  + endName;
effect.name = effectName;
if (clockWise) effect(1).setValue(1);
effect(10).setValue(0);


if (threeD) {
direction = controller.Effects.addProperty("ADBE Angle Control");
direction.name = Duik.uiStrings.ikDirection + " " + endName;
}

//limit
limit = root.Effects.addProperty("ADBE Angle Control");
limit.name = Duik.uiStrings.ikLimit;

//ZERO
var endZero = null;

if (shapeLayer)
{
//if shape layer, create zero
endZero = controller.containingComp.layers.addNull();
endZero.threeDLayer = true;
var controllerParent = controller.parent;
controller.parent = null;
endZero.position.setValue(controller.position.value);
endZero.name = "IK_zero " + endName.slice(-24);
controller.parent = controllerParent;

//link zero
endZero.parent = end;

//verrouiller et masquer le zero
endZero.moveToEnd();
endZero.guideLayer = true;
endZero.locked = true;
endZero.enabled = false;
endZero.shy = true;

endZeroName = endZero.name;
}
else
{
//add an effect to store the goal stretch
var endEffect = end.Effects.addProperty("ADBE Point Control");
endEffect.name = Duik.uiStrings.ikEnd;
//set the value of the effect and store it
endEffect(1).expression = "bonePos = thisComp.layer(\"" + controllerName + "\").toWorld(thisComp.layer(\"" + controllerName + "\").anchorPoint);\nfromWorld(bonePos)";
var zeroValue = endEffect(1).value;
endEffect(1).expression = "";
endEffect(1).setValue(zeroValue);
}




//=========================================================
//EXPRESSION A INSERER SUR LE BONE BOUT
var endExpression = "//Duik.twoLayerIK\r\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"layer2 = thisComp.layer('" + endName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n";

if (shapeLayer) endExpression += "zeroName = \"" + endZeroName + "\";\n" +
"zero = thisComp.layer(zeroName);\n";
else endExpression += "endPos = layer2.effect(\'" + endEffect.name + "')(1);\n";

endExpression += "ctrlEffect = controller.effect(\"" + effectName + "\")\n" +
"FK = ctrlEffect(5);\n" +
"IKFK = ctrlEffect(3) == 0;\n" +
"cw = ctrlEffect(1) == 1;\n" +
"function getWorldPos(L){\n" +
"return L.toWorld(L.anchorPoint);\n" +
"}\n" +
"function ik() {\n" +
"A = getWorldPos(layer1);\n" +
"B = getWorldPos(layer2);\n";

if (shapeLayer) endExpression += "C = getWorldPos(zero);\n";
else endExpression += "C = layer2.toWorld(endPos);\n";

endExpression += "E = getWorldPos(controller);\n" +
"a = length(B,C);\n" +
"b = length(E,A);\n" +
"c = length(A,B);\n" +
"x = (b*b + c*c - a*a )/(2*b);\n" +
"alpha = Math.acos(clamp(x/c,-1,1));\n" +
"y = b - x;\n" +
"  gamma = Math.acos(clamp(y/a,-1,1));\n" +
"result = (cw ? 1 : -1)*radiansToDegrees(gamma + alpha);  V1 = B - A;\n" +
"  adj1 = radiansToDegrees(Math.atan2(V1[1],V1[0]));\n" +
"  V2 = C - B;\n" +
"  adj2 = radiansToDegrees(Math.atan2(V2[1],V2[0]));\n" +
"  IK = result +  adj1 - adj2 + value;\n" +
"return IK;\n" +
"}\n" +
"IKFK ? ik() : FK;";
//=========================================================

if (threeD) {end.transform.zRotation.expression = endExpression; end.transform.zRotation.setValue(0);}
else {end.transform.rotation.expression = endExpression; end.transform.rotation.setValue(0);}


//=========================================================
//EXPRESSION A INSERER SUR LE BONE RACINE
var rootExpression = "//Duik.twoLayerIK\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"layer2 = thisComp.layer('" + endName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n";

if (shapeLayer) rootExpression += "zeroName = \"" + endZeroName + "\";\n" +
"zero = thisComp.layer(zeroName);\n";
else rootExpression += "endPos = layer2.effect(\'" + endEffect.name + "')(1);\n";

rootExpression += "ctrlEffect = controller.effect(\"" + effectName + "\")\n" +
"limit = effect('" + limit.name + "')(1);\n" +
"FK = ctrlEffect(4);\n" +
"IKFK = ctrlEffect(3) == 0;\n" +
"cw = ctrlEffect(1) == 1;\n" +
"function getWorldPos(L){\n" +
"return L.toWorld(L.anchorPoint);\n" +
"}\n" +
"function ik() {\n" +
"A = getWorldPos(layer1);\n" +
"B = getWorldPos(layer2);\n";

if (shapeLayer) rootExpression += "C = getWorldPos(zero);\n";
else rootExpression += "C = layer2.toWorld(endPos);\n";

rootExpression += "E = getWorldPos(controller);\n" +
"a = length(B,C);\n" +
"b = length(E,A);\n" +
"c = length(A,B);\n" +
"x = (b*b + c*c - a*a )/(2*b);\n" +
"alpha = Math.acos(clamp(x/c,-1,1));\n" +
"D = E - A;\n" +
"delta = Math.atan2(D[1],D[0]);\n" +
"result = radiansToDegrees(delta - (cw ? 1 : -1)*alpha);\n" +
"V = B - A;\n" +
"adj1 = radiansToDegrees(Math.atan2(V[1],V[0]));\n" +
"IK = result - adj1 + value;\n" +
"if (IK < limit) IK+=360;\n" +
"return IK;\n" +
"}\n" +
"IKFK ? ik() : FK;";
//=======================================================

if (threeD) {root.transform.zRotation.expression = rootExpression; root.transform.zRotation.setValue(0);}
else {root.transform.rotation.expression = rootExpression; root.transform.rotation.setValue(0);}

if (threeD) {
//si 3D : le zero de la jambe pour l'orientation
//creer un zero
var zero = app.project.activeItem.layers.addNull();
zero.threeDLayer = true;
var calqueparent = root.parent;
root.parent = null;
zero.position.setValue(root.position.value);
zero.name = "Zero_" + rootName.slice(-24);
//verrouiller et masquer le zero
zero.moveToEnd();
zero.guideLayer = true;
zero.shy = true;

if (frontFacing) {
var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +
"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" +
"C = controleur.toWorld(controleur.anchorPoint);\n" +
"Cx = C[0];\n" +
"Cy = C[1];\n" +
"Cz = C[2];\n" +
"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
"Lx = L[0];\n" +
"Ly = L[1];\n" +
"Lz = L[2];" +
"angle = lookAt([Cz,Cy,Cx],[Lz,Ly,Lx]);\n" +
"[-angle[1]+90,-angle[0],value[2]]\n"
} else { //front
var zeroExpression = "//Duik.twoLayerIK.threeD\r\n" +
"controleur =thisComp.layer(\"" + controllerName + "\");\n\n" +
"C = controleur.toWorld(controleur.anchorPoint);\n" +
"L =  thisLayer.toWorld(thisLayer.anchorPoint);\n" +
"angle = lookAt(C,L);\n" +
"[angle[0],angle[1],value[2]]\n"
} //else front
zero.transform.orientation.expression = zeroExpression;
zero.transform.xRotation.expression = "//Duik.twoLayerIK.threeD\r\n" + "thisComp.layer(\"" + controllerName + "\").effect(\"IK Direction " +  rootName.slice(-15) + "\")(1)";

root.parent = zero;
//lier le zero au bone du bout
zero.parent = calqueparent;
zero.enabled = false;
zero.locked = true;
} //tridi

//les expressions de stretch
//les positions d'origine
var posbout = end.transform.position.value.toSource();
var poszero;
if (shapeLayer) poszero = endZero.transform.position.value.toSource();
else poszero = zeroValue.toSource();
var apracine = root.transform.anchorPoint.value.toSource();
var apbout = end.transform.anchorPoint.value.toSource();

var expressionstretchbout = "//Duik.twoLayerIK.stretch\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n" +
"ctrlEffect = controller.effect('" + effectName + "');\n" +
"stretch = ctrlEffect(9);\n" +
"auto = ctrlEffect(8) == 1;\n" +
"IK = ctrlEffect(3) == 0;\n" +
"shrinkVal = ctrlEffect(10)/100;\n" +
"function getWorldPos(L){\n" +
"return L.toWorld(L.anchorPoint);\n" +
"}\n" +
"dist1 = length(" + apracine + "," + posbout + ");\n" +
"dist2 = length(" + apbout + "," + poszero + ");\n" +
"IKLength = dist1+dist2;\n" +
"IKStretched = IKLength+stretch;\n" +
"boneStretch = 0;\n" +
"proportion = dist1/(IKLength);\n" +
"posC = getWorldPos(controller);\n" +
"posR = getWorldPos(layer1);\n" +
"distC = length(posC,posR);\n" +
"shrinkMax = IKLength*shrinkVal;\n" +
"shrink = 0;\n" +
"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
"else boneStretch += stretch*proportion;\n" +
"coef = 1;\n" +
"dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n" +
"(" + posbout + "-" + apracine + ")*coef+" + apracine + ";";

end.transform.position.expression = expressionstretchbout;

var expressionstretchgoal = "//Duik.twoLayerIK.stretch\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n" +
"ctrlEffect = controller.effect('" + effectName + "');\n" +
"stretch = ctrlEffect(9);\n" +
"auto = ctrlEffect(8) == 1;\n" +
"IK = ctrlEffect(3) == 0;\n" +
"shrinkVal = ctrlEffect(10)/100;\n" +
"function getWorldPos(L){\n" +
"return L.toWorld(L.anchorPoint);\n" +
"}\n" +
"dist1 = length(" + apracine + "," + posbout + ");\n" +
"dist2 = length(" + apbout + "," + poszero + ");\n" +
"IKLength = dist1+dist2;\n" +
"IKStretched = IKLength+stretch;\n" +
"boneStretch = 0;\n" +
"proportion = dist2/(IKLength);\n" +
"posC = getWorldPos(controller);\n" +
"posR = getWorldPos(layer1);\n" +
"distC = length(posC,posR);\n" +
"shrinkMax = IKLength*shrinkVal;\n" +
"shrink = 0;\n" +
"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
"else boneStretch += stretch*proportion;\n" +
"coef = 1;\n" +
"dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n" +
"(" + poszero + "-" + apbout + ")*coef+" + apbout + ";";

if (shapeLayer) endZero.transform.position.expression = expressionstretchgoal;
else endEffect(1).expression = expressionstretchgoal;

//select controller
Duik.utils.deselectLayers();
controller.selected = true;

//move the controller to avoid bugs (forces expressions evaluation)
controller.transform.position.setValue(controller.transform.position.value);

return endZero;
}
}
// ADD THREE-LAYER IK - Duik.threeLayerIK(controller,root,middle,end,clockWise)
if (typeof Duik.threeLayerIK !== 'function')
{
Duik.threeLayerIK = function (controller,root,middle,end,clockWise)
{
//if there's not at least one controller and three layers, abort creation
if (controller == undefined) throw "A controller is needed for the IK";
if (root == undefined) throw "The first layer of the IK is missing";
if (middle == undefined) throw "The second layer of the IK is missing";
if (end == undefined) throw "The third layer of the IK is missing";

//check names
Duik.utils.checkNames(controller.containingComp);

//check if shape layers
var shapeLayer = false;
if (root instanceof ShapeLayer || middle instanceof ShapeLayer || end instanceof ShapeLayer) shapeLayer = true;

//Names
var endName = end.name;
var middleName = middle.name;
var rootName = root.name;
var controllerName = controller.name;

//pseudo effect
var effect;
effect = Duik.utils.addEffect(controller,Duik.effects.Three_Layer_IK);
effect.name = Duik.uiStrings.ik + " "  + endName;
if (clockWise) effect(1).setValue(1);
effect(11).setValue(0);

//limit
limit = root.Effects.addProperty("ADBE Angle Control");
limit.name = Duik.uiStrings.ikLimit;

//ZERO
var endZero = null;
if (shapeLayer)
{
//creer un zero
endZero = controller.containingComp.layers.addNull();
endZero.threeDLayer = true;
var controllerParent = controller.parent;
controller.parent = null;
endZero.position.setValue(controller.position.value);
endZero.name = "IK_zero " + endName.slice(-24);
controller.parent = controllerParent;

//lier le zero au bone du bout
endZero.parent = end;

//verrouiller et masquer le zero
endZero.moveToEnd();
endZero.guideLayer = true;
endZero.locked = true;
endZero.enabled = false;
endZero.shy = true;

endZeroName = endZero.name;
}
else
{
//add an effect to store the goal stretch
var endEffect = end.Effects.addProperty("ADBE Point Control");
endEffect.name = Duik.uiStrings.ikEnd;
//set the value of the effect and store it
if (end instanceof ShapeLayer)
{
endEffect(1).expression = "thisComp.layer(\"" + controllerName + "\").toWorld(thisComp.layer(\"" + controllerName + "\").anchorPoint)";
}
else
{
endEffect(1).expression = "bonePos = thisComp.layer(\"" + controllerName + "\").toWorld(thisComp.layer(\"" + controllerName + "\").anchorPoint);\nfromWorld(bonePos)";
}
var zeroValue = endEffect(1).value;
endEffect(1).expression = "";
endEffect(1).setValue(zeroValue);
}



//=========================================================
//EXPRESSION A INSERER SUR LE BONE BOUT
endExpression = "//Duik.threeLayerIK\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"layer2 = thisComp.layer('" + middleName + "');\n" +
"layer3 = thisComp.layer('" + endName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n";

if (shapeLayer) endExpression += "zeroName = \"" + endZeroName + "\";\n" +
"zero = thisComp.layer(zeroName);\n";
else endExpression += "endPos = layer3.effect(\'" + endEffect.name + "')(1);\n";

endExpression += "ctrlEffect = controller.effect('" + effect.name + "');\n" +
"FK = ctrlEffect(6);\n" +
"IKFK = ctrlEffect(3) == 0;\n" +
"cw = ctrlEffect(1) == 1;\n" +
"function getWorldPos(layer){\n" +
"return layer.toWorld(layer.anchorPoint);\n" +
"}\n" +
"function sq(result){\n" +
"return result*result;\n" +
"}\n" +
"function getAngle(p1,p2){\n" +
"var dist = p2-p1;\n" +
"var angle = Math.atan2(dist[1],dist[0]);\n" +
"return radiansToDegrees(angle);\n" +
"}\n" +
"function ik() {\n" +
"var uPos = getWorldPos(layer1);\n" +
"var mPos = getWorldPos(layer2);\n" +
"var lPos = getWorldPos(layer3);\n";

if (shapeLayer) endExpression += "var zPos = getWorldPos(zero);\n";
else endExpression += "var zPos = layer3.toWorld(endPos);\n";

endExpression += "var cPos = getWorldPos(controller);\n" +
"var uLength = length(uPos,mPos);\n" +
"var mLength = length(mPos,lPos);\n" +
"var lLength = length(lPos,zPos);\n" +
"var ikLength = length(uPos,cPos);\n" +
"if (ikLength == 0) ikLength = 1;\n" +
"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" +
"var d2 = sq(ikLength) * (uLength+lLength);\n" +
"var d3 = -sq(ikLength) * uLength * lLength;\n" +
"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" +
"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" +
"var d6 = Math.sqrt( sq(ikLength) + sq(uLength) - 2*ikLength*uLength*Math.cos(baseA));\n" +
"var lowerA = Math.acos(clamp((sq(d6) - sq(lLength) - sq(mLength)) / (-2*lLength*mLength),-1,1));\n" +
"lowerA = cw ? -lowerA : lowerA;\n" +
"lowerA = radiansToDegrees(lowerA);\n" +
"var mToL =getAngle(mPos,lPos);\n" +
"var lToZ =getAngle(lPos,zPos);\n" +
"var ikResult = lowerA + mToL - lToZ +180;\n" +
"return ikResult;\n" +
"}\n" +
"var result = value;\n" +
"IKFK ? result += ik() : result += FK;\n" +
"result;\n";

end.transform.rotation.expression = endExpression;
end.transform.rotation.setValue(0);
//=========================================================

//=========================================================
//EXPRESSION A INSERER SUR LE BONE MIDDLE
middleExpression ="//Duik.threeLayerIK\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"layer2 = thisComp.layer('" + middleName + "');\n" +
"layer3 = thisComp.layer('" + endName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n";

if (shapeLayer) middleExpression += "zeroName = \"" + endZeroName + "\";\n" +
"zero = thisComp.layer(zeroName);\n";
else middleExpression += "endPos = layer3.effect(\'" + endEffect.name + "')(1);\n";

middleExpression += "ctrlEffect = controller.effect('" + effect.name + "');\n" +
"FK = ctrlEffect(5);\n" +
"IKFK = ctrlEffect(3) == 0;\n" +
"cw = ctrlEffect(1) == 1;\n" +
"function getWorldPos(layer){\n" +
"return layer.toWorld(layer.anchorPoint);\n" +
"}\n" +
"function sq(result){\n" +
"return result*result;\n" +
"}\n" +
"function getAngle(p1,p2){\n" +
"var dist = p2-p1;\n" +
"var angle = Math.atan2(dist[1],dist[0]);\n" +
"return radiansToDegrees(angle);\n" +
"}\n" +
"function ik() {\n" +
"var uPos = getWorldPos(layer1);\n" +
"var mPos = getWorldPos(layer2);\n" +
"var lPos = getWorldPos(layer3);\n";

if (shapeLayer) middleExpression += "var zPos = getWorldPos(zero);\n";
else middleExpression += "var zPos = layer3.toWorld(endPos);\n";

middleExpression += "var cPos = getWorldPos(controller);\n" +
"var uLength = length(uPos,mPos);\n" +
"var mLength = length(mPos,lPos);\n" +
"var lLength = length(lPos,zPos);\n" +
"var ikLength = length(uPos,cPos);\n" +
"if (ikLength == 0) ikLength = 1;\n" +
"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" +
"var d2 = sq(ikLength) * (uLength+lLength);\n" +
"var d3 = -sq(ikLength) * uLength * lLength;\n" +
"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" +
"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" +
"var d5 = Math.sqrt( sq(ikLength) + sq(lLength) - 2*ikLength*lLength*Math.cos(baseA));\n" +
"var middleA = Math.acos(clamp((sq(d5)-sq(uLength)-sq(mLength)) / (-2*uLength*mLength),-1,1));\n" +
"middleA = cw ? -middleA : middleA ;\n" +
"middleA = radiansToDegrees(middleA);\n" +
"var uToM =getAngle(uPos,mPos);\n" +
"var mToL =getAngle(mPos,lPos);\n" +
"var ikResult = middleA + uToM - mToL +180;\n" +
"return ikResult;\n" +
"}\n" +
"var result = value;\n" +
"IKFK ? result += ik() : result += FK;\n" +
"result;\n";

middle.transform.rotation.expression = middleExpression;
middle.transform.rotation.setValue(0);
//=========================================================

//=========================================================
//EXPRESSION A INSERER SUR LE BONE ROOT
rootExpression = "//Duik.threeLayerIK\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"layer2 = thisComp.layer('" + middleName + "');\n" +
"layer3 = thisComp.layer('" + endName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n";

if (shapeLayer) rootExpression += "zeroName = \"" + endZeroName + "\";\n" +
"zero = thisComp.layer(zeroName);\n";
else rootExpression += "endPos = layer3.effect(\'" + endEffect.name + "')(1);\n";

rootExpression += "limit = effect('" + limit.name + "')(1);\n" +
"ctrlEffect = controller.effect('" + effect.name + "');\n" +
"FK = ctrlEffect(4);\n" +
"IKFK = ctrlEffect(3) == 0;\n" +
"cw = ctrlEffect(1) == 1;\n" +
"function getWorldPos(layer){\n" +
"return layer.toWorld(layer.anchorPoint);\n" +
"}\n" +
"function sq(result){\n" +
"return result*result;\n" +
"}\n" +
"function getAngle(p1,p2){\n" +
"var dist = p2-p1;\n" +
"var angle = Math.atan2(dist[1],dist[0]);\n" +
"return radiansToDegrees(angle);\n" +
"}\n" +
"function ik() {\n" +
"var uPos = getWorldPos(layer1);\n" +
"var mPos = getWorldPos(layer2);\n" +
"var lPos = getWorldPos(layer3);\n";

if (shapeLayer) rootExpression += "var zPos = getWorldPos(zero);\n";
else rootExpression += "var zPos = layer3.toWorld(endPos);\n";

rootExpression += "var cPos = getWorldPos(controller);\n" +
"var uLength = length(uPos,mPos);\n" +
"var mLength = length(mPos,lPos);\n" +
"var lLength = length(lPos,zPos);\n" +
"var ikLength = length(uPos,cPos);\n" +
"if (ikLength == 0) ikLength = 1;\n" +
"var d1 = sq(mLength) - sq(ikLength) - sq(uLength-lLength);\n" +
"var d2 = sq(ikLength) * (uLength+lLength);\n" +
"var d3 = -sq(ikLength) * uLength * lLength;\n" +
"var d4 = (-d2 - Math.sqrt( sq(d2) - 4*d1*d3 )) / (2*d1);\n" +
"var baseA = Math.acos(clamp(ikLength/(2*d4),-1,1));\n" +
"var upperA = cw ? -baseA : baseA ;\n" +
"upperA = radiansToDegrees(upperA);\n" +
"var uToC =getAngle(uPos,cPos);\n" +
"var uToM =getAngle(uPos,mPos);\n" +
"var ikResult = upperA + uToC - uToM;\n" +
"if (ikResult < limit) ikResult +=360;\n" +
"return ikResult;\n" +
"}\n" +
"var result = value;\n" +
"IKFK ? result += ik() : result += FK;\n" +
"result;\n";

root.transform.rotation.expression = rootExpression;
root.transform.rotation.setValue(0);
//=========================================================

//move the controller to avoid bugs (forces expressions evaluation)
controller.transform.position.setValue(controller.transform.position.value);

//les expressions de stretch
//les positions d'origine
var posmiddle = middle.transform.position.value.toSource();
var posend = end.transform.position.value.toSource();
var poszero;
if (shapeLayer) poszero = endZero.transform.position.value.toSource();
else poszero = zeroValue.toSource();
var aproot = root.transform.anchorPoint.value.toSource();
var apmiddle = middle.transform.anchorPoint.value.toSource();
var apend = end.transform.anchorPoint.value.toSource();

//=========================================================
//EXPRESSION A INSERER SUR LE BONE MIDDLE
middle.transform.position.expression = "//Duik.threeLayerIK.stretch\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n" +
"ctrlEffect = controller.effect('" + effect.name + "');\n" +
"stretch = ctrlEffect(10);\n" +
"auto = ctrlEffect(9) == 1;\n" +
"IK = ctrlEffect(3) == 0;\n" +
"shrinkVal = ctrlEffect(11)/100;\n" +
"function getWorldPos(L){\n" +
"return L.toWorld(L.anchorPoint);\n" +
"}\n" +
"var upperAP = " + aproot + ";\n" +
"var middlePos = " + posmiddle + ";\n" +
"var middleAP = " + apmiddle + ";\n" +
"var lowerPos = " + posend + ";\n" +
"var lowerAP = " + apend + ";\n" +
"var zeroPos = " + poszero + ";\n" +
"dist1 = length(upperAP,middlePos);\n" +
"dist2 = length(middleAP,lowerPos);\n" +
"dist3 = length(lowerAP,zeroPos);\n" +
"IKLength = dist1+dist2+dist3;\n" +
"IKStretched = IKLength+stretch;\n" +
"boneStretch = 0;\n" +
"proportion = dist1/(IKLength);\n" +
"posC = getWorldPos(controller);\n" +
"posR = getWorldPos(layer1);\n" +
"distC = length(posC,posR);\n" +
"shrinkMax = IKLength*shrinkVal;\n" +
"shrink = 0;\n" +
"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
"else boneStretch += stretch*proportion;\n" +
"coef = 1;\n" +
"dist1 != 0 ? coef = (dist1+boneStretch)/dist1 : coef = 1;\n" +
"(middlePos-upperAP)*coef+upperAP;\n";
//=========================================================

//=========================================================
//EXPRESSION A INSERER SUR LE BONE BOUT
end.transform.position.expression = "//Duik.threeLayerIK.stretch\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n" +
"ctrlEffect = controller.effect('" + effect.name + "');\n" +
"stretch = ctrlEffect(10);\n" +
"auto = ctrlEffect(9) == 1;\n" +
"IK = ctrlEffect(3) == 0;\n" +
"shrinkVal = ctrlEffect(11)/100;\n" +
"function getWorldPos(L){\n" +
"return L.toWorld(L.anchorPoint);\n" +
"}\n" +
"var upperAP = " + aproot + ";\n" +
"var middlePos = " + posmiddle + ";\n" +
"var middleAP = " + apmiddle + ";\n" +
"var lowerPos = " + posend + ";\n" +
"var lowerAP = " + apend + ";\n" +
"var zeroPos = " + poszero + ";\n" +
"dist1 = length(upperAP,middlePos);\n" +
"dist2 = length(middleAP,lowerPos);\n" +
"dist3 = length(lowerAP,zeroPos);\n" +
"IKLength = dist1+dist2+dist3;\n" +
"IKStretched = IKLength+stretch;\n" +
"boneStretch = 0;\n" +
"proportion = dist2/(IKLength);\n" +
"posC = getWorldPos(controller);\n" +
"posR = getWorldPos(layer1);\n" +
"distC = length(posC,posR);\n" +
"shrinkMax = IKLength*shrinkVal;\n" +
"shrink = 0;\n" +
"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
"else boneStretch += stretch*proportion;\n" +
"coef = 1;\n" +
"dist2 != 0 ? coef = (dist2+boneStretch)/dist2 : coef = 1;\n" +
"(middlePos-upperAP)*coef+upperAP;\n";
//=========================================================

//=========================================================
//EXPRESSION A INSERER SUR LE ZERO
expressionstretchgoal = "//Duik.threeLayerIK.stretch\n" +
"layer1 = thisComp.layer('" + rootName + "');\n" +
"controller = thisComp.layer('" + controllerName + "');\n" +
"ctrlEffect = controller.effect('" + effect.name + "');\n" +
"stretch = ctrlEffect(10);\n" +
"auto = ctrlEffect(9) == 1;\n" +
"IK = ctrlEffect(3) == 0;\n" +
"shrinkVal = ctrlEffect(11)/100;\n" +
"function getWorldPos(L){\n" +
"return L.toWorld(L.anchorPoint);\n" +
"}\n" +
"var upperAP = " + aproot + ";\n" +
"var middlePos = " + posmiddle + ";\n" +
"var middleAP = " + apmiddle + ";\n" +
"var lowerPos = " + posend + ";\n" +
"var lowerAP = " + apend + ";\n" +
"var zeroPos = " + poszero + ";\n" +
"dist1 = length(upperAP,middlePos);\n" +
"dist2 = length(middleAP,lowerPos);\n" +
"dist3 = length(lowerAP,zeroPos);\n" +
"IKLength = dist1+dist2+dist3;\n" +
"IKStretched = IKLength+stretch;\n" +
"boneStretch = 0;\n" +
"proportion = dist3/(IKLength);\n" +
"posC = getWorldPos(controller);\n" +
"posR = getWorldPos(layer1);\n" +
"distC = length(posC,posR);\n" +
"shrinkMax = IKLength*shrinkVal;\n" +
"shrink = 0;\n" +
"if (distC < IKStretched && IK) shrink = 1-distC/IKStretched;\n" +
"boneStretch -= easeOut(shrink,0,shrinkMax)*proportion;\n" +
"if (distC > IKStretched && auto && IK) boneStretch += (distC-IKLength)*proportion;\n" +
"else boneStretch += stretch*proportion;\n" +
"coef = 1;\n" +
"dist3 != 0 ? coef = (dist3+boneStretch)/dist3 : coef = 1;\n" +
"(middlePos-upperAP)*coef+upperAP;\n";

if (shapeLayer) endZero.transform.position.expression = expressionstretchgoal;
else endEffect(1).expression = expressionstretchgoal;
//=========================================================

//select controller
Duik.utils.deselectLayers();
controller.selected = true;

//move the controller to avoid bugs (forces expressions evaluation)
controller.transform.position.setValue(controller.transform.position.value);

return endZero;
}
}
/* ADD GOAL - Duik.goal(layer,controller)
adds a goal to the layer which may be controlled by a controller

parameters:
layer	| AVLayer
controller | AVLayer or undefined

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.goal !== 'function')
{
Duik.goal = function (layer,controller)
{
//pour ne pas bouger, il faut recuperer la rotation d'origine
var ancienneRot = 0;
if (layer.threeDLayer) ancienneRot = layer.transform.zRotation.value;
else ancienneRot = layer.transform.rotation.value;

//check names
Duik.utils.checkNames(layer.containingComp);

//si on a un controleur
if (controller != undefined)
{
//ajouter la case sur le controleur
var effetGoal = controller.Effects.addProperty("ADBE Checkbox Control");
effetGoal.name = "Goal" + " " + layer.name;
effetGoal(1).setValue(true);
//ajouter l'expression dans le calque
expr = "//Duik.goal\r\n" +
"var C = thisComp.layer('" + controller.name + "');\r\n" +
"var goal = C.effect('" + effetGoal.name + "')(1);\r\n" +
"var result = value + C.rotation;\r\n" +
"if (goal == 1)\r\n" +
"{\r\n" +
"var layer = thisLayer;\r\n" +
"while (layer.hasParent)\r\n" +
"{\r\n" +
"layer = layer.parent;\r\n" +
"result = result - layer.rotation;\r\n" +
"}\r\n" +
"}\r\n" +
"result;";

if (layer.threeDLayer) layer.transform.zRotation.expression = expr;
else layer.transform.rotation.expression = expr;
}
else
{
//ajouter la case sur le calque
var effetGoal = layer.Effects.addProperty("ADBE Checkbox Control");
effetGoal.name = "Goal";
effetGoal(1).setValue(true);
//ajouter l'expression dans le calque
layer.transform.rotation.expression = "//Duik.goal\r\n" +
"var goal = thisLayer.effect('" + effetGoal.name + "')(1);\r\n" +
"var result = value;\r\n" +
"if (goal == 1)\r\n" +
"{\r\n" +
"var layer = thisLayer;\r\n" +
"while (layer.hasParent)\r\n" +
"{\r\n" +
"layer = layer.parent;\r\n" +
"result = result - layer.rotation;\r\n" +
"}\r\n" +
"}\r\n" +
"result;";
}

//et remettre la bonne rotation pour pas bouger
var nouvelleRot = 0;
if (layer.threeDLayer) nouvelleRot = layer.transform.zRotation.value;
else nouvelleRot = layer.transform.rotation.value;

if (layer.threeDLayer) layer.transform.zRotation.setValue(2*ancienneRot-nouvelleRot);
else layer.transform.rotation.setValue(2*ancienneRot-nouvelleRot);

//select controller
if (controller != undefined)
{
Duik.utils.deselectLayers();
controller.selected = true;
}

return true;
}
}
/* ADD CONTROLLER - Duik.addController(layer,autoLock,rotation,xPosition,yPosition,scale,placement)

parameters
layer | AVLayer, default: null
autoLock | boolean
rotation | boolean
position | boolean
scale | boolean

returns
Controller Object
*/
if (typeof Duik.addController !== 'function')
{
Duik.addController = function (layer,autoLock,rotation,xPosition,yPosition,scale)
{
if (layer == undefined) layer = null;
if (rotation == undefined) rotation = true;
if (xPosition == undefined) xPosition = true;
if (yPosition == undefined) yPosition = true;
if (scale == undefined) scale = false;
if (autoLock == undefined) autoLock = false;
var type = Duik.settings.controllerType;
var color = Duik.settings.controllerColor;
var placement = Duik.settings.ctrlPlacement;

if (layer != null)
{
var layerParent = layer.parent;
layer.parent = null;
var layerPosition = layer.transform.position.value;
layer.parent = layerParent;
}

var controllerObj = new Controller();
controllerObj.rotation = rotation;
controllerObj.xPosition = xPosition;
controllerObj.yPosition = yPosition;
controllerObj.scale = scale;
controllerObj.arc = false;
controllerObj.eye = false;
controllerObj.color = color;
controllerObj.size = 0;

//le controleur
var controller;
if (type == Duik.layerTypes.NULL)
{
if (layer != null) controller = layer.containingComp.layers.addNull();
else controller = app.project.activeItem.layers.addNull();
//controller size
var controllerSize = Duik.settings.controllerSize;
if (Duik.settings.controllerSizeAuto)
{
controllerSize = controller.containingComp.width/2 + controller.containingComp.height/2;
if (Duik.settings.controllerSizeHint == Duik.sizes.SMALL) controllerSize = Math.floor(controllerSize/40);
else if (Duik.settings.controllerSizeHint == Duik.sizes.MEDIUM) controllerSize = Math.floor(controllerSize/20);
else if (Duik.settings.controllerSizeHint == Duik.sizes.BIG) controllerSize = Math.floor(controllerSize/10);
}
controller.source.width = controllerSize;
controller.source.height = controllerSize;
controller.anchorPoint.setValue([controller.source.width/2,controller.source.height/2]);
controllerObj.layer = controller;
controllerObj.type = Duik.layerTypes.NULL;
controllerObj.size = controllerSize;
}
else
{
if (Duik.settings.controllerSizeAuto) controllerObj.size = 0;
else controllerObj.size = Duik.settings.controllerSize/30*100;
if (layer != null) controller = layer.containingComp.layers.addShape();
else controller = app.project.activeItem.layers.addShape();
controller.guideLayer = true;
controllerObj.layer = controller;
controllerObj.type = Duik.layerTypes.VECTOR;
controllerObj.update();
}
if (layer != null)
{
controller.transform.position.setValue(layerPosition);
var cname = "C_";
if (layer.name.length > 29)
{
cname = cname + layer.name.slice(0,10) + " ... " + layer.name.slice(-13);
}
else
{
cname = cname + layer.name;
}
controller.name = cname;
}
else
{
controller.name = "C_";
}

//add to group
Duik.utils.addLayerToDuGroup(controller,Duik.uiStrings.controllers);

if (autoLock) controllerObj.lock();

if (layer != null)
{
if (placement == Duik.placement.OVER_LAYER) controller.moveBefore(layer);
else if (placement == Duik.placement.UNDER_LAYER) controller.moveAfter(layer);
}
if (placement == Duik.placement.BOTTOM) controller.moveToEnd();

//select controller
Duik.utils.deselectLayers();
controller.selected = true;

return controllerObj;
}
}
/* ADD CONTROLLERS - Duik.addControllers(layers,color,autoLock,rotation,xPosition,yPosition,scale,placement)

parameters
layers | Array of AVLayer or LayerCollection
color | Array of 4 floats R,V,B,A
autoLock | boolean
rotation | boolean
position | boolean
scale | boolean
placement | Duik.placement.OVER_LAYER or Duik.placement.UNDER_LAYER or Duik.placement.TOP or Duik.placement.BOTTOM, default: Duik.settings.ctrlPlacement

returns
Array of Controller Objects
*/
if (typeof Duik.addControllers !== 'function')
{
Duik.addControllers = function (layers,autoLock,rotation,xPosition,yPosition,scale)
{
var controllers = [];

if (layers.length > 0)
{
for (var i = 0 ; i < layers.length ; i++)
{
controllers.push ( Duik.addController( Duik.utils.getItem(layers,i),autoLock,rotation,xPosition,yPosition,scale) );
}
}
else
{
controllers.push(Duik.addController(null,autoLock,rotation,xPosition,yPosition,scale));
}

//select controllers
Duik.utils.deselectLayers();
for (var controllerI = 0; controllerI < controllers.length;controllerI++)
{
controllers[controllerI].layer.selected = true;
}

return controllers;
}
}
/* ADD WIGGLE - Duik.wiggle(layer,property,separateDimensions)

Adds a wiggle effect on the property of the layer

parameters
layer | AVLayer
property | Property
separateDimensions | boolean, default: false

returns
true if successful, false if anything went wrong
*/
if (typeof Duik.wiggle !== 'function')
{
Duik.wiggle = function (layer,prop,separateDimensions)
{
if (!prop.canSetExpression) return false;

if (separateDimensions == undefined) separateDimensions = false;

//dimensions
var dimensions = Duik.utils.getPropertyDimensions(prop);
if (!separateDimensions) dimensions = 1;

var ok = false;

if (dimensions == 3) ok = Duik.threeDWiggle(layer,prop);
else if (dimensions == 2) ok = Duik.twoDWiggle(layer,prop);
else ok = Duik.oneDWiggle(layer,prop);

return ok;
}
}
// ADD 3D WIGGLE - Duik.threeDWiggle(layer,property,x,y,z)
if (typeof Duik.threeDWiggle !== 'function')
{
Duik.threeDWiggle = function (layer,prop)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.ThreeD_Wiggle);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.wiggle);
effect(11).setValue(layer.containingComp.duration);

prop.expression = "//Duik.3DWiggle\r\n" +
"Xfreq = effect(\"" + effect.name + "\")(7);\n" +
"Yfreq = effect(\"" + effect.name + "\")(8);\n" +
"Zfreq = effect(\"" + effect.name + "\")(9);\n" +
"Xamp = effect(\"" + effect.name + "\")(2);\n" +
"Yamp = effect(\"" + effect.name + "\")(3);\n" +
"Zamp = effect(\"" + effect.name + "\")(7);\n" +
"loop = effect(\"" + effect.name + "\")(11);\n" +
"if (loop == 0) loop = thisComp.duration;\n" +
"t = (time % loop)-loop;\n" +
"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
"Z1 = wiggle(Zfreq,Zamp, 1, 0.5, t);\n" +
"w1 = [X1[0],Y1[1],Z1[2]];\n" +
"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
"Z2 = wiggle(Zfreq,Zamp, 1, 0.5, t - loop);\n" +
"w2 = [X2[0],Y2[1],Z2[2]];\n" +
"w = ease(t, -loop,  0, w1, w2);\n" +
"w + value - valueAtTime(0)";

return true;
}
}
// ADD 2D WIGGLE - Duik.twoDWiggle(layer,property)
if (typeof Duik.twoDWiggle !== 'function')
{
Duik.twoDWiggle = function (layer,prop)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.TwoD_Wiggle);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.wiggle);
effect(9).setValue(layer.containingComp.duration);

prop.expression = "//Duik.2DWiggle\n" +
"Xfreq = effect(\"" + effect.name + "\")(6);\n" +
"Yfreq = effect(\"" + effect.name + "\")(7);\n" +
"Xamp = effect(\"" + effect.name + "\")(2);\n" +
"Yamp = effect(\"" + effect.name + "\")(3);\n" +
"loop = effect(\"" + effect.name + "\")(9);\n" +
"if (loop == 0) loop = thisComp.duration;\n" +
"t = (time % loop)-loop;\n" +
"X1 = wiggle(Xfreq,Xamp, 1, 0.5, t);\n" +
"Y1 = wiggle(Yfreq,Yamp, 1, 0.5, t);\n" +
"w1 = [X1[0],Y1[1]];\n" +
"X2 = wiggle(Xfreq,Xamp, 1, 0.5, t - loop);\n" +
"Y2 = wiggle(Yfreq,Yamp, 1, 0.5, t - loop);\n" +
"w2 = [X2[0],Y2[1]];\n" +
"w = ease(t, -loop,  0, w1, w2);\n" +
"w + value - valueAtTime(0)";
return true;
}
}
// ADD 1D WIGGLE - Duik.1DWiggle(layer,property)
if (typeof Duik.oneDWiggle !== 'function')
{
Duik.oneDWiggle = function (layer,prop)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.OneD_Wiggle);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.wiggle);
effect(3).setValue(layer.containingComp.duration);

prop.expression = "//Duik.1DWiggle\n" +
"freq = effect(\"" + effect.name + "\")(2);\n" +
"amp = effect(\"" + effect.name + "\")(1);\n" +
"loop = effect(\"" + effect.name + "\")(3);\n" +
"if (loop == 0) loop = thisComp.duration;\n" +
"t = (time % loop)-loop;\n" +
"w1 = wiggle(freq,amp, 1, 0.5, t);\n" +
"w2 = wiggle(freq,amp, 1, 0.5, t - loop);\n" +
"w = ease(t, -loop,  0, w1, w2);\n" +
"w + value - valueAtTime(0)";
return true;

}
}
/* ADAPTATIVE EXPOSURE - Duik.adaptativeExposure(layers,precision,minExp,maxExp,sync,layerSync);

Adds exposure controls to the animation of the property.
The exposure adapts automatically to the speed, according to the given precision,
of the properties between a minimum and a maximum exposure (in frames).

parameters
layers | Array of AVLayer or LayerCollection
precision | integer, default: 100
minExp | integer, default: 1
maxExp | integer, default: 4

returns
void

*/
if (typeof Duik.adaptativeExposure !== 'function')
{
Duik.adaptativeExposure = function (layrs,limit,minExp,maxExp,sync,layerSync)
{
//functions
function getSpeed(p,t)
{
if (p.propertyType != PropertyType.PROPERTY) return 0;
if (p.numKeys == 0) return 0;

//get the nearest key
var nearKey = p.nearestKeyIndex(t);
var nearKeyTime = p.keyTime(nearKey);

//if we're still before the first key
if (t <= nearKeyTime && nearKey == 1) return 0;

//get the previous key
var prevKey = 0;
if (t < nearKeyTime) prevKey = nearKey -1;
else prevKey = nearKey;

//if the last key is in the past
if (prevKey == p.numKeys) return 0;

//get speed & num frames from prevKey
var difference = Duik.utils.getLength(p.valueAtTime(t,false),p.keyValue(prevKey));
return difference;
}

//exposure
if (layrs == undefined) return false;
if (layrs.length == 0) return false;

if (minExp == undefined) minExp = 1;
if (maxExp == undefined) maxExp = 4;
if (sync == undefined) sync = true;
if (layerSync == undefined) layerSync = false;

var layers = Duik.utils.convertCollectionToArray(layrs);

if (minExp <= 0) minExp = 1;
if (maxExp <= 0) maxExp = 1;

if (limit == undefined) limit = 100;
if (limit == 0) limit = 1;

limit = 1/limit*10000;

//for each frame of the comp
var comp = layers[0].containingComp;
var frames = comp.duration / comp.frameDuration ;
var exposure = 0;
if (sync && !layerSync)
{
for (var frame = 0 ; frame < frames ; frame += minExp)
{
exposure++;
var speed = 0;
var time = frame*comp.frameDuration;
//BOUCLE SUR LES CALQUES POUR VERIFIER SI LIMITE DEPASSEE
for (var i = 0 ; i < layers.length ; i++)
{
var layer = layers[i];
if (layer.selectedProperties.length == 0) continue;
for (var j = 0 ; j < layer.selectedProperties.length ; j++)
{
var prop = layer.selectedProperties[j];
var speedTest = getSpeed(prop,time);
if (speedTest > speed) speed = speedTest;
}
}

//BOUCLE SUR LES CALQUES POUR METTRE UNE CLEF SI LIMITE DEPASSEE
if ((speed >= limit || exposure >= maxExp) && speed > 0)
{
exposure = 0;
for (var i = 0 ; i < layers.length ; i++)
{
var layer = layers[i];
if (layer.selectedProperties.length == 0) continue;
for (var j = 0 ; j < layer.selectedProperties.length ; j++)
{
var prop = layer.selectedProperties[j];
if (prop.propertyType != PropertyType.PROPERTY) continue;
if (prop.numKeys == 0) continue;
prop.addKey(time);
}
}
}
if (speed == 0) exposure = 0;
}
}
else if (sync)
{
//POUR CHAQUE CALQUE
for (var i = 0 ; i < layers.length ; i++)
{
var layer = layers[i];
if (layer.selectedProperties.length == 0) continue;
//pour chaque frame
for (var frame = 0 ; frame < frames ; frame += minExp)
{
exposure++;
var speed = 0;
var time = frame*comp.frameDuration;
//POUR CHAQUE PROP
for (var j = 0 ; j < layer.selectedProperties.length ; j++)
{
var prop = layer.selectedProperties[j];
var speedTest = getSpeed(prop,time);
if (speedTest > speed) speed = speedTest;
}
if ((speed >= limit || exposure >= maxExp) && speed > 0)
{
exposure = 0;
for (var j = 0 ; j < layer.selectedProperties.length ; j++)
{
var prop = layer.selectedProperties[j];
if (prop.propertyType != PropertyType.PROPERTY) continue;
if (prop.numKeys == 0) continue;
prop.addKey(time);
}
}
if (speed == 0) exposure = 0;
}
}
}
else
{
//POUR CHAQUE CALQUE
for (var i = 0 ; i < layers.length ; i++)
{
var layer = layers[i];
if (layer.selectedProperties.length == 0) continue;
//POUR CHAQUE PROP
for (var j = 0 ; j < layer.selectedProperties.length ; j++)
{
for (var frame = 0 ; frame < frames ; frame += minExp)
{
exposure++;
var speed = 0;
var time = frame*comp.frameDuration;
var prop = layer.selectedProperties[j];
var speed = getSpeed(prop,time);
if ((speed >= limit || exposure >= maxExp) && speed > 0)
{
exposure = 0;
prop.addKey(time);
}
if (speed == 0) exposure = 0;
}
}
}
}
//all key interpolations to HOLD
Duik.utils.stepSelectedProperties(layers);
return true;
}
}
/* SET EXPOSURE - Duik.setExposure(layers,exposure)

Sets the animation exposure on the selected props on the layers.
If the exposure is not provided, the function will use Duik.detectedExposure, the exposure detected using Duik.utils.getFootageExposure

parameters
layers | Array of AVLayer or LayerCollection
exposure | Array of float, the times where a keyframe must be added, default: Duik.detectedExposure

returns
void

*/
if (typeof Duik.setExposure !== 'function')
{
Duik.setExposure = function (layrs,exposure)
{
if (layrs == undefined) return;
if (exposure == undefined) exposure = Duik.detectedExposure;
if (!exposure.length) return;

var layers = Duik.utils.convertCollectionToArray(layrs);

//for each time in exposure
for (var e=0;e<exposure.length;e++)
{
var time = exposure[e];
//POUR CHAQUE CALQUE
for (var i = 0 ; i < layers.length ; i++)
{
var layer = layers[i];
if (layer.selectedProperties.length == 0) continue;
//POUR CHAQUE PROP
for (var j = 0 ; j < layer.selectedProperties.length ; j++)
{
layer.selectedProperties[j].addKey(time);
}
}
}

//STEP
Duik.utils.stepSelectedProperties(layers);
}
}
/* FIXED EXPOSURE - Duik.fixedExposure(layer,prop);

Adds exposure controls to the animation of the property.

parameters
layer | AVLayer
prop | Property

returns
Array of AVLayers, the bones created

*/
if (typeof Duik.fixedExposure !== 'function')
{
Duik.fixedExposure = function (layer,prop)
{
if (layer == undefined) return false;
if (prop == undefined) return false;

//creer l'effet
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.Exposure);
var effect = prep[0];
var prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.exposure);
effect(1).setValue(1);

prop.expression = "expo = effect(\"" + effect.name + "\")(1);\n" +
"expo == 0 ? expo = 1 : Math.abs(expo);\n" +
"timef = timeToFrames(time);\n" +
"valueAtTime(framesToTime( timef - timef%expo ))";
}
}
/* ADD BONES - Duik.addBones(layers,placement);

Adds bones to the layers, only on selected pins if any, or else on all puppet pins found on those layers.

parameters
layers | Array of AVLayer
placement | Duik.placement.OVER_LAYER or Duik.placement.UNDER_LAYER or Duik.placement.TOP or Duik.placement.BOTTOM, default: Duik.settings.bonePlacement

returns
Array of AVLayers, the bones created

*/
if (typeof Duik.addBones !== 'function')
{
Duik.addBones = function (layers,placement)
{
if (placement == undefined) placement = Duik.settings.bonePlacement;
var createdBones = [];
if (layers.length == 0) { return createdBones; }

//check names
Duik.utils.checkNames(layers[0].containingComp);

for (var i=0;i<layers.length;i++)
{
var calque = Duik.utils.getItem(layers,i);
// les proprietes selectionnees
var props = calque.selectedProperties;
var coins = [];
//lister les puppet pins
if (props.length > 0)
{
for (var j=0;j<props.length;j++)
{
if (props[j].matchName == "ADBE FreePin3 PosPin Atom") coins.push(props[j]);
}
}
//if no pins were found, use every selected spatial properties
if (!coins.length && props.length > 0)
{
for (var j=0;j<props.length;j++)
{
if (props[j].propertyType == PropertyType.PROPERTY)
{
if (props[j].propertyValueType == PropertyValueType.TwoD_SPATIAL || props[j].propertyValueType == PropertyValueType.ThreeD_SPATIAL)
{
if (props[j].canSetExpression) coins.push(props[j]);
}
}
}
}
//si il n'y a pas de coins selectionnes, on les prend tous
if (!coins.length) coins = Duik.utils.getPuppetPins(calque("Effects"));
//si on a vraiment rien trouve, on laisse tomber
if (!coins.length) throw "Please select a spatial property to link it to a bone.\nYou cannot link a non-spatial property to a bone\nIt must have two or three dimensions.";

for (var j=0;j<coins.length;j++)
{
var coin = coins[j];

var position;

if (coin.matchName == "ADBE FreePin3 PosPin Atom")
{
position = coin.position;
}
else
{
position = coin;
}

//creer le bone
var bone;
//sa taille
boneTaille = Duik.settings.boneSize;
if (Duik.settings.boneSizeAuto)
{
if (calque instanceof ShapeLayer)
{
boneTaille = app.project.activeItem.height/2 + app.project.activeItem.height/2;
}
else
{
var calqueParent = calque.parent;
calque.parent = null;
var calqueEchelle = calque.transform.scale.value;
calque.parent = calqueParent;
boneTaille = calque.source.width*Math.abs(calqueEchelle[0])/130 + calque.source.height*Math.abs(calqueEchelle[1])/130;
}

if (Duik.settings.boneSizeHint == Duik.sizes.SMALL) boneTaille = Math.floor(boneTaille/60);
else if (Duik.settings.boneSizeHint == Duik.sizes.MEDIUM) boneTaille = Math.floor(boneTaille/40);
else if (Duik.settings.boneSizeHint == Duik.sizes.BIG) boneTaille = Math.floor(boneTaille/20);
}
if (Duik.settings.boneType == Duik.layerTypes.NULL)
{
bone = app.project.activeItem.layers.addNull();
bone.name = "B_" + coin.name;
bone.source.width = boneTaille;
bone.source.height = boneTaille;
bone.transform.anchorPoint.setValue([bone.source.width/2,bone.source.height/2]);
}
else
{
var colorString = Duik.settings.boneColor;
bone = app.project.activeItem.layers.addSolid(Duik.utils.hexColorToRVB(colorString),"B_" + coin.name,boneTaille,boneTaille,app.project.activeItem.pixelAspect);
}
if (placement == Duik.placement.OVER_LAYER) bone.moveBefore(calque);
else if (placement == Duik.placement.UNDER_LAYER) bone.moveAfter(calque);
else if (placement == Duik.placement.BOTTOM) bone.moveToEnd();

//group
Duik.utils.addLayerToDuGroup(bone,Duik.uiStrings.bones);

createdBones.push(bone);

//mettre le bone a la position du coin : utiliser une expression pour avoir la position en mode world du coin
Duik.utils.pickWhip(bone.position,position);
if (!(calque instanceof ShapeLayer))
{
bone.position.expression = "thisComp.layer(\"" + calque.name + "\").toWorld(" + bone.position.expression + ")";
}

bone.position.setValue(bone.position.value);
bone.position.expression = "";
//nom du bone
if (coin.matchName == "ADBE FreePin3 PosPin Atom")
{
bone.name = "B_" + coin.name;
}
else
{
var name = "B_" + coin.name + "_" + coin.parentProperty.name;
if (name.length > 32) name = name.substr(0,32);
bone.name = name;
}

bone.guideLayer = true;
//mettre l'expression dans le coin
if (calque instanceof ShapeLayer)
{
position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint)";
}
else
{
position.expression = "bonePos = thisComp.layer(\"" + bone.name + "\").toWorld(thisComp.layer(\"" + bone.name + "\").anchorPoint);\nfromWorld(bonePos)";
}
}//for coins
}//for layers
return createdBones;
}
}
// ADD ZERO - Duik.addZero(layer);
if (typeof Duik.addZero !== 'function')
{
Duik.addZero = function (layer)
{
//create null object
var zero = layer.containingComp.layers.addNull();
Duik.utils.addLayerToDuGroup(zero,Duik.uiStrings.zeroes);
var calqueparent = layer.parent;
layer.parent = null;
zero.position.setValue(layer.position.value);
zero.rotation.setValue(layer.rotation.value);
zero.name = "Zero_" + layer.name.slice(-24);
layer.parent = zero;
zero.scale.setValue(layer.scale.value);
layer.scale.setValue([100,100,100]);

//parent
zero.parent = calqueparent;

//lock and hide
zero.moveToEnd();
zero.guideLayer = true;
zero.locked = true;
zero.shy = true;
zero.enabled = false;

return zero;
}
}
/* ADD ZEROS - Duik.addZeros(layers);

Adds a null object for each layer, at the same place and orientation,
and then parents the layer to it, parenting the null object (the zero) to the former
parent of the layer.

parameters
layers | Array of AVLayer

returns
Array of AVLayers, the zeros created

*/
if (typeof Duik.addZeros !== 'function')
{
Duik.addZeros = function (layers)
{
var zeros = [];
for (var i = 0 ; i < layers.length ; i++)
{
var calque = Duik.utils.getItem(layers,i);
var zero = Duik.addZero(calque);
zeros.push(zeros);
}
return zeros;
}
}
/* ROTATION MORPH - Duik.rotationMorph(layer,prop);

Creates a rotation morph on the given property

parameters
layer | AVLayer
prop | Property

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.rotationMorph !== 'function')
{
Duik.rotationMorph = function (layer,prop)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.RotMorph);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.rotMorph);

prop.expression = "//Duik.rotationMorph\r\n" +
"if (numKeys > 1)\r\n" +
"{\r\n" +
"r = thisLayer.effect('" + effect.name + "')(1).transform.rotation;\r\n" +
"n = timeToFrames(key(numKeys).time);\r\n" +
"Min =  thisLayer.effect('" + effect.name + "')(2);\r\n" +
"Max = thisLayer.effect('" + effect.name + "')(3);\r\n" +
"div =  (Max - Min) / n;\r\n" +
"val = 0;\r\n" +
"if (div != 0) val = r/div - (Min/div);\r\n" +
"valueAtTime(framesToTime(val));\r\n" +
"} else value;";

return true;
}
}
/* SWING - Duik.swing(layer,prop);

Creates a swing on the given property

parameters
layer | AVLayer
prop | Property

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.swing !== 'function')
{
Duik.swing = function (layer,prop)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.Swing);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.swing);
effect(1).setValue(10);
effect(2).setValue(1);

prop.expression = "//Duik.swing\r\n" +
"amp = effect('" + effect.name + "')(1);\n" +
"freq = effect('" + effect.name + "')(2)*2*Math.PI;\n" +
"decalage = framesToTime(effect('" + effect.name + "')(3));\n" +
"amorti = Math.abs(effect('" + effect.name + "')(4));\n\n" +
"sin = Math.sin(time*freq+decalage);\n\n" +
"for(i=0;i<amorti;i++) {\n" +
"sin = Math.sin(sin);\n" +
"}\n" +
"sin*amp+value;";

return true;
}
}
/* WHEEL - Duik.wheel(layer,radius,curved);

Automates the rotation of the given layer using its position.
If curved, works even if the trajectory is not horizontal, but is heavier to compute.

parameters
layer | AVLayer
radius | float, default 100.0
curved | boolean, default false

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.wheel !== 'function')
{
Duik.wheel = function (layer,radius,curved)
{
if (radius == undefined) radius = 100;
else if (! (radius > 0)) radius = 100;
if (curved == undefined) curved = false;
var prep = Duik.utils.rigProperty(layer,layer.transform.rotation,Duik.effects.Wheel);
var effect = prep[0];
if (effect == null) return false;
Duik.utils.renameEffect(effect,Duik.uiStrings.wheel);
effect(1).setValue(radius);

if (!curved) layer.transform.rotation.expression = "//Duik.Wheel\r\n" +
"O = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
"R = thisLayer.effect('" + effect.name + "')(1);\n" +
"Rev = thisLayer.effect('" + effect.name + "')(2);\n" +
"result = 0;\n" +
"R > 0 ? result = radiansToDegrees(O[0]/R) : result = 0 ;" +
"Rev == 1 ? value - result : value + result;";
else layer.transform.rotation.expression = "//Duik.Wheel\r\n" +
"R = thisLayer.effect('" + effect.name + "')(1);\n" +
"Rev = thisLayer.effect('" + effect.name + "')(2);\n" +
"var precision = 1;\n" +
"function pos(frame)\n" +
"{\n" +
"return thisLayer.toWorld(thisLayer.anchorPoint,framesToTime(frame));\n" +
"}\n" +
"function roue()\n" +
"{\n" +
"if (R<=0) return value;\n" +
"var distance = 0;\n" +
"var start = thisLayer.inPoint > thisComp.displayStartTime ? timeToFrames(thisLayer.inPoint) : timeToFrames(thisComp.displayStartTime) ;\n" +
"var end = time < thisLayer.outPoint ? timeToFrames(time) : timeToFrames(thisLayer.outPoint);\n" +
"for(i=start;i<end;i+=precision)\n" +
"{\n" +
"if (pos(i+precision)[0] - pos(i)[0] > 0) distance += length(pos(i+precision),pos(i));\n" +
"else distance -= length(pos(i+precision),pos(i));\n" +
"}\n" +
"return radiansToDegrees(distance/R) ;\n" +
"}\n" +
"Rev == 1 ? value - roue() : value + roue();";

return true;
}
}
/* MORPHER - Duik.morpher(layers);

Adds a "morpher", a slider to easily control interpolations of selected properties of the given layers.

parameters
layers | Array of AVLayer

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.morpher !== 'function')
{
Duik.morpher = function (layers)
{
//recuperer la selection d'effets du premier calque, puisqu'elle sera perdue a la creation de la glissiere..... (voir avec adobe si vous trouvez ca pas pratique)
var selection = [];
var effets = Duik.utils.getItem(layers,0).selectedProperties;

for (var j=0;j<effets.length;j++) {
if (effets[j].canSetExpression && effets[j].parentProperty.isEffect) {
var layerIndex = app.project.activeItem.selectedLayers[0].index;
var effetIndex =  effets[j].propertyIndex;
var effetParentName = effets[j].parentProperty.name;
selection.push([layerIndex,effetParentName,effetIndex]);
delete effetIndex;
delete effetParentName;
}
}

//creer le curseur
var morpher = layers[0].Effects.addProperty("ADBE Slider Control");
Duik.utils.renameEffect(morpher,Duik.uiStrings.morpher);

//boucle pour appliquer le morpher sur la selection perdue
for (var i=0;i<selection.length;i++)
{
var effet = layers[0].effect(selection[i][1])(selection[i][2]);
effet.expression = "//Duik.Morpher\r\nvalueAtTime((thisComp.layer(\"" +  layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
//la boucle pour creer automatiquement des clefs sur le morpher :
if (Duik.settings.morpherCreatesKeyframes)
{
//nombre de clefs
var nbreClefs = effet.numKeys;
//duree d'image de la compo
var ips = app.project.activeItem.frameDuration;
var temps = 0;
var prop = effet;
for (var k=1;k<=nbreClefs;k++)
{
//recupere l'instant de la clef
temps = prop.keyTime(k);
//cree une image clef sur le morpher
morpher(1).setValueAtTime(temps,temps/ips);
}
delete temps;
delete prop;
delete ips;
delete nbreClefs;
}
}

//boucle pour appliquer le morpher partout
for (var i=0;i<layers.length;i++)
{
for (var j=0;j<layers[i].selectedProperties.length;j++)
{
var effet = Duik.utils.getItem(layers,i).selectedProperties[j];
if (effet.canSetExpression && effet.parentProperty.name != "Morpher")
{
effet.expression = "valueAtTime((thisComp.layer(\"" + layers[0].name +"\").effect(\"Morpher\")(1)-thisComp.displayStartTime/thisComp.frameDuration)*thisComp.frameDuration)";
//la boucle pour creer automatiquement des clefs sur le morpher :
if (Duik.settings.morpherCreatesKeyframes)
{
//nombre de clefs
var nbreClefs = effet.numKeys;
//duree d'image de la compo
var ips = app.project.activeItem.frameDuration;
var temps = 0;
var prop = effet;
for (var k=1;k<=nbreClefs;k++)
{
//recupere l'instant de la clef
temps = prop.keyTime(k);
//cree une image clef sur le morpher
morpher(1).setValueAtTime(temps,temps/ips);
}
delete temps;
delete prop;
delete ips;
delete nbreClefs;
}
}
}
}

return true;
}
}
/* LENS FLARE - Duik.lensFlare(layers);

Rigs the layers to move like a lens flare.

parameters
layers | Array of AVLayer

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.lensFlare !== 'function')
{
Duik.lensFlare = function (layers)
{
//sortir le premier calque, le centre, et ajouter les controleurs
var centre = layers.shift();

//check names
Duik.utils.checkNames(centre.containingComp);

var nomcentre = centre.name;
var centerEffect;
centerEffect = Duik.utils.addEffect(centre,Duik.effects.LensFlare);
centerEffect.name = Duik.uiStrings.lensFlare;
centerEffect(1).setValue(100);
centerEffect(2).setValue(100);

//l'expression de position
var positionexpression = "//Duik.LensFlare\r\n" +
"calqueCentre = thisComp.layer(\"" + nomcentre + "\");\n\n" +
"function positionAbs(calque) {\n" +
"return calque.toWorld(calque.anchorPoint)\n" +
"}\n\n" +
"n=effect(\"" + centerEffect.name + "\")(1);\n\n" +
"X = thisComp.width - positionAbs(calqueCentre)[0];\n" +
"Y = thisComp.height - positionAbs(calqueCentre)[1];\n\n" +
"i=n/100;\n" +
"j=1-i;\n\n" +
"if (n!=100) value + ( (  [X,Y]*(i/j) + positionAbs(calqueCentre) )*j)\n" +
"else value + [X,Y];";

//l'expression d'opacite
var opaciteexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + centre.name  + "\").effect(\"" + centerEffect.name + "\")(1);\n" + "value*n/100";

//l'expression d'echelle
var tailleexpression = "//Duik.LensFlare\r\n" + "n=thisComp.layer(\"" + nomcentre  + "\").effect(\"" + centerEffect.name + "\")(2);\n" + "value*n/100";

//appliquer les expressions sur le centre
centre.transform.opacity.expression = opaciteexpression;
centre.transform.scale.expression = tailleexpression;

//la boucle d'application des expressions et controleurs
var nombrecalques = layers.length;
for (var layerI = 0; layerI < nombrecalques; layerI++)
{
calque = layers[layerI];
calque.position.setValue([0,0]);
//le controleur de la distance
var distanceEffect;
distanceEffect = Duik.utils.addEffect(calque,Duik.effects.LensFlareDistance);
distanceEffect.name = Duik.uiStrings.lensFlare;
distanceEffect(1).setValue(100/nombrecalques*(layerI+1));

//appliquer les expressions
calque.transform.position.expression = positionexpression;
calque.transform.opacity.expression = opaciteexpression;
calque.transform.scale.expression = tailleexpression;

//fin de la boucle
}

//selectionner le centre (controleur)
Duik.utils.deselectLayers();
centre.selected = true;
}
}
/* DISTANCE LINK - Duik.distanceLink(layer,property,parentLayer);

Links the property to the distance of parentLayer

parameters
layer | AVLayer containing the property
property | Property to rig
parentLayer | AVLayer which distance from layer is used to rig

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.distanceLink !== 'function')
{
Duik.distanceLink = function (layer,prop,parentLayer)
{
//add effect
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.DistanceLink);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.distanceLink);
//get the distance between the two layers
var distance = Duik.utils.getDistance(layer,parentLayer);
effect(2).setValue(distance - distance/4.0);
effect(3).setValue(distance + distance/4.0);

//check names
Duik.utils.checkNames(layer.containingComp);

if (parentLayer instanceof CameraLayer)
{
prop.expression = "//Duik.DistanceLink\r\n" +
"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" +
"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" +
"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" +
"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" +
"falloff=effect(\"" + effect.name + "\")(6);\n" +
"function positionAbs(calque) {\n" +
"return calque.toWorld(calque.anchorPoint);\n" +
"}\n\n" +
"distance = length(calqueRef.position,positionAbs(thisLayer));\n" +
"if (distMax>=distMin && falloff!=0){\n" +
"if (distance <= distMax && distance >=distMin) {value}\n" +
"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" +
"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" +
"if (distMax==0){value + distance/falloff}\n" +
"}else {value}";
}
else
{
prop.expression = "//Duik.DistanceLink\r\n" +
"calqueRef = thisComp.layer(\"" + parentLayer.name + "\");\n" +
"distMin=Math.abs(effect(\"" + effect.name + "\")(2));\n" +
"distMax=Math.abs(effect(\"" + effect.name + "\")(3));\n" +
"reverse = effect(\"" + effect.name + "\")(5) == 1 ? -1 : 1 ;\n" +
"falloff=effect(\"" + effect.name + "\")(6);\n" +
"function positionAbs(calque) {\n" +
"return calque.toWorld(calque.anchorPoint);\n" +
"}\n\n" +
"distance = length(positionAbs(calqueRef),positionAbs(thisLayer));\n" +
"if (distMax>=distMin && falloff!=0){\n" +
"if (distance <= distMax && distance >=distMin) {value}\n" +
"if (distance > distMax && distMax!=0) {value + (distance/falloff-distMax/falloff)*reverse}\n" +
"if (distance < distMin){value + (distMin/falloff-distance/falloff)*reverse}\n" +
"if (distMax==0){value + distance/falloff}\n" +
"}else {value}";
}

return true;

}
}
/* SPRING - Duik.spring(property, layer, simulated);

Adds a spring effect on the property

parameters
property | Array of property
simulated | if true, applies the simulated version of the spring, default: false

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.spring !== 'function')
{
Duik.spring = function (prop, simulated)
{
if (prop == undefined) return;

//search for one dimension effects, to know if we need a "bounce" checkbox
var bounce = false;
if (prop.propertyValueType == PropertyValueType.OneD) bounce = true;

//if it's not a position, light version
if (prop.matchName != "ADBE Position") simulated = false;
if (simulated == undefined) simulated = false;

var layer = Duik.utils.getPropertyLayer(prop);

var effect;
if (bounce)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.Spring_Bounce);
var effect = prep[0];
prop = prep[1];
}
else
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.Spring);
var effect = prep[0];
prop = prep[1];
}
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.spring);

if (bounce)
{
prop.expression = "//Duik.Spring\r\n" +
"amorti = effect(\"" + effect.name + "\")(2);\n" +
"freq = effect(\"" + effect.name + "\")(1);\n" +
"speedLimit = effect(\"" + effect.name + "\")(4);\n" +
"rebond = effect(\"" + effect.name + "\")(3);\n\n" +
"if (numKeys > 1 && freq != 0 ){\n" +
"if (nearestKey(time).index == 1) { value }\n" +
"else {\n\n" +
"if (length(velocity) <= speedLimit ) {\n\n" +
"tempsClefProx = nearestKey(time).time;\n\n" +
"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
"temps = time - tempsDebut;\n\n" +
"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n" +
"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
"if (rebond == 0) valueAtTime(tempsDebut) + spring;\n\n" +
"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" +
"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" +
"}\n" +
"else { value }\n" +
"}\n" +
"}\n" +
"else { value }";
}
else if (!simulated)
{
prop.expression = "//Duik.Spring\r\n" +
"amorti = effect(\"" + effect.name + "\")(2);\n" +
"freq = effect(\"" + effect.name + "\")(1);\n" +
"speedLimit = effect(\"" + effect.name + "\")(3);\n" +
"rebond = 0;\n\n" +
"if (numKeys > 1 && freq != 0 ){\n" +
"if (nearestKey(time).index == 1) { value }\n" +
"else {\n\n" +
"if (length(velocity) <= speedLimit ) {\n\n" +
"tempsClefProx = nearestKey(time).time;\n\n" +
"if ( tempsClefProx <= time ) { tempsDebut = tempsClefProx }\n" +
"else { tempsDebut = key(nearestKey(time).index-1).time }\n\n" +
"temps = time - tempsDebut;\n\n" +
"spring = velocityAtTime(tempsDebut-thisComp.frameDuration) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n" +
"if (speedLimit > 0) spring = spring * (1-length(velocity)/speedLimit);\n" +
"if (rebond == 0) valueAtTime(tempsDebut) + spring;\n\n" +
"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) >  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) + Math.abs(spring);\n\n" +
"if (rebond == 1 &&  valueAtTime(tempsDebut-thisComp.frameDuration) <  valueAtTime(tempsDebut)) valueAtTime(tempsDebut) - Math.abs(spring);\n\n" +
"}\n" +
"else { value }\n" +
"}\n" +
"}\n" +
"else { value }";
}
else
{
prop.expression = "//Duik.spring\r\n" +
"amorti = effect(\"" + effect.name + "\")(2);\n" +
"freq = effect(\"" + effect.name + "\")(1);\n" +
"if (amorti == 0) amorti = 0.1;\n" +
"if (freq == 0) freq = 0.1;\n" +
"retard = freq/amorti;\n" +
"poids = 1/amorti/10;\n" +
"precision = thisComp.frameDuration;\n" +
"function worldVelocity(temps) {\n" +
"worldVelocityX = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[0]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[0])*100;\n" +
"worldVelocityY = (thisLayer.toWorld(thisLayer.anchorPoint,temps)[1]-thisLayer.toWorld(thisLayer.anchorPoint,temps-.01)[1])*100;\n" +
"return [worldVelocityX,worldVelocityY];\n" +
"}\n" +
"function worldSpeed(temps) {\n" +
"return length(worldVelocity(temps));\n" +
"}\n" +
"tempsDebut = 0;\n" +
"tempsRedemarrage = 0;\n" +
"stop = false;\n" +
"arrete = false;\n" +
"for (i=timeToFrames(time);i>=0;i--) {\n" +
"var instant = framesToTime(i);\n" +
"var instantSuivant = instant-precision;\n" +
"if (worldSpeed(instant) == 0 ) {\n" +
"if (tempsRedemarrage == 0) tempsRedemarrage = instant;\n" +
"if (worldSpeed(instantSuivant) !=0 ) {\n" +
"tempsDebut = instantSuivant;\n" +
"break;\n" +
"}\n" +
"}\n" +
"}\n" +
"temps = time-tempsDebut;\n" +
"frameRedemarre = timeToFrames( time-tempsRedemarrage);\n" +
"valeur = value\n" +
"if ( frameRedemarre <= retard)\n" +
"valeur = value - worldVelocity(time)*poids*(frameRedemarre/retard);\n" +
"else\n" +
"valeur = value - worldVelocity(time)*poids;\n" +
"if (worldSpeed(time) == 0) {\n" +
"spring = worldVelocity(tempsDebut) * ( .15/freq * Math.sin(freq * temps * 2 * Math.PI) / Math.exp( temps * amorti ) );\n" +
"valeur + spring;\n" +
"}else{ valeur; }\n";
}

return true;
}
}
/* PATH FOLLOW - Duik.pathFollow(layer);

Automates the rotation of the layer so it follows its path.

parameters
layer | AVLayer

returns
void

*/
if (typeof Duik.pathFollow !== 'function')
{
Duik.pathFollow = function (layer)
{
//expression a inserer
layer.transform.rotation.expression  = "//Duik.PathFollow\n" +
"ff = framesToTime(1);\r\n" +
"pos = thisLayer.position;\r\n" +
"if (pos.numKeys > 1){\n" +
"A = pos.valueAtTime(time-ff);\r\n" +
"B =  pos.valueAtTime(time+ff);\r\n\r\n" +
"if (pos.key(1).time > time){\r\n" +
"A = pos.key(1).value;\r\n" +
"B =pos.valueAtTime(pos.key(1).time+ff);\r\n" +
"}\r\n\r\n" +
"if (thisLayer.position.key(thisLayer.position.numKeys).time < time){\r\n" +
"A = pos.valueAtTime(pos.key(pos.numKeys).time-ff);\r\n" +
"B = pos.key(pos.numKeys).value;\r\n" +
"}\r\n\r\n" +
"angle = lookAt(A,B);\r\n" +
"angle[0] > 0 ? angle[0]+angle[1]+value : angle[0]-angle[1]+value;\r\n" +
"} else value;";
}
}
/* MULTIPLANE - Duik.multiplane(numLayers);

Creates null objects rigged to easily animate a 2D multiplane camera.

parameters
numLayers | int, number of layers to create, default: 3

returns
void

*/
if (typeof Duik.multiplane !== 'function')
{
Duik.multiplane = function (nbre)
{
if (nbre == undefined) nbre = 3;
//la couche camera
camNbre = Math.ceil(nbre/2);

var calqueCam;

for (var i=1;i<=nbre;i++)
{
var numero = "L00";
i < 10 ? numero = "L0" + i : numero = "L" + i ;
//creer les nuls et leurs zeros

if (i == camNbre)
{
if (Duik.settings.controllerType == Duik.layerTypes.VECTOR)
{
var cam = Duik.addController();
cam.camera = true;
cam.update();
calqueCam = cam.layer;
}
else
{
var calqueCam = app.project.activeItem.layers.addNull();
}

//Creer un ctrl cam
calqueCam.name = numero + " cam";
//ajouter un zero
Duik.addZero(calqueCam);
}
else
{
var calque = app.project.activeItem.layers.addNull() ;
calque.name = numero;
//ajouter un zero
Duik.addZero(calque);
}
}

//cam effect
var effect;
effect = Duik.utils.addEffect(calqueCam,Duik.effects.Multiplane);
effect.name = Duik.uiStrings.multiplane;

//cam rig
var camZero = calqueCam.parent;
//tilt
camZero.transform.rotation.expression = "//Duik.multiplane\n" +
"thisComp.layer(\"L0" + camNbre + " cam\").effect(\"" + Duik.uiStrings.multiplane + "\")(4);";
//zoom & truck in/out
camZero.transform.scale.expression = "//Duik.multiplane\n" +
"var zoom = thisComp.layer(\"L0" + camNbre + " cam\").effect(\"" + Duik.uiStrings.multiplane + "\")(2);\n" +
"var truck = thisComp.layer(\"L0" + camNbre + " cam\").effect(\"" + Duik.uiStrings.multiplane + "\")(3);\n" +
"value + [zoom,zoom] + [truck,truck];";
//pan
camZero.transform.position.expression = "//Duik.multiplane\n" +
"thisComp.layer(\"L0" + camNbre + " cam\").effect(\"" + Duik.uiStrings.multiplane + "\")(1);";

//ajouter les expressions et curseurs
for (var i=1;i<=nbre;i++)
{
//si on n'est pas sur le calque cam (dont on differencie le numero si il est pair ou impair)
if (i != camNbre-nbre%2+1 )
{
var calque = app.project.activeItem.layer(i);
var zero = calque.parent;
//add position expression
var curseur = calque.Effects.addProperty("ADBE Slider Control");
curseur.name = Duik.uiStrings.camInfluence;
(i<camNbre+1) ? curseur(1).setValue(Math.abs(i-camNbre-2)-nbre%2) : curseur(1).setValue((1/camNbre)*Math.abs(i-nbre-1)) ;
delete curseur;
calque.transform.position.expression = "//Duik.multiplane\nthisComp.layer(\"L0" + camNbre + " cam\").position * effect(\"" + curseur.name + "\")(1)";
//rig the zero
//tilt
zero.transform.rotation.expression = "//Duik.multiplane\n" +
"thisComp.layer(\"L0" + camNbre + " cam\").effect(\"" + Duik.uiStrings.multiplane + "\")(4);";
//zoom & truck in/out
zero.transform.scale.expression = "//Duik.multiplane\n" +
"var zoom = thisComp.layer(\"L0" + camNbre + " cam\").effect(\"" + Duik.uiStrings.multiplane + "\")(2);\n" +
"var truck = thisComp.layer(\"L0" + camNbre + " cam\").effect(\"" + Duik.uiStrings.multiplane + "\")(3);\n" +
"var infl = thisComp.layer(\"" + calque.name + "\").effect(\"" + curseur.name + "\")(1);\n" +
"value + [zoom,zoom] + [truck,truck]*infl;";
//pan
zero.transform.position.expression = "//Duik.multiplane\n" +
"thisComp.layer(\"L0" + camNbre + " cam\").effect(\"" + Duik.uiStrings.multiplane + "\")(1);";
}
}

Duik.utils.deselectLayers();
calqueCam.selected = true;
}
}
/* COPY ANIM - Duik.copyAnim(layers,selectedKeysOnly,startTime,endTime);

Copy all the animations (except expressions) on selected layers, and store them in Duik.copiedAnim.

parameters
layers | Array or Collection of AVLayers
selectedKeysOnly | boolean, true to copy only selected keys, default: false
startTime | float, default: start of comp
endTime | float, default: end of comp

returns
Array of LayerAnim

*/
if (typeof Duik.copyAnim !== 'function')
{
Duik.copyAnim = function (layers,selectedKeysOnly,startTime,endTime)
{
if (layers.length == 0)
{
return null;
}

var comp = Duik.utils.getItem(layers,0).containingComp

if (selectedKeysOnly == undefined) selectedKeysOnly = false;
if (startTime == undefined) startTime = comp.workAreaStart;
if (endTime == undefined) endTime = comp.workAreaDuration + comp.workAreaStart;

Duik.copiedAnim = [];

//parcourir tous les calques a la recherche des anims a sauvegarder
for (var layerIndex = 0; layerIndex < layers.length ; layerIndex++)
{
var layerAnim = new LayerAnim();
var l = Duik.utils.getItem(layers,layerIndex);
layerAnim.name = l.name;
layerAnim.index = l.index;

// 1 - sauver l'anim des transformations
layerAnim.transformAnims = Duik.utils.getPropertyAnims(l.transform,selectedKeysOnly,false,startTime,endTime);

// 2 - les masques
for (var maskIndex=1;maskIndex<=l("Masks").numProperties;maskIndex++)
{
var maskAnim = new MaskAnim();
maskAnim.name = l("Masks")(maskIndex).name;
maskAnim.anims = Duik.utils.getPropertyAnims(l("Masks")(maskIndex),selectedKeysOnly,false,startTime,endTime);
if (maskAnim.anims.length >=1) layerAnim.masksAnims.push(maskAnim);
}

// 3 - les effets
for (var effectIndex=1;effectIndex<=l("Effects").numProperties;effectIndex++)
{
var effectAnim = new EffectAnim();
effectAnim.name = l("Effects")(effectIndex).name;
effectAnim.matchName = l("Effects")(effectIndex).matchName;
effectAnim.anims = Duik.utils.getPropertyAnims(l("Effects")(effectIndex),selectedKeysOnly,false,startTime,endTime);
if (effectAnim.anims.length >=1) layerAnim.effectsAnims.push(effectAnim);
}

Duik.copiedAnim.push(layerAnim);

}
return Duik.copiedAnim;
}
}
/* PASTE ANIM - Duik.pasteAnim(layers,layerAnims,startTime,getLayerMethod);

Paste all the animations in the Array of LayerAnim on layers, using layer names or layer indexes, beginning at startTime

parameters
layers | Layers where to paste the animation
layerAnims | Array of LayerAnim, default: Duik.copiedAnim
startTime | float, default: comp.time
getLayerMethod | one of Duik.getLayers.NAME, Duik.getLayers.INDEX, Duik.getLayers.SELECTION_INDEX, default: Duik.settings.getLayersMethod

returns
integer, number of layers where animations were pasted

*/
if (typeof Duik.pasteAnim !== 'function')
{
Duik.pasteAnim = function (layers,layerAnims,startTime,getLayerMethod)
{
if (layers == undefined) return 0;
if (layers.length == 0) return 0;
if (layerAnims == undefined) layerAnims = Duik.copiedAnim;
if (getLayerMethod == undefined) getLayerMethod = Duik.settings.getLayersMethod;
var comp = Duik.utils.getItem(layers,0).containingComp;
if (startTime == undefined) startTime = comp.time;

var totalPasted = 0;

for (var li = 0;li < layers.length;li++)
{
var l = Duik.utils.getItem(layers,li);
var layerAnim = null;
//parcourir les animations sauvees pour trouver celle qui matche le calque
if (getLayerMethod == Duik.getLayers.INDEX)
{
for (var ai = 0;ai < layerAnims.length;ai++)
{
if (layerAnims[ai].index == l.index)
{
layerAnim = layerAnims[ai];
break;
}
}
}
else if (getLayerMethod == Duik.getLayers.NAME)
{
for (var ai = 0; ai < layerAnims.length ; ai++)
{
if (layerAnims[ai].name == l.name)
{
layerAnim = layerAnims[ai];
break;
}
}
}
else if (getLayerMethod == Duik.getLayers.SELECTION_INDEX)
{
if (li < layerAnims.length) layerAnim = layerAnims[li];
}

if (layerAnim == null) continue;

totalPasted++;

//transform
if (layerAnim.transformAnims.length > 0)
{
for (var j = 0;j< layerAnim.transformAnims.length; j++)
{
Duik.utils.setPropertyAnim(l.transform,layerAnim.transformAnims[j],startTime);
}
}

//masks
if (layerAnim.masksAnims.length > 0)
{
for (var j = 0;j< layerAnim.masksAnims.length; j++)
{
for (var k = 1;k<=l("Masks").numProperties;k++)
{
if (l("Masks")(k).name == layerAnim.masksAnims[j].name)
{
for (var mi = 0;mi < layerAnim.masksAnims[j].anims.length;mi++)
{
Duik.utils.setPropertyAnim(l("Masks")(layerAnim.masksAnims[j].name),layerAnim.masksAnims[j].anims[mi],startTime);
}
break;
}
}
}
}

//effects
if (layerAnim.effectsAnims.length > 0)
{
for (var j = 0;j< layerAnim.effectsAnims.length; j++)
{
for (var k = 1;k<=l("Effects").numProperties;k++)
{
if (l("Effects")(k).name == layerAnim.effectsAnims[j].name && l("Effects")(k).matchName == layerAnim.effectsAnims[j].matchName)
{
for (var ei = 0;ei < layerAnim.effectsAnims[j].anims.length;ei++)
{
Duik.utils.setPropertyAnim(l("Effects")(layerAnim.effectsAnims[j].name),layerAnim.effectsAnims[j].anims[ei],startTime);
}
break;
}
}
}
}
}
return totalPasted;
}
}
/* RIG PAINT - Duik.rigPaint(layers);

Rigs the paint effects to be able to animate all strokes as if there was only one.

parameters
layers | Array of Layers or LayerCollection which have a paint effect

returns
void

*/
if (typeof Duik.rigPaint !== 'function')
{
Duik.rigPaint = function (layrs)
{
var layers = Duik.utils.convertCollectionToArray(layrs);
for (var i = 0 ; i < layers.length ; i++)
{
var layer = layers[i];

//if there's no paint effect
var paintEffect = layer("Effects")("ADBE Paint");
if (paintEffect == null) continue;

//add effect
var effect;
effect = Duik.utils.addEffect(layer,Duik.effects.Paint_Rig);

effectName = Duik.uiStrings.paintRig;
effect.name = effectName;

//need to get the paint effect again after addProperty, After Effects bug.......
var paintEffect = layer("Effects")("ADBE Paint");

//for each stroke
var nbre = paintEffect.property(2).numProperties;
for (var j=1;j<=nbre;j++)
{
var stroke = paintEffect.property(2).property(j);
var propStart = stroke.property(4).property(1);
var propEnd = stroke.property(4).property(2);
var propDiam = stroke.property(4).property(4);

propStart.expression = "//Duik.PaintRig\n" +
"var ctrl = effect(\"" + effectName + "\")(1);\n" +
"var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n" +
"var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n" +
"result = ctrl - ((100/total)*(ind-1));\n" +
"result = result * total;\n" +
"result;";

propEnd.expression = "//Duik.PaintRig\n" +
"var ctrl = effect(\"" + effectName + "\")(2);\n" +
"var total = thisProperty.propertyGroup().propertyGroup().propertyGroup().numProperties;\n" +
"var ind = total + 1 - thisProperty.propertyGroup().propertyGroup().propertyIndex;\n" +
"result = ctrl - ((100/total)*(ind-1));\n" +
"result = result * total;\n" +
"result;";

propDiam.expression = "//Duik.PaintRig\n" +
"value+effect(\"" + effectName + "\")(3);";
}
}
}
}
/* BLINK - Duik.blink(layer,prop);

Adds a blink effect to the property.

parameters
layer | AVLayer
prop | Property

returns
true if successful, false if anything went wrong

*/
if (typeof Duik.blink !== 'function')
{
Duik.blink = function (layer,prop)
{
var dim = Duik.utils.getPropertyDimensions(prop);
if (dim == 1)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.Blink_1D);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.blink);

prop.expression = "//Duik.blink\r\n" +
"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
"var offValue = effect(\"" + effect.name + "\")(4);\r\n" +
"freq= timeToFrames(1)/freq;\r\n" +
"var currentFrame = timeToFrames(time)+offset;\r\n" +
"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
"else value;";
}
else if (dim == 2)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.Blink_2D);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.blink);

prop.expression = "//Duik.blink\r\n" +
"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
"var offValue = [effect(\"" + effect.name + "\")(4),effect(\"" + effect.name + "\")(5)];\r\n" +
"freq= timeToFrames(1)/freq;\r\n" +
"var currentFrame = timeToFrames(time)+offset;\r\n" +
"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
"else value;";
}
else if (dim == 3)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.Blink_3D);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.blink);

prop.expression = "//Duik.blink\r\n" +
"var freq = effect(\"" + effect.name + "\")(1);\r\n" +
"var timeOn = effect(\"" + effect.name + "\")(2);\r\n" +
"var offset = effect(\"" + effect.name + "\")(3);\r\n" +
"var offValue = [effect(\"" + effect.name + "\")(4),effect(\"" + effect.name + "\")(5),effect(\"" + effect.name + "\")(6)];\r\n" +
"freq= timeToFrames(1)/freq;\r\n" +
"var currentFrame = timeToFrames(time)+offset;\r\n" +
"if (currentFrame%freq > freq*timeOn/100) offValue;\r\n" +
"else value;";
}

return true;
}
}
/* LOCK PROPERTY - Duik.lockProperty(layer,prop);

Locks the property with a simple expression.

parameters
prop | Property

returns
void

*/
if (typeof Duik.lockProperty !== 'function')
{
Duik.lockProperty = function (prop)
{
if (prop.canSetExpression)
{
prop.expression = uneval(prop.value);
}
}
}
/* SCALE Z-LINK - Duik.scaleZLink(layers);

Links the distance of the layer from the camera to its scale so its apparent size won't change.
If multiple cameras, include the camera used in the array

parameters
layers | Array of Layer or LayerCollection

returns
void

*/
if (typeof Duik.scaleZLink !== 'function')
{
Duik.scaleZLink = function (layrs)
{
if (layrs == undefined) return;
if (layrs.length == 0) return;

var camera = null;
//find camera
var layers = Duik.utils.convertCollectionToArray(layrs);
for (i = 0 ; i <layers.length;i++)
{
var l = layers[i];
if (l instanceof CameraLayer)
{
camera = l;
break;
}
}
if (camera == null)
{
var comp = layers[0].containingComp;
for (var i = 1;i<=comp.layers.length;i++)
{
var l = comp.layers[i];
if (l instanceof CameraLayer)
{
camera = l;
break;
}
}
}
if (camera == null) return;

//go!
var layers = Duik.utils.convertCollectionToArray(layrs);
for (i = 0 ; i <layers.length;i++)
{
	var layer = layers[i];
	layer.threeDLayer = true;
	if (!layer.threeDLayer) continue;
	var currentDistance = Duik.utils.getDistance(layer,camera);
	if (currentDistance == 0) currentDistance = 1;
	var currentScale = layer.transform.scale.value;

	var effect = layer.Effects.addProperty("ADBE Slider Control");
	effect.name = Duik.uiStrings.scale;

	effect(1).setValue(currentScale[0]);

	layer.transform.scale.expression = "//Duik.scaleZLink\n" +
	"var sca = effect(\"" + effect.name + "\")(1);\n" +
	"var C = thisComp.layer(\"" + camera.name + "\").position;\n" +
	"var O = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
	"var oDist = " + currentDistance + ";\n" +
	"if (sca != 0) {\n" +
	"var factor = oDist / sca;\n" +
	"var dist = length(C,O);\n" +
	"var result = dist/factor;\n" +
	"result = [result,result,result];\n" +
	"result = result ;\n" +
	"result;\n" +
	"} else [0,0,0];";
}
}
}
/* SMART TIME REMAP - Duik.timeRemap(layers);

Activates the time remapping of the layers, extending them to the length of the comp and
adjusting the last keyframe.

parameters
layers | Array of Layer or LayerCollection
loopType | String, "in" or "out" or "none", default: "none"

returns
void

*/
if (typeof Duik.timeRemap !== 'function')
{
Duik.timeRemap = function (layrs,loopType)
{
if (layrs == undefined) return;
if (layrs.length == 0 ) return;
var layers = Duik.utils.convertCollectionToArray(layrs);
for (var i = 0 ; i < layers.length ; i++)
{
var layer = layers[i];
if (!layer.canSetTimeRemapEnabled) continue;

var comp = layer.containingComp;
var lastValueTime = layer.outPoint - comp.frameDuration;

if (!layer.timeRemapEnabled) layer.timeRemapEnabled = true;

layer.timeRemap.setValueAtTime(lastValueTime,layer.timeRemap.valueAtTime(lastValueTime,true));
layer.timeRemap.removeKey(3);
if (loopType == "out")
{
layer.timeRemap.setValueAtTime(lastValueTime+comp.frameDuration,0);
layer.timeRemap.expression = "loopOut();";
}
if (loopType == "in")
{
layer.timeRemap.setValueAtTime(lastValueTime+comp.frameDuration,0);
layer.timeRemap.expression = "loopIn();";
layer.inPoint = 0;
}
}
}
}
/* ONION SKIN - Duik.onionSkin(layer,activate,duration,exposure);

Activates or deactivates an onion skin on paint effects on the layer.

parameters
layer | AVLayer
onionSkin | OnionSkin

returns
void

*/
if (typeof Duik.onionSkin !== 'function')
{
	Duik.onionSkin = function (layer,onionSkin)
	{
		if (layer == undefined) return;
		if (onionSkin == undefined)
		{
		onionSkin = new OnionSkin();
		onionSkin.activated = true;
		}
		activate = onionSkin.activated;
		onionDuration = onionSkin.duration;
		exposure = onionSkin.exposure;
		inOpacity = onionSkin.inOpacity;
		outOpacity = onionSkin.outOpacity;

		var comp = layer.containingComp;
		for (var i = 1 ; i <= layer.Effects.numProperties ; i++)
		{
		var paint = layer.effect(i);
		if (paint.matchName != "ADBE Paint") continue;
		for (var j = 1 ; j <= paint.property("ADBE Paint Group").numProperties ; j++)
		{
		var stroke = paint.property("ADBE Paint Group")(j);
		if (stroke.matchName != "ADBE Paint Atom") continue;

		var inPoint = stroke.property("ADBE Paint Duration").value[0];
		var duration = stroke.property("ADBE Paint Duration").value[1];

		//adjust expo
		if (stroke.name.indexOf("#Duik") < 0)
		{
		duration = exposure*comp.frameDuration;
		stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
		stroke.name = stroke.name + " #Duik";
		}

		if (activate)
		{
			//stroke.property("ADBE Paint Transfer Mode") : blending mode
			var outPoint = duration + inPoint;
			var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
			//if keyframes (already activated)
			if (opacity.numKeys > 0)
			{
				if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0)
				{
					outPoint = opacity.keyTime(2);
				}
				else if (stroke.name.indexOf("#Out") < 0 && stroke.name.indexOf("#In") >= 0)
				{
					inPoint = opacity.keyTime(3);
				}
				else if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") >= 0)
				{
					inPoint = opacity.keyTime(3);
					outPoint = opacity.keyTime(5);
				}

				//remove keys
				while (opacity.numKeys>0)
				{
					opacity.removeKey(1);
				}
				opacity.setValue(100);
				stroke.name = stroke.name.replace(/ #Out/g,"");
				stroke.name = stroke.name.replace(/ #In/g,"");
			}

			//set duration
			if (outOpacity > 0 && inOpacity <= 0)
			{
				duration = outPoint - inPoint + onionDuration*comp.frameDuration;
				stroke.property("ADBE Paint Duration").setValue([inPoint,duration]);
			}
			else if (outOpacity <= 0 && inOpacity > 0)
			{
				duration = outPoint - inPoint + onionDuration*comp.frameDuration;
				stroke.property("ADBE Paint Duration").setValue([inPoint-onionDuration*comp.frameDuration,duration]);
			}
			else
			{
				duration = outPoint - inPoint + 2*onionDuration*comp.frameDuration;
				stroke.property("ADBE Paint Duration").setValue([inPoint-onionDuration*comp.frameDuration,duration]);
			}


			//add keyframes
			if (outOpacity > 0)
			{
			opacity.setValueAtTime(outPoint-comp.frameDuration+layer.startTime,100);
			opacity.setValueAtTime(outPoint+layer.startTime,outOpacity);
			opacity.setValueAtTime(outPoint + onionDuration*comp.frameDuration+layer.startTime,0);
			stroke.name = stroke.name + " #Out";
			}
			if (inOpacity > 0)
			{
			opacity.setValueAtTime(inPoint+layer.startTime,100);
			opacity.setValueAtTime(inPoint-onionDuration*comp.frameDuration+layer.startTime,0);
			opacity.setValueAtTime(inPoint-comp.frameDuration+layer.startTime,inOpacity);
			stroke.name = stroke.name + " #In";
			}

		}
		else
		{
			var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");
			if (opacity.numKeys > 0)
			{
			inPoint = 0;
			outPoint = 1;
			if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0)
			{
			inPoint = stroke.property("ADBE Paint Duration").value[0];
			outPoint = opacity.keyTime(2);
			}
			else if (stroke.name.indexOf("#Out") < 0 && stroke.name.indexOf("#In") >= 0)
			{
			outPoint = stroke.property("ADBE Paint Duration").value[0] + stroke.property("ADBE Paint Duration").value[1];
			inPoint = opacity.keyTime(3);
			}
			else if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") >= 0)
			{
			inPoint = opacity.keyTime(3);
			outPoint = opacity.keyTime(5);
			}


			while (opacity.numKeys>0)
			{
			opacity.removeKey(1);
			}
			opacity.setValue(100);
			//set duration
			var o = outPoint-inPoint;
			var i = inPoint;
			if (stroke.name.indexOf("#Out") >= 0 && stroke.name.indexOf("#In") < 0) o = o-layer.startTime;
			else if (stroke.name.indexOf("#Out") < 0) o = o + layer.startTime;
			if (stroke.name.indexOf("#In") >= 0) i = i-layer.startTime;
			
			stroke.property("ADBE Paint Duration").setValue([i,o]);

			stroke.name = stroke.name.replace(/ #In/g,"");
			stroke.name = stroke.name.replace(/ #Out/g,"");
			}
		}
		}
		}
		//deselect
		while(layer.selectedProperties.length > 0)
		{
		layer.selectedProperties[0].selected = false;
		}
	}
}
/* ONION SKIN - Duik.getOnionSkin(layer);

Gets current onion skin parameters from the layer.

parameters
layer | AVLayer

returns
OnionSkin object

*/
if (typeof Duik.getOnionSkin !== 'function')
{
Duik.getOnionSkin = function (layer)
{
var onionSkin = new OnionSkin();
if (layer == undefined) return onionSkin;


var comp = layer.containingComp;
for (var i = 1 ; i <= layer.Effects.numProperties ; i++)
{
var paint = layer.effect(i);
if (paint.matchName != "ADBE Paint") continue;
for (var j = 1 ; j <= paint.property("ADBE Paint Group").numProperties ; j++)
{
var stroke = paint.property("ADBE Paint Group")(j);
if (stroke.matchName != "ADBE Paint Atom") continue;

var inPoint = stroke.property("ADBE Paint Duration").value[0];
var duration = stroke.property("ADBE Paint Duration").value[1];
var outPoint = inPoint + duration;

var opacity = stroke.property("ADBE Paint Properties").property("ADBE Paint Opacity");

if (stroke.name.indexOf("#In") >=0 && stroke.name.indexOf("#Out") >=0)
{
onionSkin.activated = true;
onionSkin.duration = (opacity.keyTime(3) - inPoint)/comp.frameDuration;
onionSkin.inOpacity = opacity.keyValue(2);
onionSkin.outOpacity = opacity.keyValue(5);
onionSkin.exposure = (opacity.keyTime(4) - opacity.keyTime(3))/comp.frameDuration;
}
else if (stroke.name.indexOf("#In") >=0 && stroke.name.indexOf("#Out") < 0)
{
onionSkin.activated = true;
onionSkin.duration = (opacity.keyTime(3) - inPoint)/comp.frameDuration;
onionSkin.inOpacity = opacity.keyValue(2);
onionSkin.outOpacity = 0;
onionSkin.exposure = (outPoint - opacity.keyTime(3))/comp.frameDuration;
}
else if (stroke.name.indexOf("#In") < 0 && stroke.name.indexOf("#Out") >= 0)
{
onionSkin.activated = true;
onionSkin.duration = (opacity.keyTime(3) - opacity.keyTime(2))/comp.frameDuration;
onionSkin.inOpacity = 0;
onionSkin.outOpacity = opacity.keyValue(2);
onionSkin.exposure = (opacity.keyTime(2) - inPoint)/comp.frameDuration;
}
else
{
onionSkin.activated = false;
}
break;
}
}

return onionSkin;
}
}
/* IMPORT RIG IN COMP - Duik.importRigInComp(comp,rigComp,rigName);

Imports a rig in the comp, transferring and linking the controllers in the new comp, while keeping the rig precomposed.
The rig comp is duplicated, including precomps, renamed, and expressions are updated, so that one can import the same rig seeveral times.

parameters
comp | CompItem, the comp where to import the rig
rigComp | CompItem, the comp containing the rig
rigName | the name of this instance of the rig, must be unique in the project

returns
void

*/
if (typeof Duik.importRigInComp !== 'function')
{
Duik.importRigInComp = function (comp, characterComp, characterName)
{
app.beginSuppressDialogs();

//duplicate character comp
var characterComp = Duik.utils.duplicateComp(characterComp,characterName + "_");

//add character comp in the comp
var characterLayer = comp.layers.add(characterComp);

//Create a null object to get world coordinates of the zeros in the character comp
var tempNull = characterComp.layers.addNull();
//check if all controllers have a zero, create it if needed
//get world pos of the zeros
var zerosPos = [];
var characterZeros = [];
var characterControllers = Duik.utils.getControllers(characterComp.layers);

if (Duik.settings.displayProgressPanel) Duik.ui.showProgressPanel(characterControllers.length*4,"Preparing controllers and zeros");
var progressValue = 0;

for (var i = 0;i<characterControllers.length;i++)
{
progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue);

var zero = characterControllers[i].layer.parent;
if (zero == null || zero.name.indexOf("Zero") != 0)
{
zero = Duik.addZero(characterControllers[i].layer);
}
//get the coordinates of the zero
tempNull.transform.position.expression = "thisComp.layer(" + characterControllers[i].layer.parent.index + ").toWorld(thisComp.layer(" + characterControllers[i].layer.parent.index + ").anchorPoint)";
zerosPos.push(tempNull.transform.position.value);
characterZeros.push(zero);
}
tempNull.remove();

progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Creating new controllers");

//create the new zeros and controllers in the comp
var newZeros = [];
var newControllerLayers = [];
for (var i = characterControllers.length -1; i>=0 ; i--)
{
progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue);

var oldZero = characterZeros[i];
var newZero = comp.layers.addNull();
newZero.parent = characterLayer;
newZero.transform.position.setValue(zerosPos[i]);
newZero.name = "Zero_" + characterName + "_" + characterControllers[i].layer.name;
newZero.guideLayer = true;
newZero.shy = true;
newZero.moveToEnd();
newZero.enabled = false;
newZeros.unshift(newZero);

var oldController = characterControllers[i];
var newController = Duik.addController(newZero,false,oldController.rotation,oldController.xPosition,oldController.yPosition,oldController.scale);
newController.color = oldController.color;
newController.type = oldController.type;
newController.size = oldController.size;
newController.arc = oldController.arc;
newController.eye = oldController.eye;
newController.update();
newController.layer.name = characterName + "_" + oldController.layer.name;
newController.layer.parent = newZero;
newControllerLayers.unshift(newController.layer);

//Get the effects
for (var j = 1; j <= oldController.layer.effect.numProperties ; j++)
{
var oldEffect = oldController.layer.effect(j);
var newEffect = newController.layer.effect.addProperty(oldEffect.matchName);
newEffect.name = oldEffect.name;
//set the properties
Duik.utils.linkProperties(oldEffect,newEffect);
}

Duik.utils.linkProperties(oldController.layer.transform,newController.layer.transform);
}


progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Updating expressions");

//update expressions (controller and zeros names have changed)

for (var i in characterControllers)
{
progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,);

//controllers
try {
//check names
var oldName = characterControllers[i].layer.name;
var newName = newControllerLayers[i].name;
//update
//double quotes
var old = "layer(\"" + oldName + "\"";
var newExpr = "layer(\"" + newName + "\"";
Duik.utils.replaceInLayersExpressions(newControllerLayers,old,newExpr);
//single quotes
var old = "layer('" + oldName + "'";
var newExpr = "layer('" + newName + "'";
Duik.utils.replaceInLayersExpressions(newControllerLayers,old,newExpr);
}
catch (err2) {}
//zeros
try {
//check names
var oldName = characterZeros[i].name;
var newName = newZeros[i].name;
//update
//double quotes
var old = "layer(\"" + oldName + "\"";
var newExpr = "layer(\"" + newName + "\"";
Duik.utils.replaceInLayersExpressions(newControllerLayers,old,newExpr);
//single quotes
var old = "layer('" + oldName + "'";
var newExpr = "layer('" + newName + "'";
Duik.utils.replaceInLayersExpressions(newControllerLayers,old,newExpr);
}
catch (err2) {}
}


progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Linking and locking zeros");

//link and lock the zeros in the comp
for  (var i in characterZeros)
{
progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue);

var newZero = newZeros[i];
//Link zero
if (characterZeros[i].parent != null)
{
for (var j = 1 ; j <= comp.numLayers ; j++)
{
if (comp.layer(j).name == characterName + "_" + characterZeros[i].parent.name)
{
newZero.parent = comp.layer(j);
break;
}
}
}
newZero.locked = true;
}


progressValue++;
if (Duik.settings.displayProgressPanel) Duik.ui.updateProgressPanel(progressValue,"Setting up master controller");

//And finally, a master ctrl to control them all!
var masterC = Duik.addController(characterLayer,false,true,true,true,true,false);
masterC.layer.transform.position.setValue([masterC.layer.transform.position.value[0],comp.height-20]);
masterC.layer.name = "MASTER_" + characterName;
var flip = masterC.layer.effect.addProperty("ADBE Checkbox Control");
flip.name = Duik.uiStrings.flip;
masterC.layer.transform.scale.expression = "//Duik.importRig\n" +
"var flip = thisLayer.effect(\"" + flip.name + "\")(1).value\n" +
"if (flip) [-value[0],value[1]]\n" +
"else value";
characterLayer.parent = masterC.layer;
characterLayer.locked = true;

if (Duik.settings.displayProgressPanel) Duik.ui.hideProgressPanel();

app.endSuppressDialogs(false);
}
}
/* DUPLICATE RIG - Duik.duplicateRig(rigComp,rigName);

Duplicates a rig, including precomps, renamed, and expressions are updated, so that one can duplicate the same rig several times.

parameters
rigComp | CompItem, the comp containing the rig
rigName | the name of this instance of the rig, must be unique in the project

returns
void

*/
if (typeof Duik.duplicateRig !== 'function')
{
Duik.duplicateRig = function (characterComp, characterName)
{
app.beginSuppressDialogs();

//duplicate character comp
var characterComp = Duik.utils.duplicateComp(characterComp,characterName + "_");


app.endSuppressDialogs(false);
}
}
/* MOVE AWAY - Duik.moveAway(layer);

Rigs the position of the layer to be able to move it away from its parent with a simple slider.

parameters
layer | AVLayer

returns
void

*/
if (typeof Duik.moveAway !== 'function')
{
Duik.moveAway = function (layer)
{
if (layer == undefined) return;
var effect = layer.Effects.addProperty("ADBE Slider Control");
effect.name = Duik.uiStrings.moveAway;

layer.transform.position.expression = "//Duik.moveAway\n" +
"if (thisLayer.hasParent)\n" +
"{\n" +
"thisWorldPos = thisLayer.toWorld(thisLayer.anchorPoint);\n" +
"parentWorldPos = thisLayer.parent.toWorld(thisLayer.parent.anchorPoint);\n" +
"depl = effect(\"" + effect.name  + "\")(1)\n" +
"dist = length(parentWorldPos ,thisWorldPos )\n" +
"coef = (dist+depl)/dist\n" +
"newWorldPos = (thisWorldPos-parentWorldPos)*coef+parentWorldPos\n" +
"thisLayer.parent.fromWorld(newWorldPos)\n" +
"}\n" +
"else\n" +
"{\n" +
"value\n" +
"}\n";
}
}
/* RANDOMIZE - Duik.randomizeProperties(props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax);

Randomizes the values of the properties.
Min and max values for each axis can be undefined: in this case, the axis won't be randomized.

parameters
props | Array of PropertyBase
fromCurrentVal | boolean, if true, min and max values are added to current property value

returns
void

*/
if (typeof Duik.randomizeProperties !== 'function')
{
Duik.randomizeProperties = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax)
{
if (props == undefined) throw "You must select the properties you want to randomize";
if (props.length == 0) throw "You must select the properties you want to randomize";
var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));

for (var i = 0;i<props.length;i++)
{
var prop = props[i];
if (prop.propertyType == PropertyType.PROPERTY)
{
//Get containing comp
var comp = Duik.utils.getPropertyComp(prop);
var dim = Duik.utils.getPropertyDimensions(prop);
var xval = 0;
var yval = 0;
var zval = 0;
//X
if (x) xval = Duik.js.random(xMin,xMax);
else if (dim == 1) xval = prop.value;
else xval = prop.value[0];
//Y
if (dim == 2 || dim == 3 && y) yval = Duik.js.random(yMin,yMax);
else if (dim == 3 || dim == 2) yval = 0;
//Z
if (dim == 3 && z) zval = Duik.js.random(zMin,zMax);
else if (dim == 3) zval = 0;
//SET VALUE
var val;
if (dim == 1) val = xval;
if (dim == 2) val = [xval,yval];
if (dim == 3) val = [xval,yval,zval];
if (fromCurrentVal) val = val + prop.value;
prop.numKeys ? prop.setValueAtTime(comp.time,val) : prop.setValue(val);
}
}
}
}
/* RANDOMIZE - Duik.randomizeSelectedKeys(props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax);

Randomizes the values of the selected keyframes of the properties.
Min and max values for each axis can be undefined: in this case, the axis won't be randomized.

parameters
props | Array of PropertyBase
fromCurrentVal | boolean, if true, min and max values are added to current property value

returns
void

*/
if (typeof Duik.randomizeSelectedKeys !== 'function')
{
Duik.randomizeSelectedKeys = function (props,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax)
{
if (props == undefined) throw "You must select the keyframes you want to randomize";
if (props.length == 0) throw "You must select the keyframes you want to randomize";
var x = (xMin != undefined && xMax != undefined && !isNaN(xMin) && !isNaN(xMax));
var y = (yMin != undefined && yMax != undefined && !isNaN(yMin) && !isNaN(yMax));
var z = (zMin != undefined && zMax != undefined && !isNaN(zMin) && !isNaN(zMax));
for (var i = 0;i<props.length;i++)
{
var prop = props[i];
if (prop.propertyType == PropertyType.PROPERTY)
{
//Get containing comp and dimensions
var comp = Duik.utils.getPropertyComp(prop);
var dim = Duik.utils.getPropertyDimensions(prop);
//loop through selected keyframes
for (var j = 0 ; j < prop.selectedKeys.length; j++)
{
var key = prop.selectedKeys[j];
var xval = 0;
var yval = 0;
var zval = 0;
//X
if (x) xval = Duik.js.random(xMin,xMax);
else if (dim == 1) xval = prop.value;
else xval = prop.value[0];
//Y
if (dim == 2 || dim == 3 && y) yval = Duik.js.random(yMin,yMax);
else if (dim == 3 || dim == 2) yval = 0;
//Z
if (dim == 3 && z) zval = Duik.js.random(zMin,zMax);
else if (dim == 3) zval = 0;
//SET VALUE
var val;
if (dim == 1) val = xval;
if (dim == 2) val = [xval,yval];
if (dim == 3) val = [xval,yval,zval];
if (fromCurrentVal) val = val + prop.keyValue(key);
prop.setValueAtKey(key,val);
}
}
}
}
}
/* RANDOMIZE - Duik.randomizeSelectedKeys(layrs,fromCurrentVal,xMin,xMax,yMin,yMax,zMin,zMax);

Randomizes the values of the selected keyframes of the properties.
Min and max values for each axis can be undefined: in this case, the axis won't be randomized.

parameters
layrs | Array or Collection of Layers
fromCurrentVal | boolean, if true, min and max values are added to current property value

returns
void

*/
if (typeof Duik.randomizeSelectedKeyTimes !== 'function')
{
Duik.randomizeSelectedKeyTimes = function (layrs,fromCurrentVal,min,max)
{
if (layrs == undefined) throw "You must select the keyframes you want to randomize";
if (layrs.length == 0) throw "You must select the keyframes you want to randomize";
var x = (min != undefined && max != undefined && !isNaN(min) && !isNaN(max));
if (!x) throw "You must define a randomizing range";

var layers = Duik.utils.convertCollectionToArray(layrs);

//array to list keys to be removed
var krProps = [];
var krKeys = [];

for (var l = 0 ; l < layers.length; l++)
{
var layer = layers[l];
var props = layer.selectedProperties;
for (var i = 0;i<props.length;i++)
{
var prop = props[i];
krProps.push(prop);
var krK = [];
if (prop.propertyType == PropertyType.PROPERTY)
{
//Get containing comp and dimensions
var comp = Duik.utils.getPropertyComp(prop);
var dim = Duik.utils.getPropertyDimensions(prop);
//loop through selected keyframes
for (var j = 0 ; j < prop.selectedKeys.length; j++)
{
var key = prop.selectedKeys[j];
var t = Duik.js.random(min,max)*comp.frameDuration;
//SET VALUE
if (fromCurrentVal) r += prop.keyTime(key);
var oldKey = Duik.utils.getKey(prop,key);
krK.push(prop.keyTime(key));
Duik.utils.addKey(prop,oldKey,t);
}
}
krKeys.push(krK);
}
}

for (var i = 0 ; i < krProps.length ; i++)
{
var prop = krProps[i];
for (var j = 0 ; j < krKeys[i].length ; j++)
{
prop.removeKey(prop.nearestKeyIndex(krKeys[i][j]));
}
}
}
}
/* RANDOMIZE - Duik.randomizeStartTimes(layers,fromCurrentVal,min,max);

Randomizes start times of the given layers.
Min and Max in seconds (comp time).

parameters
layers | Array of Layers or LayerCollection
fromCurrentVal | boolean, if true, min and max values are added to current property value

returns
void

*/
if (typeof Duik.randomizeStartTimes !== 'function')
{
	Duik.randomizeStartTimes = function (layrs,fromCurrentVal,min,max)
	{
		if (layrs == undefined) return;
		if (layrs.length == 0 ) return;

		var layers = Duik.utils.convertCollectionToArray(layrs);
		for (var i = 0; i< layers.length;i++)
		{
			var l = layers[i];
			var comp = l.containingComp;
			var startTime = Duik.js.random(min,max)*comp.frameDuration;
			if (fromCurrentVal) l.startTime = l.startTime + startTime;
			else l.startTime = startTime;
		}
	}
}
/* RANDOMIZE - Duik.randomizeInPoints(layers,fromCurrentVal,min,max);

Randomizes start times of the given layers.
Min and Max in seconds (comp time).

parameters
layers | Array of Layers or LayerCollection
fromCurrentVal | boolean, if true, min and max values are added to current property value

returns
void

*/
if (typeof Duik.randomizeInPoints !== 'function')
{
Duik.randomizeInPoints = function (layrs,fromCurrentVal,min,max)
{
if (layrs == undefined) return;
if (layrs.length == 0 ) return;

var layers = Duik.utils.convertCollectionToArray(layrs);

for (var i = 0; i< layers.length;i++)
{
var l = layers[i];
var comp = l.containingComp;
var inPoint = Duik.js.random(min,max)*comp.frameDuration;
if (fromCurrentVal) l.inPoint = l.inPoint + inPoint;
else l.inPoint = inPoint;
}
}
}
/* RANDOMIZE - Duik.randomizeOutPoints(layers,fromCurrentVal,min,max);

Randomizes start times of the given layers.
Min and Max in seconds (comp time).

parameters
layers | Array of Layers or LayerCollection
fromCurrentVal | boolean, if true, min and max values are added to current property value

returns
void

*/
if (typeof Duik.randomizeOutPoints !== 'function')
{
Duik.randomizeOutPoints = function (layrs,fromCurrentVal,min,max)
{
if (layrs == undefined) return;
if (layrs.length == 0 ) return;

var layers = Duik.utils.convertCollectionToArray(layrs);

for (var i = 0; i< layers.length;i++)
{
var l = layers[i];
var comp = l.containingComp;
var outPoint = Duik.js.random(min,max)*comp.frameDuration;
if (fromCurrentVal) l.outPoint = l.outPoint + outPoint;
else l.outPoint = outPoint;
}
}
}
/* GROUP PAINT - Duik.groupPaint(props);

Rigs the paint effects to be able to animate all strokes as if there was only one.

parameters
props | Array of Properties

returns
void

*/
if (typeof Duik.groupPaint !== 'function')
{
Duik.groupPaint = function (props)
{
if (props == undefined) return;
if (props.length == 0) return;
//get selection
var selection = [];
for (var i = 0 ; i < props.length ; i++)
{
var stroke = props[i];
if (stroke.matchName != "ADBE Paint Atom") continue;
if (stroke.selected) selection.push(stroke.propertyIndex);
}
if (selection.length == 0) return;

//add effect
var effect;
var layer = Duik.utils.getPropertyLayer(props[0]);
effect = Duik.utils.addEffect(layer,Duik.effects.Paint_Group);

var paintEffect = layer("Effects")("ADBE Paint");
var firstStroke = paintEffect.property(2).property(selection[0]);

Duik.utils.renameEffect(effect,firstStroke.name + " " + Duik.uiStrings.paintGroup);

//anchorPoint
effect(8).setValue(firstStroke.property(5).property(1).value);
firstStroke.property(5).property(1).expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(8);";
//position
effect(9).setValue(firstStroke.property(5).property(2).value);
firstStroke.property(5).property(2).expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(9);";
//scale
effect(10).setValue(firstStroke.property(5).property(3).value[0]);
firstStroke.property(5).property(3).expression = "//Duik.groupPaint\n" +
"var sca = effect(\"" + effect.name + "\")(10);\n" +
"[sca,sca]";
//rotation
effect(11).setValue(firstStroke.property(5).property(4).value);
firstStroke.property(5).property(4).expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(11);";

//start
firstStroke.property(4).property(1).expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(2);\n";
//end
firstStroke.property(4).property(2).expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(3);\n";
//color
firstStroke.property(4).property(3).expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(4);\n";
//diameter
firstStroke.property(4).property(4).expression = "//Duik.groupPaint\n" +
"value+effect(\"" + effect.name + "\")(5);\n";


//for each stroke
for (var j=1;j<selection.length;j++)
{
var stroke = paintEffect.property(2).property(selection[j]);
var propStart = stroke.property(4).property(1);
var propEnd = stroke.property(4).property(2);
var propColor = stroke.property(4).property(3);
var propDiam = stroke.property(4).property(4);

propStart.expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(2);\n";

propEnd.expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(3);";

propColor.expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(4);";

propDiam.expression = "//Duik.groupPaint\n" +
"value+effect(\"" + effect.name + "\")(5);";

stroke.property(5).property(1).expression = "//Duik.groupPaint\n" +
"-" + stroke.property(5).property(2).value.toSource() + " + " + effect(9).value.toSource() + " + effect(\"" + effect.name + "\")(8);\n";
stroke.property(5).property(2).expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(9);";
stroke.property(5).property(3).expression = "//Duik.groupPaint\n" +
"var sca = effect(\"" + effect.name + "\")(10);\n" +
"[sca,sca]";
stroke.property(5).property(4).expression = "//Duik.groupPaint\n" +
"effect(\"" + effect.name + "\")(11);";
}
}
}
/* LIST - Duik.list(prop);

Creates a list on the prop.

parameters
prop | Property

returns
void

*/
if (typeof Duik.list !== 'function')
{
Duik.list = function (prop)
{
if (prop == undefined) return;

var dim = Duik.utils.getPropertyDimensions(prop);
var layer = Duik.utils.getPropertyLayer(prop);
var comp = layer.containingComp;

if (dim == 1)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.OneD_List);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.list);

//set value
effect(2).setValue(prop.value);

//copy expression
effect(2).expression = prop.expression;

prop.expression = "//Duik.list\r\n" +
"var v1 = effect(\"" + effect.name + "\")(2);\n" +
"var w1 = effect(\"" + effect.name + "\")(3);\n" +
"var v2 = effect(\"" + effect.name + "\")(6);\n" +
"var w2 = effect(\"" + effect.name + "\")(7);\n" +
"var v3 = effect(\"" + effect.name + "\")(10);\n" +
"var w3 = effect(\"" + effect.name + "\")(11);\n" +
"var v4 = effect(\"" + effect.name + "\")(14);\n" +
"var w4 = effect(\"" + effect.name + "\")(15);\n" +
"var v5 = effect(\"" + effect.name + "\")(18);\n" +
"var w5 = effect(\"" + effect.name + "\")(19);\n" +
"v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;";
}
else if (dim == 2)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.TwoD_List);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.list);

effect(2).setValue([prop.value[0],prop.value[1]]);

if (prop.expression != "") effect(2).expression = prop.expression;

prop.expression = "//Duik.list\r\n" +
"var v1 = effect(\"" + effect.name + "\")(2);\n" +
"var w1 = effect(\"" + effect.name + "\")(3);\n" +
"var v2 = effect(\"" + effect.name + "\")(6);\n" +
"var w2 = effect(\"" + effect.name + "\")(7);\n" +
"var v3 = effect(\"" + effect.name + "\")(10);\n" +
"var w3 = effect(\"" + effect.name + "\")(11);\n" +
"var v4 = effect(\"" + effect.name + "\")(14);\n" +
"var w4 = effect(\"" + effect.name + "\")(15);\n" +
"var v5 = effect(\"" + effect.name + "\")(18);\n" +
"var w5 = effect(\"" + effect.name + "\")(19);\n" +
"v1*w1/100+v2*w2/100+v3*w3/100+v4*w4/100+v5*w5/100;";
}
else if (dim == 3)
{
var prep = Duik.utils.rigProperty(layer,prop,Duik.effects.ThreeD_List);
var effect = prep[0];
prop = prep[1];
if (effect == null) return false;
Duik.utils.renameEffect(effect,prop.name + " " + Duik.uiStrings.list);

effect(2).setValue([prop.value[0],prop.value[1]]);
effect(3).setValue(prop.value[2]);

if (prop.expression != "") effect(2).expression = prop.expression;


prop.expression = "//Duik.list\r\n" +
"var v1 = effect(\"" + effect.name + "\")(2);\n" +
"var z1 = effect(\"" + effect.name + "\")(3);\n" +
"var w1 = effect(\"" + effect.name + "\")(4);\n" +
"var v2 = effect(\"" + effect.name + "\")(7);\n" +
"var z2 = effect(\"" + effect.name + "\")(8);\n" +
"var w2 = effect(\"" + effect.name + "\")(9);\n" +
"var v3 = effect(\"" + effect.name + "\")(12);\n" +
"var z3 = effect(\"" + effect.name + "\")(13);\n" +
"var w3 = effect(\"" + effect.name + "\")(14);\n" +
"var v4 = effect(\"" + effect.name + "\")(17);\n" +
"var z4 = effect(\"" + effect.name + "\")(18);\n" +
"var w4 = effect(\"" + effect.name + "\")(19);\n" +
"var v5 = effect(\"" + effect.name + "\")(22);\n" +
"var z5 = effect(\"" + effect.name + "\")(23);\n" +
"var w5 = effect(\"" + effect.name + "\")(24);\n" +
"[v1[0],v1[1],z1]*w1/100+[v2[0],v2[1],z2]*w2/100+[v3[0],v3[1],z3]*w3/100+[v4[0],v4[1],z4]*w4/100+[v5[0],v5[1],z5]*w5/100;";
}

return true;
}
}

}());

